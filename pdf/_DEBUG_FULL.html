<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Archimedes Indexer - GuÃ­a Completa</title>
</head>
<body>
    
        <div class="cover-page">
            <div class="cover-title">Archimedes Indexer</div>
            <div class="cover-subtitle">De Python BÃ¡sico a Pathway MS AI (CU Boulder)</div>
            <div class="cover-meta">DUQUEOM Â· 2025 Â· VersiÃ³n 1.0</div>
        </div>
        
        <div id="mod_index" class="cover-page">
            <a name="mod_index"></a>
            <div class="cover-title">Landing Page</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>Archimedes Indexer - GuÃ­a Educativa</h1>
<blockquote>
<p><strong>Un Motor de BÃºsqueda y RecomendaciÃ³n Construido desde Cero</strong></p>
</blockquote>
<p>Esta guÃ­a es un programa de formaciÃ³n intensivo de 6 meses diseÃ±ado para transformar un perfil de Python bÃ¡sico en un candidato preparado para el <a href="https://www.coursera.org/degrees/ms-artificial-intelligence-boulder">MS in Artificial Intelligence de CU Boulder</a>.</p>
<hr />
<h2>ğŸ“š Ãndice Principal</h2>
<p>ğŸ‘‰ <strong><a href="#mod_00_INDICE">Ir al Ãndice Completo â†’</a></strong></p>
<hr />
<h2>ğŸ¯ Â¿QuÃ© es Archimedes Indexer?</h2>
<p>Un proyecto integral que te obliga a:</p>
<table>
<thead>
<tr>
<th>Componente</th>
<th>Habilidad Desarrollada</th>
</tr>
</thead>
<tbody>
<tr>
<td>Arquitectura OOP</td>
<td>DiseÃ±o de clases profesional</td>
</tr>
<tr>
<td>Ãndice Invertido</td>
<td>Hash Maps, Memoria, DSA</td>
</tr>
<tr>
<td>Algoritmos de BÃºsqueda</td>
<td>QuickSort, Binary Search, RecursiÃ³n</td>
</tr>
<tr>
<td>Ranking ML</td>
<td>TF-IDF, Similitud de Coseno, Ãlgebra Lineal</td>
</tr>
<tr>
<td>AnÃ¡lisis de Complejidad</td>
<td>Big O Notation, MatemÃ¡ticas Discretas</td>
</tr>
</tbody>
</table>
<p><strong>RestricciÃ³n crÃ­tica:</strong> Todo en Python puro. Sin <code>numpy</code>, <code>pandas</code>, <code>sklearn</code>.</p>
<hr />
<h2>ğŸ—‚ï¸ Estructura de la GuÃ­a</h2>
<h3>Fases del Proyecto</h3>
<table>
<thead>
<tr>
<th>Fase</th>
<th>MÃ³dulos</th>
<th>Enfoque</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>I. Fundamentos</strong></td>
<td>01-03</td>
<td>Python profesional, OOP, LÃ³gica</td>
</tr>
<tr>
<td><strong>II. Estructuras de Datos</strong></td>
<td>04-06</td>
<td>Hash Maps, Ãndices, Memoria</td>
</tr>
<tr>
<td><strong>III. Algoritmos</strong></td>
<td>07-09</td>
<td>Sorting, Searching, RecursiÃ³n</td>
</tr>
<tr>
<td><strong>IV. MatemÃ¡ticas para ML</strong></td>
<td>10-11</td>
<td>Ãlgebra Lineal, TF-IDF, Coseno</td>
</tr>
<tr>
<td><strong>V. IntegraciÃ³n</strong></td>
<td>12</td>
<td>Proyecto completo, AnÃ¡lisis Big O</td>
</tr>
</tbody>
</table>
<h3>Material Complementario</h3>
<ul>
<li>ğŸ“ <a href="#mod_EJERCICIOS">Ejercicios PrÃ¡cticos</a></li>
<li>âœ… <a href="#mod_EJERCICIOS_SOLUCIONES">Soluciones Detalladas</a></li>
<li>ğŸ“Š <a href="#mod_RUBRICA_EVALUACION">RÃºbrica de EvaluaciÃ³n</a></li>
<li>ğŸ“– <a href="#mod_GLOSARIO">Glosario TÃ©cnico</a></li>
<li>â˜‘ï¸ <a href="#mod_CHECKLIST">Checklist Final</a></li>
<li>ğŸ¯ <a href="#mod_SIMULACRO_ENTREVISTA">Simulacro de Entrevista</a></li>
</ul>
<hr />
<h2>ğŸš€ Quick Start</h2>
<pre><code class="language-bash"># Clonar el repositorio
git clone &lt;repo-url&gt;
cd archimedes-indexer

# Crear entorno virtual
python -m venv venv
source venv/bin/activate  # Linux/Mac
# o: venv\Scripts\activate  # Windows

# Verificar Python puro (sin dependencias externas)
python -c &quot;print('Ready to build from scratch!')&quot;
</code></pre>
<h3>Levantar la documentaciÃ³n localmente</h3>
<pre><code class="language-bash">pip install mkdocs mkdocs-material
mkdocs serve
# Abrir http://localhost:8000
</code></pre>
<hr />
<h2>ğŸ“… Tiempo Estimado</h2>
<table>
<thead>
<tr>
<th>DedicaciÃ³n</th>
<th>DuraciÃ³n Total</th>
</tr>
</thead>
<tbody>
<tr>
<td>6 horas/dÃ­a (L-S)</td>
<td>6 meses</td>
</tr>
<tr>
<td>3 horas/dÃ­a</td>
<td>10-12 meses</td>
</tr>
<tr>
<td>Fin de semana intensivo</td>
<td>12-15 meses</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ”— Enlaces Clave</h2>
<ul>
<li><a href="https://www.coursera.org/degrees/ms-artificial-intelligence-boulder">MS in AI - CU Boulder</a></li>
<li><a href="https://www.coursera.org/degrees/ms-artificial-intelligence-boulder/admissions">Pathway de AdmisiÃ³n</a></li>
<li><a href="https://www.coursera.org/specializations/mathematics-machine-learning">Mathematics for ML Specialization</a></li>
</ul>
<hr />
<blockquote>
<p>ğŸ’¡ <strong>FilosofÃ­a:</strong> Si puedes construir un motor de bÃºsqueda desde cero y defender su anÃ¡lisis Big O, cualquier reclutador o comitÃ© de admisiÃ³n sabrÃ¡ que dominas los cimientos de CS.</p>
</blockquote>
        </section>
        
        <div id="mod_00_INDICE" class="cover-page">
            <a name="mod_00_INDICE"></a>
            <div class="cover-title">Ãndice Principal</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>ğŸ“š Archimedes Indexer - Ãndice Principal</h1>
<blockquote>
<p><strong>De Python BÃ¡sico a Ingeniero de IA: Construyendo un Motor de BÃºsqueda desde Cero</strong></p>
</blockquote>
<hr />
<h2>ğŸ¯ Â¿QuÃ© LograrÃ¡s al Completar Esta GuÃ­a?</h2>
<table>
<thead>
<tr>
<th>Habilidad</th>
<th>Nivel Alcanzado</th>
<th>Evidencia</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>OOP Profesional</strong></td>
<td>Avanzado</td>
<td>Clases <code>Document</code>, <code>Corpus</code>, <code>InvertedIndex</code> con diseÃ±o SOLID</td>
</tr>
<tr>
<td><strong>Estructuras de Datos</strong></td>
<td>Intermedio-Avanzado</td>
<td>Hash Maps, Tries, Listas enlazadas implementadas desde cero</td>
</tr>
<tr>
<td><strong>Algoritmos</strong></td>
<td>Intermedio-Avanzado</td>
<td>QuickSort, Binary Search, recursiÃ³n dominada</td>
</tr>
<tr>
<td><strong>Ãlgebra Lineal Aplicada</strong></td>
<td>Intermedio</td>
<td>TF-IDF y Similitud de Coseno sin numpy</td>
</tr>
<tr>
<td><strong>AnÃ¡lisis de Complejidad</strong></td>
<td>Intermedio</td>
<td>DocumentaciÃ³n Big O de todo el sistema</td>
</tr>
<tr>
<td><strong>InglÃ©s TÃ©cnico</strong></td>
<td>B2+</td>
<td>Todo el material y cÃ³digo en inglÃ©s</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ‘¤ Perfil de Entrada</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PERFIL IDEAL DE ENTRADA                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  âœ… Python bÃ¡sico (variables, funciones, listas, diccionarios) â”‚
â”‚  âœ… LÃ³gica de programaciÃ³n (if/else, loops)                    â”‚
â”‚  âœ… Ganas de entender &quot;cÃ³mo funciona por dentro&quot;               â”‚
â”‚  âœ… MatemÃ¡ticas de bachillerato (Ã¡lgebra bÃ¡sica)               â”‚
â”‚  âš ï¸  NO se requiere: numpy, pandas, sklearn, ML previo         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ”„ MetodologÃ­a de Aprendizaje</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CICLO DE APRENDIZAJE                              â”‚
â”‚                                                                      â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚    â”‚  LEER   â”‚â”€â”€â”€â–¶â”‚ ENTENDERâ”‚â”€â”€â”€â–¶â”‚CODIFICARâ”‚â”€â”€â”€â–¶â”‚ ANALIZARâ”‚        â”‚
â”‚    â”‚ TeorÃ­a  â”‚    â”‚ AnalogÃ­aâ”‚    â”‚ Scratch â”‚      â”‚  Big O  â”‚        â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚         â”‚                                              â”‚             â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                        ITERAR                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p><strong>Leer:</strong> Estudiar el concepto teÃ³rico y su contexto.<br />
<strong>Entender:</strong> Asimilar mediante analogÃ­as y ejemplos visuales.<br />
<strong>Codificar:</strong> Implementar desde cero en Python puro.<br />
<strong>Analizar:</strong> Documentar la complejidad y eficiencia.</p>
<hr />
<h2>ğŸ—ºï¸ Roadmap Visual (6 Meses)</h2>
<pre><code>MES 1            MES 2          MES 3          MES 4          MES 5          MES 6
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚FUNDAMENâ”‚     â”‚ESTRUCTUâ”‚    â”‚DSA     â”‚     â”‚DSA     â”‚    â”‚MATEMÃT-â”‚     â”‚INTEGRA-â”‚
â”‚  TOS   â”‚â”€â”€â”€â–¶â”‚RAS I   â”‚â”€â”€â”€â–¶â”‚AVANZADOâ”‚â”€â”€â”€â–¶â”‚AVANZADOâ”‚â”€â”€â”€â–¶â”‚  ICAS  â”‚â”€â”€â”€â–¶â”‚  CIÃ“N  â”‚
â”‚01-03   â”‚     â”‚04-06   â”‚    â”‚13-15   â”‚     â”‚07-09   â”‚    â”‚10-11   â”‚     â”‚  12    â”‚
â”‚        â”‚     â”‚        â”‚    â”‚        â”‚     â”‚16-18   â”‚    â”‚        â”‚     â”‚        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚              â”‚              â”‚              â”‚              â”‚              â”‚
    â–¼              â–¼              â–¼              â–¼              â–¼              â–¼
 Python        HashMap        LinkedList     Trees+DP       TF-IDF       PROYECTO
  +OOP          +Index        +Stack+Queue   +Greedy+Heap   +Coseno      COMPLETO
</code></pre>
<hr />
<h2>ğŸ“– MÃ³dulos de la GuÃ­a</h2>
<h3>FASE I: Fundamentos (Mes 1)</h3>
<p><em>Objetivo: Establecer bases sÃ³lidas de Python profesional y pensamiento computacional</em></p>
<table>
<thead>
<tr>
<th>#</th>
<th>MÃ³dulo</th>
<th>DescripciÃ³n</th>
<th>Tiempo</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td><a href="#mod_01_PYTHON_PROFESIONAL">Python Profesional</a></td>
<td>Type hints, funciones puras, estilo PEP8</td>
<td>2 semanas</td>
</tr>
<tr>
<td>02</td>
<td><a href="#mod_02_OOP_DESDE_CERO">OOP desde Cero</a></td>
<td>Clases, herencia, composiciÃ³n, SOLID bÃ¡sico</td>
<td>1.5 semanas</td>
</tr>
<tr>
<td>03</td>
<td><a href="#mod_03_LOGICA_DISCRETA">LÃ³gica y MatemÃ¡ticas Discretas</a></td>
<td>Conjuntos, lÃ³gica proposicional, demostraciones</td>
<td>0.5 semanas</td>
</tr>
</tbody>
</table>
<p><strong>Checkpoint Fase I:</strong> <a href="#mod_SIMULACRO_ENTREVISTA">Simulacro Fundamentos</a></p>
<hr />
<h3>FASE II: Estructuras de Datos (Mes 2-3)</h3>
<p><em>Objetivo: Dominar las estructuras que hacen rÃ¡pidos a los sistemas reales</em></p>
<table>
<thead>
<tr>
<th>#</th>
<th>MÃ³dulo</th>
<th>DescripciÃ³n</th>
<th>Tiempo</th>
</tr>
</thead>
<tbody>
<tr>
<td>04</td>
<td><a href="#mod_04_ARRAYS_STRINGS">Arrays, Strings y Memoria</a></td>
<td>ManipulaciÃ³n de secuencias, complejidad bÃ¡sica</td>
<td>1.5 semanas</td>
</tr>
<tr>
<td>05</td>
<td><a href="#mod_05_HASHMAPS_SETS">Hash Maps y Sets</a></td>
<td>Diccionarios, hashing, colisiones, O(1) lookup</td>
<td>2 semanas</td>
</tr>
<tr>
<td>06</td>
<td><a href="#mod_06_INVERTED_INDEX">Ãndice Invertido</a></td>
<td>ConstrucciÃ³n del nÃºcleo del motor de bÃºsqueda</td>
<td>2.5 semanas</td>
</tr>
</tbody>
</table>
<p><strong>Checkpoint Fase II:</strong> <a href="#mod_SIMULACRO_ENTREVISTA">Simulacro Estructuras</a></p>
<hr />
<h3>FASE III: Estructuras de Datos Avanzadas (Mes 3) â­ CRÃTICO PATHWAY</h3>
<p><em>Objetivo: Dominar estructuras que aparecen en el Pathway</em></p>
<table>
<thead>
<tr>
<th>#</th>
<th>MÃ³dulo</th>
<th>DescripciÃ³n</th>
<th>Tiempo</th>
</tr>
</thead>
<tbody>
<tr>
<td>13</td>
<td><a href="#mod_13_LINKED_LISTS_STACKS_QUEUES">Linked Lists, Stacks, Queues</a></td>
<td>Estructuras lineales fundamentales</td>
<td>1.5 semanas</td>
</tr>
<tr>
<td>14</td>
<td><a href="#mod_14_TREES">Ãrboles y BST</a></td>
<td>Binary trees, traversals, BST</td>
<td>2 semanas</td>
</tr>
<tr>
<td>15</td>
<td><a href="#mod_15_GRAPHS">Grafos, BFS, DFS</a></td>
<td>RepresentaciÃ³n, recorridos</td>
<td>2 semanas</td>
</tr>
</tbody>
</table>
<p><strong>Checkpoint Fase III:</strong> <a href="#mod_SIMULACRO_ENTREVISTA">Simulacro DSA Avanzado</a></p>
<hr />
<h3>FASE IV: Algoritmos (Mes 4) â­ CRÃTICO PATHWAY</h3>
<p><em>Objetivo: Implementar algoritmos clÃ¡sicos de ordenamiento, bÃºsqueda y optimizaciÃ³n</em></p>
<table>
<thead>
<tr>
<th>#</th>
<th>MÃ³dulo</th>
<th>DescripciÃ³n</th>
<th>Tiempo</th>
</tr>
</thead>
<tbody>
<tr>
<td>07</td>
<td><a href="#mod_07_RECURSION">RecursiÃ³n y Divide &amp; Conquer</a></td>
<td>Pensamiento recursivo, casos base, call stack</td>
<td>1 semana</td>
</tr>
<tr>
<td>08</td>
<td><a href="#mod_08_SORTING">Algoritmos de Ordenamiento</a></td>
<td>QuickSort, MergeSort desde cero</td>
<td>1 semana</td>
</tr>
<tr>
<td>09</td>
<td><a href="#mod_09_BINARY_SEARCH">BÃºsqueda Binaria</a></td>
<td>ImplementaciÃ³n perfecta, variantes</td>
<td>1 semana</td>
</tr>
<tr>
<td>16</td>
<td><a href="#mod_16_DYNAMIC_PROGRAMMING">Dynamic Programming</a></td>
<td>Memoization, tabulation, problemas clÃ¡sicos</td>
<td>2 semanas</td>
</tr>
<tr>
<td>17</td>
<td><a href="#mod_17_GREEDY">Greedy Algorithms</a></td>
<td>CuÃ¡ndo y cÃ³mo usar estrategia greedy</td>
<td>1 semana</td>
</tr>
<tr>
<td>18</td>
<td><a href="#mod_18_HEAPS">Heaps y Priority Queues</a></td>
<td>Top K, merge K lists</td>
<td>1 semana</td>
</tr>
</tbody>
</table>
<p><strong>Checkpoint Fase IV:</strong> <a href="#mod_SIMULACRO_ENTREVISTA">Simulacro Algoritmos</a></p>
<hr />
<h3>FASE V: MatemÃ¡ticas para ML (Mes 5)</h3>
<p><em>Objetivo: Implementar la matemÃ¡tica del ranking sin librerÃ­as</em></p>
<table>
<thead>
<tr>
<th>#</th>
<th>MÃ³dulo</th>
<th>DescripciÃ³n</th>
<th>Tiempo</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td><a href="#mod_10_ALGEBRA_LINEAL">Ãlgebra Lineal sin NumPy</a></td>
<td>Vectores, matrices, operaciones desde cero</td>
<td>2 semanas</td>
</tr>
<tr>
<td>11</td>
<td><a href="#mod_11_TFIDF_COSENO">TF-IDF y Similitud de Coseno</a></td>
<td>VectorizaciÃ³n de texto, ranking por relevancia</td>
<td>2 semanas</td>
</tr>
</tbody>
</table>
<p><strong>Checkpoint Fase V:</strong> <a href="#mod_SIMULACRO_ENTREVISTA">Simulacro MatemÃ¡ticas</a></p>
<hr />
<h3>FASE VI: IntegraciÃ³n (Mes 6)</h3>
<p><em>Objetivo: Ensamblar todo en un proyecto defendible</em></p>
<table>
<thead>
<tr>
<th>#</th>
<th>MÃ³dulo</th>
<th>DescripciÃ³n</th>
<th>Tiempo</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td><a href="#mod_12_PROYECTO_INTEGRADOR">Proyecto Integrador</a></td>
<td>Motor de bÃºsqueda completo + anÃ¡lisis Big O</td>
<td>4 semanas</td>
</tr>
</tbody>
</table>
<p><strong>Checkpoint Final:</strong> <a href="#mod_SIMULACRO_ENTREVISTA">Simulacro Entrevista Completo</a></p>
<hr />
<h2>ğŸ“¦ Material Complementario</h2>
<h3>PrÃ¡ctica y EvaluaciÃ³n</h3>
<table>
<thead>
<tr>
<th>Documento</th>
<th>DescripciÃ³n</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_EJERCICIOS">EJERCICIOS.md</a></td>
<td>Ejercicios prÃ¡cticos por mÃ³dulo (3-5 por mÃ³dulo)</td>
</tr>
<tr>
<td><a href="#mod_EJERCICIOS_SOLUCIONES">EJERCICIOS_SOLUCIONES.md</a></td>
<td>Soluciones detalladas con explicaciÃ³n</td>
</tr>
<tr>
<td><a href="#mod_RUBRICA_EVALUACION">RUBRICA_EVALUACION.md</a></td>
<td>Criterios de evaluaciÃ³n (100 puntos)</td>
</tr>
</tbody>
</table>
<h3>Referencia</h3>
<table>
<thead>
<tr>
<th>Documento</th>
<th>DescripciÃ³n</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md</a></td>
<td>80+ definiciones tÃ©cnicas A-Z con analogÃ­as</td>
</tr>
<tr>
<td><a href="#mod_CHECKLIST">CHECKLIST.md</a></td>
<td>VerificaciÃ³n final del proyecto</td>
</tr>
<tr>
<td><a href="#mod_DECISIONES_TECH">DECISIONES_TECH.md</a></td>
<td>Por quÃ© Python puro y cada decisiÃ³n de diseÃ±o</td>
</tr>
<tr>
<td><a href="#mod_REFERENCIAS_CRUZADAS">REFERENCIAS_CRUZADAS.md</a></td>
<td>Mapa de navegaciÃ³n entre documentos</td>
</tr>
<tr>
<td><a href="#mod_EVALUACION_GUIA">EVALUACION_GUIA.md</a></td>
<td>AutoevaluaciÃ³n de completitud (99/100)</td>
</tr>
</tbody>
</table>
<h3>PlanificaciÃ³n</h3>
<table>
<thead>
<tr>
<th>Documento</th>
<th>DescripciÃ³n</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_SYLLABUS">SYLLABUS.md</a></td>
<td>Programa detallado con objetivos y entregables</td>
</tr>
<tr>
<td><a href="#mod_PLAN_ESTUDIOS">PLAN_ESTUDIOS.md</a></td>
<td>Cronograma dÃ­a a dÃ­a (6 meses)</td>
</tr>
</tbody>
</table>
<h3>PreparaciÃ³n para Entrevistas/Pathway</h3>
<table>
<thead>
<tr>
<th>Documento</th>
<th>DescripciÃ³n</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_SIMULACRO_ENTREVISTA">SIMULACRO_ENTREVISTA.md</a></td>
<td>50+ preguntas tipo Pathway con respuestas</td>
</tr>
<tr>
<td><a href="#mod_RECURSOS">RECURSOS.md</a></td>
<td>Cursos, libros, videos recomendados</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ”¨ Proyecto de Referencia</h2>
<pre><code>archimedes-indexer/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ document.py          # Clase Document
â”‚   â”œâ”€â”€ corpus.py            # Clase Corpus (colecciÃ³n)
â”‚   â”œâ”€â”€ tokenizer.py         # TokenizaciÃ³n manual
â”‚   â”œâ”€â”€ inverted_index.py    # Ãndice invertido (HashMap)
â”‚   â”œâ”€â”€ sorting.py           # QuickSort, MergeSort
â”‚   â”œâ”€â”€ searching.py         # Binary Search
â”‚   â”œâ”€â”€ vectorizer.py        # TF-IDF desde cero
â”‚   â”œâ”€â”€ similarity.py        # Similitud de coseno
â”‚   â””â”€â”€ search_engine.py     # Motor completo
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ test_document.py
â”‚   â”œâ”€â”€ test_tokenizer.py
â”‚   â”œâ”€â”€ test_sorting.py
â”‚   â”œâ”€â”€ test_similarity.py
â”‚   â””â”€â”€ test_engine.py
â”œâ”€â”€ docs/
â”‚   â””â”€â”€ COMPLEXITY_ANALYSIS.md  # AnÃ¡lisis Big O
â”œâ”€â”€ data/
â”‚   â””â”€â”€ sample_corpus/          # Documentos de prueba
â”œâ”€â”€ README.md
â””â”€â”€ pyproject.toml
</code></pre>
<h3>Mapeo MÃ³dulos â†’ CÃ³digo</h3>
<table>
<thead>
<tr>
<th>MÃ³dulos</th>
<th>Archivos del Proyecto</th>
</tr>
</thead>
<tbody>
<tr>
<td>01-02</td>
<td><code>document.py</code>, <code>corpus.py</code></td>
</tr>
<tr>
<td>04-05</td>
<td><code>tokenizer.py</code></td>
</tr>
<tr>
<td>06</td>
<td><code>inverted_index.py</code></td>
</tr>
<tr>
<td>07-08</td>
<td><code>sorting.py</code></td>
</tr>
<tr>
<td>09</td>
<td><code>searching.py</code></td>
</tr>
<tr>
<td>10-11</td>
<td><code>vectorizer.py</code>, <code>similarity.py</code></td>
</tr>
<tr>
<td>12</td>
<td><code>search_engine.py</code>, <code>COMPLEXITY_ANALYSIS.md</code></td>
</tr>
</tbody>
</table>
<hr />
<h2>â±ï¸ Tiempo Total Estimado</h2>
<table>
<thead>
<tr>
<th>Componente</th>
<th>Horas</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lectura de mÃ³dulos</td>
<td>~80 horas</td>
</tr>
<tr>
<td>Ejercicios prÃ¡cticos</td>
<td>~120 horas</td>
</tr>
<tr>
<td>ImplementaciÃ³n del proyecto</td>
<td>~200 horas</td>
</tr>
<tr>
<td>AnÃ¡lisis y documentaciÃ³n</td>
<td>~40 horas</td>
</tr>
<tr>
<td>PreparaciÃ³n entrevistas</td>
<td>~40 horas</td>
</tr>
<tr>
<td><strong>TOTAL</strong></td>
<td><strong>~480 horas</strong></td>
</tr>
</tbody>
</table>
<p>Con 6 horas/dÃ­a (L-S) = 36 horas/semana â†’ <strong>~14 semanas efectivas</strong> (margen incluido en 6 meses)</p>
<hr />
<h2>ğŸ“Œ Convenciones de la GuÃ­a</h2>
<table>
<thead>
<tr>
<th>Icono</th>
<th>Significado</th>
</tr>
</thead>
<tbody>
<tr>
<td>ğŸ’¡</td>
<td>Tip o consejo prÃ¡ctico</td>
</tr>
<tr>
<td>âš ï¸</td>
<td>Advertencia importante</td>
</tr>
<tr>
<td>âœ…</td>
<td>Buena prÃ¡ctica</td>
</tr>
<tr>
<td>âŒ</td>
<td>Anti-patrÃ³n a evitar</td>
</tr>
<tr>
<td>ğŸ”§</td>
<td>Ejercicio prÃ¡ctico</td>
</tr>
<tr>
<td>ğŸ¯</td>
<td>Objetivo del mÃ³dulo/secciÃ³n</td>
</tr>
<tr>
<td>ğŸ“Š</td>
<td>AnÃ¡lisis de complejidad</td>
</tr>
<tr>
<td>ğŸ§ </td>
<td>Concepto clave para memorizar</td>
</tr>
<tr>
<td>ğŸ”—</td>
<td>Referencia cruzada</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ›¤ï¸ Rutas de Aprendizaje</h2>
<h3>Ruta Completa (Recomendada)</h3>
<pre><code>01 â†’ 02 â†’ 03 â†’ 04 â†’ 05 â†’ 06 â†’ 13 â†’ 14 â†’ 15 â†’ 07 â†’ 08 â†’ 09 â†’ 16 â†’ 17 â†’ 18 â†’ 10 â†’ 11 â†’ 12
</code></pre>
<h3>Ruta Acelerada (Ya sabes OOP)</h3>
<pre><code>03 â†’ 04 â†’ 05 â†’ 06 â†’ 13 â†’ 14 â†’ 15 â†’ 07 â†’ 08 â†’ 09 â†’ 16 â†’ 17 â†’ 18 â†’ 10 â†’ 11 â†’ 12
</code></pre>
<h3>Ruta Solo Pathway (Foco en DSA) â­</h3>
<pre><code>04 â†’ 05 â†’ 13 â†’ 14 â†’ 15 â†’ 07 â†’ 08 â†’ 09 â†’ 16 â†’ 17 â†’ 18 â†’ SIMULACRO_ENTREVISTA
</code></pre>
<hr />
<h2>ğŸš€ Siguiente Paso</h2>
<p><strong><a href="#mod_01_PYTHON_PROFESIONAL">Comenzar con MÃ³dulo 01: Python Profesional â†’</a></strong></p>
<hr />
<blockquote>
<p><em>"Give me a lever long enough and a fulcrum on which to place it, and I shall move the world."</em> â€” Archimedes</p>
<p>Este proyecto es tu palanca. Los fundamentos son tu fulcro.</p>
</blockquote>
        </section>
        
        <div id="mod_SYLLABUS" class="cover-page">
            <a name="mod_SYLLABUS"></a>
            <div class="cover-title">Syllabus Archimedes</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>ğŸ“‹ Syllabus - Archimedes Indexer</h1>
<blockquote>
<p><strong>Programa de FormaciÃ³n: De Python BÃ¡sico a Candidato MS in AI</strong></p>
</blockquote>
<hr />
<h2>ğŸ¯ Objetivos del Programa</h2>
<p>Al completar este programa, el estudiante serÃ¡ capaz de:</p>
<ol>
<li><strong>DiseÃ±ar</strong> sistemas de software usando principios OOP y SOLID</li>
<li><strong>Implementar</strong> estructuras de datos fundamentales (Hash Maps, Ãndices) desde cero</li>
<li><strong>Codificar</strong> algoritmos clÃ¡sicos (QuickSort, Binary Search) sin librerÃ­as</li>
<li><strong>Aplicar</strong> Ã¡lgebra lineal para ranking de documentos (TF-IDF, Similitud de Coseno)</li>
<li><strong>Analizar</strong> la complejidad algorÃ­tmica usando notaciÃ³n Big O</li>
<li><strong>Defender</strong> decisiones tÃ©cnicas en inglÃ©s a nivel tÃ©cnico</li>
</ol>
<hr />
<h2>ğŸ“Š Estructura del Programa</h2>
<h3>Macro-MÃ³dulos</h3>
<table>
<thead>
<tr>
<th>#</th>
<th>Macro-MÃ³dulo</th>
<th>DuraciÃ³n</th>
<th>Mini-Proyecto Asociado</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td>Fundamentos de Python Profesional</td>
<td>4 semanas</td>
<td>Clases <code>Document</code> y <code>Corpus</code></td>
</tr>
<tr>
<td>II</td>
<td>Estructuras de Datos Core</td>
<td>6 semanas</td>
<td><code>InvertedIndex</code> funcional</td>
</tr>
<tr>
<td>III</td>
<td>Algoritmos ClÃ¡sicos</td>
<td>4 semanas</td>
<td><code>sorting.py</code> y <code>searching.py</code></td>
</tr>
<tr>
<td>IV</td>
<td>MatemÃ¡ticas Aplicadas</td>
<td>4 semanas</td>
<td><code>vectorizer.py</code> + <code>similarity.py</code></td>
</tr>
<tr>
<td>V</td>
<td>IntegraciÃ³n y Defensa</td>
<td>4 semanas</td>
<td>Motor de bÃºsqueda completo</td>
</tr>
</tbody>
</table>
<p><strong>Total: 22 semanas</strong> (con margen para repaso = 6 meses)</p>
<hr />
<h2>ğŸ“š Mapeo Macro-MÃ³dulos â†’ MÃ³dulos â†’ CÃ³digo</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MACRO-MÃ“DULO I: FUNDAMENTOS                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ MÃ³dulos: 01, 02, 03                                                         â”‚
â”‚ CÃ³digo:  src/document.py, src/corpus.py                                     â”‚
â”‚ Tests:   tests/test_document.py                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MACRO-MÃ“DULO II: ESTRUCTURAS DE DATOS                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ MÃ³dulos: 04, 05, 06                                                         â”‚
â”‚ CÃ³digo:  src/tokenizer.py, src/inverted_index.py                            â”‚
â”‚ Tests:   tests/test_tokenizer.py, tests/test_index.py                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MACRO-MÃ“DULO III: ALGORITMOS                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ MÃ³dulos: 07, 08, 09                                                         â”‚
â”‚ CÃ³digo:  src/sorting.py, src/searching.py                                   â”‚
â”‚ Tests:   tests/test_sorting.py, tests/test_searching.py                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MACRO-MÃ“DULO IV: MATEMÃTICAS APLICADAS                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ MÃ³dulos: 10, 11                                                             â”‚
â”‚ CÃ³digo:  src/vectorizer.py, src/similarity.py                               â”‚
â”‚ Tests:   tests/test_vectorizer.py, tests/test_similarity.py                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MACRO-MÃ“DULO V: INTEGRACIÃ“N                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ MÃ³dulos: 12                                                                 â”‚
â”‚ CÃ³digo:  src/search_engine.py                                               â”‚
â”‚ Docs:    docs/COMPLEXITY_ANALYSIS.md, README.md                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“– Detalle por MÃ³dulo</h2>
<h3>MÃ³dulo 01: Python Profesional</h3>
<table>
<thead>
<tr>
<th>Contenido</th>
<th>Entregable</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type hints y anotaciones</td>
<td>CÃ³digo tipado con <code>mypy</code> pasando</td>
</tr>
<tr>
<td>Funciones puras vs impuras</td>
<td>Funciones sin side effects</td>
</tr>
<tr>
<td>PEP8 y estilo consistente</td>
<td>CÃ³digo que pasa <code>ruff</code> o <code>flake8</code></td>
</tr>
<tr>
<td>Docstrings y documentaciÃ³n</td>
<td>Cada funciÃ³n documentada</td>
</tr>
</tbody>
</table>
<p><strong>Mini-proyecto:</strong> FunciÃ³n <code>clean_text(text: str) -&gt; str</code> tipada y documentada.</p>
<p><strong>ValidaciÃ³n:</strong> <code>mypy src/ &amp;&amp; ruff check src/</code></p>
<hr />
<h3>MÃ³dulo 02: OOP desde Cero</h3>
<table>
<thead>
<tr>
<th>Contenido</th>
<th>Entregable</th>
</tr>
</thead>
<tbody>
<tr>
<td>Clases y objetos</td>
<td>Clase <code>Document</code> con atributos</td>
</tr>
<tr>
<td><code>__init__</code>, <code>__repr__</code>, <code>__str__</code></td>
<td>MÃ©todos mÃ¡gicos implementados</td>
</tr>
<tr>
<td>Encapsulamiento</td>
<td>Properties y validaciÃ³n</td>
</tr>
<tr>
<td>ComposiciÃ³n vs Herencia</td>
<td>Clase <code>Corpus</code> que contiene <code>Document</code>s</td>
</tr>
<tr>
<td>Principios SOLID bÃ¡sicos</td>
<td>Single Responsibility aplicado</td>
</tr>
</tbody>
</table>
<p><strong>Mini-proyecto:</strong> Clases <code>Document</code> y <code>Corpus</code> funcionales.</p>
<p><strong>ValidaciÃ³n:</strong> <code>python -m pytest tests/test_document.py -v</code></p>
<hr />
<h3>MÃ³dulo 03: LÃ³gica y MatemÃ¡ticas Discretas</h3>
<table>
<thead>
<tr>
<th>Contenido</th>
<th>Entregable</th>
</tr>
</thead>
<tbody>
<tr>
<td>TeorÃ­a de conjuntos</td>
<td>Uso correcto de <code>set</code> en Python</td>
</tr>
<tr>
<td>LÃ³gica proposicional</td>
<td>Expresiones booleanas complejas</td>
</tr>
<tr>
<td>NotaciÃ³n Big O (introducciÃ³n)</td>
<td>Explicar O(1), O(n), O(nÂ²)</td>
</tr>
<tr>
<td>Demostraciones simples</td>
<td>Documentar "por quÃ© funciona"</td>
</tr>
</tbody>
</table>
<p><strong>Mini-proyecto:</strong> Lista de stop words como <code>set</code> con anÃ¡lisis de complejidad.</p>
<p><strong>ValidaciÃ³n:</strong> Documento explicando complejidad de operaciones <code>in</code> en <code>list</code> vs <code>set</code>.</p>
<hr />
<h3>MÃ³dulo 04: Arrays, Strings y Memoria</h3>
<table>
<thead>
<tr>
<th>Contenido</th>
<th>Entregable</th>
</tr>
</thead>
<tbody>
<tr>
<td>Listas en Python (bajo nivel)</td>
<td>Entender slicing y copia</td>
</tr>
<tr>
<td>ManipulaciÃ³n de strings</td>
<td>TokenizaciÃ³n bÃ¡sica</td>
</tr>
<tr>
<td>Complejidad de operaciones</td>
<td>Tabla de O() para list</td>
</tr>
<tr>
<td>Inmutabilidad vs mutabilidad</td>
<td>Evitar bugs de referencia</td>
</tr>
</tbody>
</table>
<p><strong>Mini-proyecto:</strong> Tokenizador bÃ¡sico que separa texto en palabras.</p>
<p><strong>ValidaciÃ³n:</strong> <code>python -m pytest tests/test_tokenizer.py -v</code></p>
<hr />
<h3>MÃ³dulo 05: Hash Maps y Sets</h3>
<table>
<thead>
<tr>
<th>Contenido</th>
<th>Entregable</th>
</tr>
</thead>
<tbody>
<tr>
<td>CÃ³mo funciona un diccionario</td>
<td>Entender hashing</td>
</tr>
<tr>
<td>Colisiones y resoluciÃ³n</td>
<td>Saber que existen, no implementar</td>
</tr>
<tr>
<td>Complejidad O(1) amortizada</td>
<td>Explicar cuÃ¡ndo y por quÃ©</td>
</tr>
<tr>
<td>Sets para bÃºsqueda rÃ¡pida</td>
<td>Stop words como <code>frozenset</code></td>
</tr>
</tbody>
</table>
<p><strong>Mini-proyecto:</strong> Diccionario de frecuencia de palabras.</p>
<p><strong>ValidaciÃ³n:</strong> Benchmark <code>list</code> vs <code>set</code> para bÃºsqueda (script incluido).</p>
<hr />
<h3>MÃ³dulo 06: Ãndice Invertido</h3>
<table>
<thead>
<tr>
<th>Contenido</th>
<th>Entregable</th>
</tr>
</thead>
<tbody>
<tr>
<td>QuÃ© es un Ã­ndice invertido</td>
<td>Diagrama y explicaciÃ³n</td>
</tr>
<tr>
<td>Estructura <code>{palabra: [doc_ids]}</code></td>
<td>Clase <code>InvertedIndex</code></td>
</tr>
<tr>
<td>Agregar documentos al Ã­ndice</td>
<td>MÃ©todo <code>add_document()</code></td>
</tr>
<tr>
<td>Buscar documentos por palabra</td>
<td>MÃ©todo <code>search(query)</code></td>
</tr>
</tbody>
</table>
<p><strong>Mini-proyecto:</strong> <code>InvertedIndex</code> que indexa y busca en corpus de prueba.</p>
<p><strong>ValidaciÃ³n:</strong> <code>python -m pytest tests/test_index.py -v</code></p>
<p><strong>AnÃ¡lisis requerido:</strong> Â¿CuÃ¡l es la complejidad de <code>add_document()</code>? Â¿Y de <code>search()</code>?</p>
<hr />
<h3>MÃ³dulo 07: RecursiÃ³n y Divide &amp; Conquer</h3>
<table>
<thead>
<tr>
<th>Contenido</th>
<th>Entregable</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pensamiento recursivo</td>
<td>Funciones recursivas simples</td>
</tr>
<tr>
<td>Caso base y caso recursivo</td>
<td>Identificar en ejemplos</td>
</tr>
<tr>
<td>Call stack y lÃ­mites</td>
<td>Entender <code>RecursionError</code></td>
</tr>
<tr>
<td>Divide &amp; Conquer pattern</td>
<td>Factorial, Fibonacci, suma de lista</td>
</tr>
</tbody>
</table>
<p><strong>Mini-proyecto:</strong> <code>factorial()</code>, <code>fibonacci()</code>, <code>sum_list()</code> recursivos.</p>
<p><strong>ValidaciÃ³n:</strong> Tests que verifican casos base y casos grandes.</p>
<hr />
<h3>MÃ³dulo 08: Algoritmos de Ordenamiento</h3>
<table>
<thead>
<tr>
<th>Contenido</th>
<th>Entregable</th>
</tr>
</thead>
<tbody>
<tr>
<td>QuickSort desde cero</td>
<td>ImplementaciÃ³n funcional</td>
</tr>
<tr>
<td>Pivot selection</td>
<td>Random pivot para evitar O(nÂ²)</td>
</tr>
<tr>
<td>MergeSort (opcional)</td>
<td>ImplementaciÃ³n alternativa</td>
</tr>
<tr>
<td>AnÃ¡lisis de complejidad</td>
<td>O(n log n) promedio, O(nÂ²) peor</td>
</tr>
</tbody>
</table>
<p><strong>Mini-proyecto:</strong> <code>quicksort()</code> y <code>mergesort()</code> en <code>sorting.py</code>.</p>
<p><strong>ValidaciÃ³n:</strong> <code>python -m pytest tests/test_sorting.py -v</code></p>
<p><strong>AnÃ¡lisis requerido:</strong> Documento explicando cuÃ¡ndo QuickSort es O(nÂ²).</p>
<hr />
<h3>MÃ³dulo 09: BÃºsqueda Binaria</h3>
<table>
<thead>
<tr>
<th>Contenido</th>
<th>Entregable</th>
</tr>
</thead>
<tbody>
<tr>
<td>Binary Search clÃ¡sica</td>
<td>ImplementaciÃ³n sin errores</td>
</tr>
<tr>
<td>Off-by-one errors</td>
<td>CÃ³mo evitarlos sistemÃ¡ticamente</td>
</tr>
<tr>
<td>Variantes</td>
<td>Buscar primer/Ãºltimo elemento</td>
</tr>
<tr>
<td>CuÃ¡ndo aplicar</td>
<td>Lista ordenada, O(log n)</td>
</tr>
</tbody>
</table>
<p><strong>Mini-proyecto:</strong> <code>binary_search()</code> con variantes en <code>searching.py</code>.</p>
<p><strong>ValidaciÃ³n:</strong> <code>python -m pytest tests/test_searching.py -v</code></p>
<hr />
<h3>MÃ³dulo 10: Ãlgebra Lineal sin NumPy</h3>
<table>
<thead>
<tr>
<th>Contenido</th>
<th>Entregable</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vectores como listas</td>
<td>RepresentaciÃ³n bÃ¡sica</td>
</tr>
<tr>
<td>Suma de vectores</td>
<td><code>add_vectors(v1, v2)</code></td>
</tr>
<tr>
<td>Producto punto</td>
<td><code>dot_product(v1, v2)</code></td>
</tr>
<tr>
<td>Norma de un vector</td>
<td><code>magnitude(v)</code></td>
</tr>
<tr>
<td>Matrices como listas de listas</td>
<td>RepresentaciÃ³n 2D</td>
</tr>
</tbody>
</table>
<p><strong>Mini-proyecto:</strong> MÃ³dulo <code>linear_algebra.py</code> con operaciones bÃ¡sicas.</p>
<p><strong>ValidaciÃ³n:</strong> Tests que verifican matemÃ¡ticamente cada operaciÃ³n.</p>
<hr />
<h3>MÃ³dulo 11: TF-IDF y Similitud de Coseno</h3>
<table>
<thead>
<tr>
<th>Contenido</th>
<th>Entregable</th>
</tr>
</thead>
<tbody>
<tr>
<td>Term Frequency (TF)</td>
<td>FunciÃ³n <code>compute_tf()</code></td>
</tr>
<tr>
<td>Inverse Document Frequency (IDF)</td>
<td>FunciÃ³n <code>compute_idf()</code></td>
</tr>
<tr>
<td>TF-IDF combinado</td>
<td>FunciÃ³n <code>compute_tfidf()</code></td>
</tr>
<tr>
<td>Similitud de coseno</td>
<td>FunciÃ³n <code>cosine_similarity()</code></td>
</tr>
<tr>
<td>VectorizaciÃ³n de documentos</td>
<td>Cada doc como vector TF-IDF</td>
</tr>
</tbody>
</table>
<p><strong>Mini-proyecto:</strong> Sistema de ranking por relevancia.</p>
<p><strong>ValidaciÃ³n:</strong> Tests + comparaciÃ³n manual con resultados conocidos.</p>
<hr />
<h3>MÃ³dulo 12: Proyecto Integrador</h3>
<table>
<thead>
<tr>
<th>Contenido</th>
<th>Entregable</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ensamblaje de componentes</td>
<td><code>SearchEngine</code> que usa todo</td>
</tr>
<tr>
<td>API de bÃºsqueda</td>
<td>MÃ©todo <code>search(query, top_k)</code></td>
</tr>
<tr>
<td>AnÃ¡lisis Big O completo</td>
<td><code>COMPLEXITY_ANALYSIS.md</code></td>
</tr>
<tr>
<td>README profesional</td>
<td>DocumentaciÃ³n de uso</td>
</tr>
<tr>
<td>Tests de integraciÃ³n</td>
<td><code>test_engine.py</code></td>
</tr>
</tbody>
</table>
<p><strong>Entregable final:</strong><br />
1. Motor de bÃºsqueda funcional<br />
2. AnÃ¡lisis de complejidad de cada operaciÃ³n<br />
3. README en inglÃ©s<br />
4. Suite de tests con &gt;80% coverage</p>
<p><strong>ValidaciÃ³n:</strong> Demo en vivo + defensa del anÃ¡lisis Big O.</p>
<hr />
<h2>ğŸ“Š RÃºbrica General (100 puntos)</h2>
<table>
<thead>
<tr>
<th>DimensiÃ³n</th>
<th>Puntos</th>
<th>Criterio</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Funcionalidad</strong></td>
<td>30</td>
<td>El motor busca y rankea correctamente</td>
</tr>
<tr>
<td><strong>CÃ³digo limpio</strong></td>
<td>20</td>
<td>PEP8, type hints, docstrings</td>
</tr>
<tr>
<td><strong>Tests</strong></td>
<td>20</td>
<td>Cobertura &gt;80%, casos edge</td>
</tr>
<tr>
<td><strong>AnÃ¡lisis Big O</strong></td>
<td>20</td>
<td>Documento completo y correcto</td>
</tr>
<tr>
<td><strong>DocumentaciÃ³n</strong></td>
<td>10</td>
<td>README claro, en inglÃ©s</td>
</tr>
</tbody>
</table>
<h3>Niveles</h3>
<table>
<thead>
<tr>
<th>PuntuaciÃ³n</th>
<th>Nivel</th>
</tr>
</thead>
<tbody>
<tr>
<td>90-100</td>
<td>Listo para Pathway + entrevistas tÃ©cnicas</td>
</tr>
<tr>
<td>75-89</td>
<td>Buen nivel, reforzar Ã¡reas dÃ©biles</td>
</tr>
<tr>
<td>60-74</td>
<td>Necesita mÃ¡s prÃ¡ctica antes de Pathway</td>
</tr>
<tr>
<td>&lt;60</td>
<td>Revisar mÃ³dulos fundamentales</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ¯ PreparaciÃ³n para Pathway</h2>
<p>El curso de entrada tÃ­pico del Pathway es <strong>"Algorithms for Searching, Sorting, and Indexing"</strong>.</p>
<p>Este programa cubre directamente:<br />
- âœ… Sorting (QuickSort, MergeSort)<br />
- âœ… Searching (Binary Search)<br />
- âœ… Indexing (Inverted Index)<br />
- âœ… AnÃ¡lisis de complejidad (Big O)<br />
- âœ… Python profesional</p>
<h3>AlineaciÃ³n con el Pathway</h3>
<table>
<thead>
<tr>
<th>Tema del Pathway</th>
<th>MÃ³dulo de esta GuÃ­a</th>
</tr>
</thead>
<tbody>
<tr>
<td>Algorithm Analysis</td>
<td>03, 08, 09, 12</td>
</tr>
<tr>
<td>Sorting Algorithms</td>
<td>08</td>
</tr>
<tr>
<td>Binary Search</td>
<td>09</td>
</tr>
<tr>
<td>Hash Tables</td>
<td>05, 06</td>
</tr>
<tr>
<td>Basic Data Structures</td>
<td>04, 05</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ“… Cronograma Sugerido</h2>
<p>Ver <a href="#mod_PLAN_ESTUDIOS">PLAN_ESTUDIOS.md</a> para el cronograma dÃ­a a dÃ­a.</p>
<hr />
<h2>âœ… Checklist de FinalizaciÃ³n del Programa</h2>
<ul>
<li>[ ] Todos los mÃ³dulos completados</li>
<li>[ ] Proyecto <code>archimedes-indexer</code> funcional</li>
<li>[ ] Tests pasando con &gt;80% coverage</li>
<li>[ ] <code>COMPLEXITY_ANALYSIS.md</code> completo</li>
<li>[ ] README en inglÃ©s</li>
<li>[ ] Simulacro de entrevista completado</li>
<li>[ ] Capaz de explicar el proyecto en inglÃ©s (5 min)</li>
</ul>
<hr />
<blockquote>
<p>ğŸ’¡ <strong>Recuerda:</strong> El objetivo no es solo construir el motor, sino poder <em>defenderlo</em> tÃ©cnicamente. Practica explicar cada decisiÃ³n.</p>
</blockquote>
        </section>
        
        <div id="mod_PLAN_ESTUDIOS" class="cover-page">
            <a name="mod_PLAN_ESTUDIOS"></a>
            <div class="cover-title">Plan de Estudios (6 meses)</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>ğŸ“… Plan de Estudios - Cronograma Detallado</h1>
<blockquote>
<p><strong>6 Meses | 6 horas/dÃ­a | Lunes a SÃ¡bado</strong></p>
</blockquote>
<hr />
<h2>ğŸ—“ï¸ Vista General</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MES 1        â”‚ MES 2        â”‚ MES 3        â”‚ MES 4        â”‚ MES 5-6         â”‚
â”‚ Fundamentos  â”‚ Estructuras  â”‚ Estructuras  â”‚ Algoritmos   â”‚ Math + Integ.   â”‚
â”‚ Mod 01-03    â”‚ Mod 04-05    â”‚ Mod 06       â”‚ Mod 07-09    â”‚ Mod 10-12       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p><strong>DedicaciÃ³n total:</strong> 36 horas/semana Ã— 24 semanas = <strong>864 horas</strong> (con margen)</p>
<hr />
<h2>ğŸ“Œ DistribuciÃ³n Diaria TÃ­pica</h2>
<table>
<thead>
<tr>
<th>Bloque</th>
<th>Horario</th>
<th>Actividad</th>
<th>DuraciÃ³n</th>
</tr>
</thead>
<tbody>
<tr>
<td>ğŸŒ… MaÃ±ana</td>
<td>08:00 - 10:30</td>
<td>Estudio teÃ³rico (lectura del mÃ³dulo)</td>
<td>2.5 h</td>
</tr>
<tr>
<td>â˜• Pausa</td>
<td>10:30 - 11:00</td>
<td>Descanso</td>
<td>30 min</td>
</tr>
<tr>
<td>ğŸŒ‡ MediodÃ­a</td>
<td>11:00 - 13:30</td>
<td>ImplementaciÃ³n (cÃ³digo)</td>
<td>2.5 h</td>
</tr>
<tr>
<td>ğŸŒ™ Tarde</td>
<td>15:00 - 16:00</td>
<td>Ejercicios + repaso</td>
<td>1 h</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ—“ï¸ SEMANA 1: Python Profesional (Parte 1)</h2>
<p><strong>MÃ³dulo:</strong> 01 - Python Profesional<br />
<strong>Objetivo:</strong> Escribir cÃ³digo Python con estÃ¡ndares profesionales</p>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>Type hints bÃ¡sicos</td>
<td>Tipar funciones existentes</td>
<td>Ejercicio 1.1</td>
</tr>
<tr>
<td>M</td>
<td>Type hints avanzados</td>
<td>Tipar clases simples</td>
<td>Ejercicio 1.2</td>
</tr>
<tr>
<td>X</td>
<td>Funciones puras</td>
<td>Refactorizar a puras</td>
<td>Ejercicio 1.3</td>
</tr>
<tr>
<td>J</td>
<td>PEP8 y linters</td>
<td>Configurar <code>ruff</code></td>
<td>Corregir warnings</td>
</tr>
<tr>
<td>V</td>
<td>Docstrings</td>
<td>Documentar mÃ³dulo</td>
<td>Revisar con <code>pydoc</code></td>
</tr>
<tr>
<td>S</td>
<td><strong>Repaso semanal</strong></td>
<td>Mini-proyecto: <code>clean_text()</code></td>
<td>AutoevaluaciÃ³n</td>
</tr>
</tbody>
</table>
<p><strong>Entregable:</strong> FunciÃ³n <code>clean_text()</code> tipada, documentada, pasando linters.</p>
<p><strong>Recursos:</strong><br />
- <a href="https://realpython.com/python-type-checking/">Real Python: Type Hints</a><br />
- <a href="https://peps.python.org/pep-0008/">PEP 8 Style Guide</a></p>
<hr />
<h2>ğŸ—“ï¸ SEMANA 2: Python Profesional (Parte 2) + OOP Inicio</h2>
<p><strong>MÃ³dulo:</strong> 01 (cierre) + 02 (inicio)<br />
<strong>Objetivo:</strong> Dominar type hints complejos, iniciar OOP</p>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>Generics, Optional, Union</td>
<td>Tipar estructuras complejas</td>
<td>Ejercicio 1.4</td>
</tr>
<tr>
<td>M</td>
<td><code>mypy</code> en profundidad</td>
<td>Corregir errores de mypy</td>
<td>Config <code>pyproject.toml</code></td>
</tr>
<tr>
<td>X</td>
<td>Clases: <code>__init__</code></td>
<td>Clase <code>Document</code> bÃ¡sica</td>
<td>Ejercicio 2.1</td>
</tr>
<tr>
<td>J</td>
<td><code>__repr__</code>, <code>__str__</code></td>
<td>MÃ©todos mÃ¡gicos en Document</td>
<td>Ejercicio 2.2</td>
</tr>
<tr>
<td>V</td>
<td>Properties</td>
<td>ValidaciÃ³n en properties</td>
<td>Ejercicio 2.3</td>
</tr>
<tr>
<td>S</td>
<td><strong>Repaso</strong></td>
<td>Clase <code>Document</code> completa</td>
<td>Test manual</td>
</tr>
</tbody>
</table>
<p><strong>Entregable:</strong> Clase <code>Document</code> con type hints y mÃ©todos mÃ¡gicos.</p>
<hr />
<h2>ğŸ—“ï¸ SEMANA 3: OOP Avanzado</h2>
<p><strong>MÃ³dulo:</strong> 02 - OOP desde Cero<br />
<strong>Objetivo:</strong> ComposiciÃ³n, herencia bÃ¡sica, SOLID</p>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>ComposiciÃ³n vs Herencia</td>
<td>Clase <code>Corpus</code> con lista de docs</td>
<td>Ejercicio 2.4</td>
</tr>
<tr>
<td>M</td>
<td>Single Responsibility</td>
<td>Refactorizar clases grandes</td>
<td>Ejercicio 2.5</td>
</tr>
<tr>
<td>X</td>
<td>Open/Closed (bÃ¡sico)</td>
<td>Extensibilidad sin modificar</td>
<td>Diagrama de clases</td>
</tr>
<tr>
<td>J</td>
<td>Dataclasses</td>
<td>Migrar <code>Document</code> a dataclass</td>
<td>Comparar cÃ³digo</td>
</tr>
<tr>
<td>V</td>
<td>Testing de clases</td>
<td><code>test_document.py</code></td>
<td>pytest bÃ¡sico</td>
</tr>
<tr>
<td>S</td>
<td><strong>Repaso</strong></td>
<td><code>Corpus</code> + tests</td>
<td>Simulacro mÃ³dulo</td>
</tr>
</tbody>
</table>
<p><strong>Entregable:</strong> <code>Document</code>, <code>Corpus</code> con tests pasando.</p>
<hr />
<h2>ğŸ—“ï¸ SEMANA 4: LÃ³gica y MatemÃ¡ticas Discretas</h2>
<p><strong>MÃ³dulo:</strong> 03 - LÃ³gica y MatemÃ¡ticas Discretas<br />
<strong>Objetivo:</strong> Fundamentos de lÃ³gica y notaciÃ³n Big O bÃ¡sica</p>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>TeorÃ­a de conjuntos</td>
<td><code>set</code> vs <code>list</code> en Python</td>
<td>Ejercicio 3.1</td>
</tr>
<tr>
<td>M</td>
<td>Operaciones de conjuntos</td>
<td>UniÃ³n, intersecciÃ³n, diferencia</td>
<td>Ejercicio 3.2</td>
</tr>
<tr>
<td>X</td>
<td>LÃ³gica proposicional</td>
<td>Expresiones booleanas complejas</td>
<td>Ejercicio 3.3</td>
</tr>
<tr>
<td>J</td>
<td>Intro a Big O</td>
<td>O(1), O(n), O(nÂ²)</td>
<td>Analizar loops</td>
</tr>
<tr>
<td>V</td>
<td>Big O de estructuras</td>
<td>Tabla de complejidades</td>
<td>Documento anÃ¡lisis</td>
</tr>
<tr>
<td>S</td>
<td><strong>Checkpoint Fase I</strong></td>
<td>Simulacro Fundamentos</td>
<td>AutoevaluaciÃ³n</td>
</tr>
</tbody>
</table>
<p><strong>Entregable:</strong> Lista de stop words como <code>set</code> + anÃ¡lisis de complejidad.</p>
<p><strong>Checkpoint:</strong> <a href="#mod_SIMULACRO_FUNDAMENTOS">SIMULACRO_FUNDAMENTOS.md</a></p>
<hr />
<h2>ğŸ—“ï¸ SEMANA 5-6: Arrays, Strings y TokenizaciÃ³n</h2>
<p><strong>MÃ³dulo:</strong> 04 - Arrays, Strings y Memoria<br />
<strong>Objetivo:</strong> ManipulaciÃ³n eficiente de secuencias, tokenizador bÃ¡sico</p>
<h3>Semana 5</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>Listas en Python (internals)</td>
<td>Slicing, copia profunda</td>
<td>Ejercicio 4.1</td>
</tr>
<tr>
<td>M</td>
<td>Complejidad de list</td>
<td>append, insert, pop</td>
<td>Tabla de O()</td>
</tr>
<tr>
<td>X</td>
<td>Strings: inmutabilidad</td>
<td>ManipulaciÃ³n eficiente</td>
<td>Ejercicio 4.2</td>
</tr>
<tr>
<td>J</td>
<td>TokenizaciÃ³n bÃ¡sica</td>
<td><code>split()</code>, <code>lower()</code>, <code>strip()</code></td>
<td>Tokenizador v1</td>
</tr>
<tr>
<td>V</td>
<td>Eliminar puntuaciÃ³n</td>
<td>Regex bÃ¡sico o manual</td>
<td>Tokenizador v2</td>
</tr>
<tr>
<td>S</td>
<td><strong>Repaso</strong></td>
<td>Tests del tokenizador</td>
<td>Benchmark</td>
</tr>
</tbody>
</table>
<h3>Semana 6</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>Stop words</td>
<td>Filtrar palabras comunes</td>
<td>Tokenizador v3</td>
</tr>
<tr>
<td>M</td>
<td>Stemming (concepto)</td>
<td>Stemming bÃ¡sico manual</td>
<td>Opcional</td>
</tr>
<tr>
<td>X</td>
<td>NormalizaciÃ³n</td>
<td>Acentos, mayÃºsculas</td>
<td>Tokenizador final</td>
</tr>
<tr>
<td>J</td>
<td>Testing exhaustivo</td>
<td>Casos edge (vacÃ­o, solo sÃ­mbolos)</td>
<td>test_tokenizer.py</td>
</tr>
<tr>
<td>V</td>
<td>DocumentaciÃ³n</td>
<td>Docstrings completos</td>
<td>README del mÃ³dulo</td>
</tr>
<tr>
<td>S</td>
<td><strong>Repaso</strong></td>
<td>Tokenizador completo</td>
<td>Benchmark final</td>
</tr>
</tbody>
</table>
<p><strong>Entregable:</strong> <code>tokenizer.py</code> con tests y documentaciÃ³n.</p>
<hr />
<h2>ğŸ—“ï¸ SEMANA 7-8: Hash Maps y Sets</h2>
<p><strong>MÃ³dulo:</strong> 05 - Hash Maps y Sets<br />
<strong>Objetivo:</strong> Entender y usar eficientemente diccionarios y sets</p>
<h3>Semana 7</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>CÃ³mo funciona un hash</td>
<td>Concepto de hashing</td>
<td>Ejercicio 5.1</td>
</tr>
<tr>
<td>M</td>
<td>Diccionarios Python</td>
<td>get, setdefault, defaultdict</td>
<td>Ejercicio 5.2</td>
</tr>
<tr>
<td>X</td>
<td>Colisiones (concepto)</td>
<td>No implementar, solo entender</td>
<td>Lectura</td>
</tr>
<tr>
<td>J</td>
<td>O(1) amortizado</td>
<td>CuÃ¡ndo y por quÃ©</td>
<td>Documento</td>
</tr>
<tr>
<td>V</td>
<td>Sets: operaciones</td>
<td>in, add, remove, intersection</td>
<td>Ejercicio 5.3</td>
</tr>
<tr>
<td>S</td>
<td><strong>Repaso</strong></td>
<td>Frecuencia de palabras v1</td>
<td>Test manual</td>
</tr>
</tbody>
</table>
<h3>Semana 8</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>frozenset</td>
<td>CuÃ¡ndo usar inmutable</td>
<td>Stop words optimizado</td>
</tr>
<tr>
<td>M</td>
<td>Counter de collections</td>
<td>Alternativa a dict manual</td>
<td>Comparar</td>
</tr>
<tr>
<td>X</td>
<td>Benchmark list vs set</td>
<td>Script de mediciÃ³n</td>
<td>GrÃ¡fica de tiempos</td>
</tr>
<tr>
<td>J</td>
<td>AplicaciÃ³n: word count</td>
<td>Contador de palabras completo</td>
<td>test_word_count.py</td>
</tr>
<tr>
<td>V</td>
<td>DocumentaciÃ³n</td>
<td>AnÃ¡lisis de complejidad</td>
<td>Documento</td>
</tr>
<tr>
<td>S</td>
<td><strong>Repaso</strong></td>
<td>MÃ³dulo hashmaps completo</td>
<td>AutoevaluaciÃ³n</td>
</tr>
</tbody>
</table>
<p><strong>Entregable:</strong> Contador de frecuencias + benchmark + anÃ¡lisis.</p>
<hr />
<h2>ğŸ—“ï¸ SEMANA 9-11: Ãndice Invertido</h2>
<p><strong>MÃ³dulo:</strong> 06 - Ãndice Invertido<br />
<strong>Objetivo:</strong> Construir el nÃºcleo del motor de bÃºsqueda</p>
<h3>Semana 9</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>QuÃ© es un Ã­ndice invertido</td>
<td>Diagrama palabraâ†’docs</td>
<td>Ejercicio 6.1</td>
</tr>
<tr>
<td>M</td>
<td>Estructura de datos</td>
<td><code>{word: [doc_id, ...]}</code></td>
<td>Clase <code>InvertedIndex</code></td>
</tr>
<tr>
<td>X</td>
<td>MÃ©todo <code>add_document()</code></td>
<td>Tokenizar + indexar</td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>J</td>
<td>MÃ©todo <code>search(word)</code></td>
<td>Buscar palabra simple</td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>V</td>
<td>Testing bÃ¡sico</td>
<td>Casos simples</td>
<td>test_index.py v1</td>
</tr>
<tr>
<td>S</td>
<td><strong>Repaso</strong></td>
<td>Ãndice funcional bÃ¡sico</td>
<td>Demo</td>
</tr>
</tbody>
</table>
<h3>Semana 10</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>BÃºsqueda multi-palabra</td>
<td>AND lÃ³gico (intersecciÃ³n)</td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>M</td>
<td>OR lÃ³gico</td>
<td>UniÃ³n de resultados</td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>X</td>
<td>Frecuencia en Ã­ndice</td>
<td><code>{word: [(doc_id, freq), ...]}</code></td>
<td>Upgrade estructura</td>
</tr>
<tr>
<td>J</td>
<td>Posiciones (opcional)</td>
<td>Ãndice posicional</td>
<td>Lectura</td>
</tr>
<tr>
<td>V</td>
<td>Testing avanzado</td>
<td>Casos edge</td>
<td>test_index.py v2</td>
</tr>
<tr>
<td>S</td>
<td><strong>Repaso</strong></td>
<td>Ãndice con AND/OR</td>
<td>Demo</td>
</tr>
</tbody>
</table>
<h3>Semana 11</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>AnÃ¡lisis de complejidad</td>
<td>O() de add, search</td>
<td>Documento</td>
</tr>
<tr>
<td>M</td>
<td>Persistencia (opcional)</td>
<td>Guardar/cargar Ã­ndice</td>
<td>JSON simple</td>
</tr>
<tr>
<td>X</td>
<td>Corpus de prueba</td>
<td>Crear 10-20 docs de test</td>
<td>data/sample_corpus/</td>
</tr>
<tr>
<td>J</td>
<td>Demo completa</td>
<td>Indexar corpus, buscar</td>
<td>Script demo</td>
</tr>
<tr>
<td>V</td>
<td>DocumentaciÃ³n</td>
<td>README del mÃ³dulo</td>
<td>Docstrings</td>
</tr>
<tr>
<td>S</td>
<td><strong>Checkpoint Fase II</strong></td>
<td>Simulacro Estructuras</td>
<td>AutoevaluaciÃ³n</td>
</tr>
</tbody>
</table>
<p><strong>Entregable:</strong> <code>InvertedIndex</code> completo con anÃ¡lisis de complejidad.</p>
<p><strong>Checkpoint:</strong> <a href="#mod_SIMULACRO_ESTRUCTURAS">SIMULACRO_ESTRUCTURAS.md</a></p>
<hr />
<h2>ğŸ—“ï¸ SEMANA 12-13: RecursiÃ³n</h2>
<p><strong>MÃ³dulo:</strong> 07 - RecursiÃ³n y Divide &amp; Conquer<br />
<strong>Objetivo:</strong> Dominar el pensamiento recursivo</p>
<h3>Semana 12</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>QuÃ© es recursiÃ³n</td>
<td>AnalogÃ­a de espejos</td>
<td>Ejercicio 7.1</td>
</tr>
<tr>
<td>M</td>
<td>Caso base y recursivo</td>
<td>Identificar en ejemplos</td>
<td>Factorial</td>
</tr>
<tr>
<td>X</td>
<td>Call stack</td>
<td>Visualizar con prints</td>
<td>Fibonacci</td>
</tr>
<tr>
<td>J</td>
<td>RecursionError</td>
<td>LÃ­mites y cÃ³mo evitarlo</td>
<td>sys.setrecursionlimit</td>
</tr>
<tr>
<td>V</td>
<td>Suma de lista recursiva</td>
<td><code>sum_list()</code></td>
<td>Ejercicio 7.2</td>
</tr>
<tr>
<td>S</td>
<td><strong>Repaso</strong></td>
<td>Funciones recursivas bÃ¡sicas</td>
<td>Test</td>
</tr>
</tbody>
</table>
<h3>Semana 13</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>Divide &amp; Conquer</td>
<td>PatrÃ³n general</td>
<td>Diagrama</td>
</tr>
<tr>
<td>M</td>
<td>Merge de listas</td>
<td>Fusionar ordenadas</td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>X</td>
<td>BÃºsqueda recursiva</td>
<td>Buscar en lista</td>
<td>Ejercicio 7.3</td>
</tr>
<tr>
<td>J</td>
<td>OptimizaciÃ³n (memoization)</td>
<td>Concepto bÃ¡sico</td>
<td>Fibonacci optimizado</td>
</tr>
<tr>
<td>V</td>
<td>Testing recursivo</td>
<td>Casos base y grandes</td>
<td>test_recursion.py</td>
</tr>
<tr>
<td>S</td>
<td><strong>Repaso</strong></td>
<td>MÃ³dulo recursiÃ³n completo</td>
<td>AutoevaluaciÃ³n</td>
</tr>
</tbody>
</table>
<p><strong>Entregable:</strong> Funciones recursivas con tests.</p>
<hr />
<h2>ğŸ—“ï¸ SEMANA 14-15: Algoritmos de Ordenamiento</h2>
<p><strong>MÃ³dulo:</strong> 08 - Algoritmos de Ordenamiento<br />
<strong>Objetivo:</strong> Implementar QuickSort y MergeSort desde cero</p>
<h3>Semana 14</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>QuickSort: concepto</td>
<td>Pivot, particiÃ³n</td>
<td>Diagrama</td>
</tr>
<tr>
<td>M</td>
<td>QuickSort: particiÃ³n</td>
<td>Implementar partition()</td>
<td>Ejercicio 8.1</td>
</tr>
<tr>
<td>X</td>
<td>QuickSort: recursiÃ³n</td>
<td>Implementar quicksort()</td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>J</td>
<td>Pivot selection</td>
<td>Random vs fijo</td>
<td>Comparar</td>
</tr>
<tr>
<td>V</td>
<td>AnÃ¡lisis de complejidad</td>
<td>O(n log n) vs O(nÂ²)</td>
<td>Documento</td>
</tr>
<tr>
<td>S</td>
<td><strong>Repaso</strong></td>
<td>QuickSort funcional</td>
<td>Test bÃ¡sico</td>
</tr>
</tbody>
</table>
<h3>Semana 15</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>MergeSort: concepto</td>
<td>Divide, merge</td>
<td>Diagrama</td>
</tr>
<tr>
<td>M</td>
<td>MergeSort: merge</td>
<td>Implementar merge()</td>
<td>Ejercicio 8.2</td>
</tr>
<tr>
<td>X</td>
<td>MergeSort: recursiÃ³n</td>
<td>Implementar mergesort()</td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>J</td>
<td>ComparaciÃ³n Quick vs Merge</td>
<td>CuÃ¡ndo usar cada uno</td>
<td>Tabla comparativa</td>
</tr>
<tr>
<td>V</td>
<td>Testing exhaustivo</td>
<td>Casos edge, estabilidad</td>
<td>test_sorting.py</td>
</tr>
<tr>
<td>S</td>
<td><strong>Repaso</strong></td>
<td>sorting.py completo</td>
<td>Benchmark</td>
</tr>
</tbody>
</table>
<p><strong>Entregable:</strong> <code>sorting.py</code> con QuickSort, MergeSort, anÃ¡lisis.</p>
<hr />
<h2>ğŸ—“ï¸ SEMANA 16: BÃºsqueda Binaria</h2>
<p><strong>MÃ³dulo:</strong> 09 - BÃºsqueda Binaria<br />
<strong>Objetivo:</strong> ImplementaciÃ³n perfecta sin errores off-by-one</p>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>Binary Search: concepto</td>
<td>Dividir espacio a la mitad</td>
<td>Diagrama</td>
</tr>
<tr>
<td>M</td>
<td>ImplementaciÃ³n clÃ¡sica</td>
<td><code>binary_search()</code></td>
<td>Ejercicio 9.1</td>
</tr>
<tr>
<td>X</td>
<td>Off-by-one errors</td>
<td>CÃ³mo evitarlos</td>
<td>Debug comÃºn</td>
</tr>
<tr>
<td>J</td>
<td>Variante: primer elemento</td>
<td><code>find_first()</code></td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>V</td>
<td>Variante: Ãºltimo elemento</td>
<td><code>find_last()</code></td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>S</td>
<td><strong>Checkpoint Fase III</strong></td>
<td>Simulacro Algoritmos</td>
<td>AutoevaluaciÃ³n</td>
</tr>
</tbody>
</table>
<p><strong>Entregable:</strong> <code>searching.py</code> con variantes de binary search.</p>
<p><strong>Checkpoint:</strong> <a href="#mod_SIMULACRO_ALGORITMOS">SIMULACRO_ALGORITMOS.md</a></p>
<hr />
<h2>ğŸ—“ï¸ SEMANA 17-18: Ãlgebra Lineal sin NumPy</h2>
<p><strong>MÃ³dulo:</strong> 10 - Ãlgebra Lineal sin NumPy<br />
<strong>Objetivo:</strong> Operaciones vectoriales y matriciales desde cero</p>
<h3>Semana 17</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>Vectores como listas</td>
<td>RepresentaciÃ³n</td>
<td>Ejercicio 10.1</td>
</tr>
<tr>
<td>M</td>
<td>Suma de vectores</td>
<td><code>add_vectors()</code></td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>X</td>
<td>Producto escalar</td>
<td>Multiplicar por escalar</td>
<td>Ejercicio 10.2</td>
</tr>
<tr>
<td>J</td>
<td>Producto punto</td>
<td><code>dot_product()</code></td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>V</td>
<td>Norma/magnitud</td>
<td><code>magnitude()</code></td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>S</td>
<td><strong>Repaso</strong></td>
<td>Operaciones vectoriales</td>
<td>Test</td>
</tr>
</tbody>
</table>
<h3>Semana 18</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>Matrices como listas de listas</td>
<td>RepresentaciÃ³n 2D</td>
<td>Ejercicio 10.3</td>
</tr>
<tr>
<td>M</td>
<td>Suma de matrices</td>
<td><code>add_matrices()</code></td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>X</td>
<td>Transpuesta</td>
<td><code>transpose()</code></td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>J</td>
<td>Producto matriz-vector</td>
<td><code>matrix_vector_mult()</code></td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>V</td>
<td>Testing matemÃ¡tico</td>
<td>Verificar con cÃ¡lculos</td>
<td>test_linear_algebra.py</td>
</tr>
<tr>
<td>S</td>
<td><strong>Repaso</strong></td>
<td>linear_algebra.py completo</td>
<td>AutoevaluaciÃ³n</td>
</tr>
</tbody>
</table>
<p><strong>Entregable:</strong> <code>linear_algebra.py</code> con operaciones vectoriales/matriciales.</p>
<hr />
<h2>ğŸ—“ï¸ SEMANA 19-20: TF-IDF y Similitud de Coseno</h2>
<p><strong>MÃ³dulo:</strong> 11 - TF-IDF y Similitud de Coseno<br />
<strong>Objetivo:</strong> Sistema de ranking por relevancia</p>
<h3>Semana 19</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>Term Frequency (TF)</td>
<td>FÃ³rmula y concepto</td>
<td>Ejercicio 11.1</td>
</tr>
<tr>
<td>M</td>
<td>Implementar TF</td>
<td><code>compute_tf()</code></td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>X</td>
<td>Inverse Document Frequency</td>
<td>FÃ³rmula y concepto</td>
<td>Ejercicio 11.2</td>
</tr>
<tr>
<td>J</td>
<td>Implementar IDF</td>
<td><code>compute_idf()</code></td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>V</td>
<td>TF-IDF combinado</td>
<td><code>compute_tfidf()</code></td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>S</td>
<td><strong>Repaso</strong></td>
<td>Vectores TF-IDF</td>
<td>Test manual</td>
</tr>
</tbody>
</table>
<h3>Semana 20</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>MaÃ±ana (TeorÃ­a)</th>
<th>MediodÃ­a (CÃ³digo)</th>
<th>Tarde (PrÃ¡ctica)</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>Similitud de Coseno</td>
<td>FÃ³rmula y geometrÃ­a</td>
<td>Diagrama</td>
</tr>
<tr>
<td>M</td>
<td>Implementar coseno</td>
<td><code>cosine_similarity()</code></td>
<td>Ejercicio 11.3</td>
</tr>
<tr>
<td>X</td>
<td>Ranking de documentos</td>
<td>Ordenar por similitud</td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>J</td>
<td>Integrar con QuickSort</td>
<td>Ordenar resultados</td>
<td>ImplementaciÃ³n</td>
</tr>
<tr>
<td>V</td>
<td>Testing completo</td>
<td>Verificar rankings</td>
<td>test_similarity.py</td>
</tr>
<tr>
<td>S</td>
<td><strong>Checkpoint Fase IV</strong></td>
<td>Simulacro MatemÃ¡ticas</td>
<td>AutoevaluaciÃ³n</td>
</tr>
</tbody>
</table>
<p><strong>Entregable:</strong> <code>vectorizer.py</code> + <code>similarity.py</code> + tests.</p>
<p><strong>Checkpoint:</strong> <a href="#mod_SIMULACRO_MATEMATICAS">SIMULACRO_MATEMATICAS.md</a></p>
<hr />
<h2>ğŸ—“ï¸ SEMANA 21-24: Proyecto Integrador</h2>
<p><strong>MÃ³dulo:</strong> 12 - Proyecto Integrador<br />
<strong>Objetivo:</strong> Motor de bÃºsqueda completo + defensa tÃ©cnica</p>
<h3>Semana 21: Ensamblaje</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>Actividad</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>DiseÃ±ar clase <code>SearchEngine</code></td>
</tr>
<tr>
<td>M</td>
<td>Integrar <code>Corpus</code> + <code>InvertedIndex</code></td>
</tr>
<tr>
<td>X</td>
<td>Integrar <code>Tokenizer</code></td>
</tr>
<tr>
<td>J</td>
<td>Integrar <code>Vectorizer</code> + <code>Similarity</code></td>
</tr>
<tr>
<td>V</td>
<td>MÃ©todo <code>search(query, top_k)</code></td>
</tr>
<tr>
<td>S</td>
<td>Demo bÃ¡sica funcionando</td>
</tr>
</tbody>
</table>
<h3>Semana 22: Refinamiento</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>Actividad</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>Integrar <code>QuickSort</code> para ranking</td>
</tr>
<tr>
<td>M</td>
<td>Optimizar performance</td>
</tr>
<tr>
<td>X</td>
<td>Tests de integraciÃ³n</td>
</tr>
<tr>
<td>J</td>
<td>Casos edge y errores</td>
</tr>
<tr>
<td>V</td>
<td>Cobertura &gt;80%</td>
</tr>
<tr>
<td>S</td>
<td>RefactorizaciÃ³n</td>
</tr>
</tbody>
</table>
<h3>Semana 23: DocumentaciÃ³n y AnÃ¡lisis</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>Actividad</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>AnÃ¡lisis Big O: agregar documento</td>
</tr>
<tr>
<td>M</td>
<td>AnÃ¡lisis Big O: bÃºsqueda</td>
</tr>
<tr>
<td>X</td>
<td>AnÃ¡lisis Big O: ranking</td>
</tr>
<tr>
<td>J</td>
<td>Escribir COMPLEXITY_ANALYSIS.md</td>
</tr>
<tr>
<td>V</td>
<td>README.md profesional (inglÃ©s)</td>
</tr>
<tr>
<td>S</td>
<td>Revisar documentaciÃ³n</td>
</tr>
</tbody>
</table>
<h3>Semana 24: Defensa y PreparaciÃ³n</h3>
<table>
<thead>
<tr>
<th>DÃ­a</th>
<th>Actividad</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>Preparar presentaciÃ³n (5 min)</td>
</tr>
<tr>
<td>M</td>
<td>Practicar explicaciÃ³n en inglÃ©s</td>
</tr>
<tr>
<td>X</td>
<td>Simulacro de entrevista</td>
</tr>
<tr>
<td>J</td>
<td>Ajustes finales</td>
</tr>
<tr>
<td>V</td>
<td><strong>Demo final grabada</strong></td>
</tr>
<tr>
<td>S</td>
<td><strong>AutoevaluaciÃ³n final</strong></td>
</tr>
</tbody>
</table>
<p><strong>Entregable Final:</strong><br />
1. âœ… Motor de bÃºsqueda funcional<br />
2. âœ… AnÃ¡lisis de complejidad completo<br />
3. âœ… README en inglÃ©s<br />
4. âœ… Tests con &gt;80% coverage<br />
5. âœ… Demo grabada (opcional)</p>
<hr />
<h2>âœ… Checklist de FinalizaciÃ³n</h2>
<ul>
<li>[ ] MÃ³dulos 01-12 completados</li>
<li>[ ] Proyecto <code>archimedes-indexer</code> funcional</li>
<li>[ ] Todos los tests pasando</li>
<li>[ ] Coverage &gt;80%</li>
<li>[ ] <code>COMPLEXITY_ANALYSIS.md</code> completo</li>
<li>[ ] README.md en inglÃ©s</li>
<li>[ ] Simulacro de entrevista aprobado</li>
<li>[ ] Capaz de explicar Big O de cada componente</li>
</ul>
<hr />
<h2>ğŸ“š Recursos Generales</h2>
<ul>
<li><a href="https://www.coursera.org/specializations/mathematics-machine-learning">Mathematics for ML Specialization</a></li>
<li><a href="https://www.manning.com/books/grokking-algorithms">Grokking Algorithms</a></li>
<li><a href="https://leetcode.com/">LeetCode</a> - PrÃ¡ctica de algoritmos</li>
<li><a href="https://docs.python.org/3/library/typing.html">Python Type Hints</a></li>
</ul>
<hr />
<blockquote>
<p>ğŸ’¡ <strong>Tip:</strong> Si un dÃ­a no puedes completar todo, prioriza la <strong>implementaciÃ³n</strong> sobre la lectura. El cÃ³digo te enseÃ±a mÃ¡s que la teorÃ­a sola.</p>
</blockquote>
        </section>
        
        <div id="mod_01_PYTHON_PROFESIONAL" class="cover-page">
            <a name="mod_01_PYTHON_PROFESIONAL"></a>
            <div class="cover-title">01 - Python Profesional</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>01 - Python Profesional</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Transformar cÃ³digo Python funcional en cÃ³digo profesional con type hints, funciones puras y estÃ¡ndares de la industria.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: El Arquitecto vs El AlbaÃ±il</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                                â”‚
â”‚   ALBAÃ‘IL                              ARQUITECTO                              â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€                             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                              â”‚
â”‚   &quot;Pon ladrillos aquÃ­&quot;                 &quot;Plano estructural con medidas&quot;         â”‚
â”‚   Funciona, pero no escala             Cualquiera puede construirlo            â”‚
â”‚   Solo Ã©l sabe cÃ³mo                    Verificable y mantenible                â”‚
â”‚                                                                                â”‚
â”‚   def process(x):                      def process(data: list[int]) -&gt; int:    â”‚
â”‚       return x + 1                         &quot;&quot;&quot;Sum all positive numbers.&quot;&quot;&quot;     â”‚
â”‚                                            return sum(n for n in data if n&gt;0)  â”‚
â”‚                                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>El cÃ³digo profesional es como un plano arquitectÃ³nico: cualquier ingeniero puede leerlo, entenderlo y construir a partir de Ã©l.</p>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-type-hints">Type Hints: DocumentaciÃ³n Ejecutable</a></li>
<li><a href="#2-funciones-puras">Funciones Puras vs Impuras</a></li>
<li><a href="#3-pep8">PEP8 y Estilo Consistente</a></li>
<li><a href="#4-docstrings">Docstrings Profesionales</a></li>
<li><a href="#5-configuracion">ConfiguraciÃ³n de Herramientas</a></li>
</ol>
<hr />
<h2>1. Type Hints: DocumentaciÃ³n Ejecutable {#1-type-hints}</h2>
<h3>1.1 Â¿Por quÃ© Type Hints?</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SIN TYPE HINTS                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                â”‚
â”‚  def tokenize(text):     # Â¿text es str? Â¿bytes? Â¿list?         â”‚
â”‚      return text.split() # Â¿Retorna list? Â¿set? Â¿generator?     â”‚
â”‚                                                                 â”‚
â”‚  CON TYPE HINTS                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                 â”‚
â”‚  def tokenize(text: str) -&gt; list[str]:                          â”‚
â”‚      return text.split()  # Claro: recibe str, retorna list     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p><strong>Beneficios:</strong><br />
- ğŸ“– DocumentaciÃ³n que no se desactualiza<br />
- ğŸ› Errores detectados antes de ejecutar (con <code>mypy</code>)<br />
- ğŸ¤– Autocompletado inteligente en el IDE<br />
- ğŸ” CÃ³digo mÃ¡s fÃ¡cil de leer y mantener</p>
<h3>1.2 Tipos BÃ¡sicos</h3>
<pre><code class="language-python"># Tipos primitivos
name: str = &quot;Archimedes&quot;
count: int = 42
ratio: float = 3.14159
is_active: bool = True
nothing: None = None

# Colecciones (Python 3.9+)
words: list[str] = [&quot;hello&quot;, &quot;world&quot;]
scores: dict[str, float] = {&quot;doc1&quot;: 0.85, &quot;doc2&quot;: 0.92}
unique_words: set[str] = {&quot;the&quot;, &quot;and&quot;, &quot;or&quot;}
coordinates: tuple[float, float] = (10.5, 20.3)
</code></pre>
<h3>1.3 Tipos en Funciones</h3>
<pre><code class="language-python"># âŒ ANTES: Â¿QuÃ© recibe? Â¿QuÃ© retorna?
def clean(text):
    return text.lower().strip()

# âœ… DESPUÃ‰S: Claro y verificable
def clean(text: str) -&gt; str:
    &quot;&quot;&quot;Remove whitespace and convert to lowercase.&quot;&quot;&quot;
    return text.lower().strip()
</code></pre>
<h3>1.4 Tipos Avanzados</h3>
<pre><code class="language-python">from typing import Optional, Union

# Optional: puede ser el tipo o None
def find_document(doc_id: int) -&gt; Optional[str]:
    &quot;&quot;&quot;Return document content or None if not found.&quot;&quot;&quot;
    if doc_id in documents:
        return documents[doc_id]
    return None

# Union: puede ser uno de varios tipos (Python 3.10+ usa |)
def process(data: Union[str, list[str]]) -&gt; list[str]:
    &quot;&quot;&quot;Accept string or list of strings.&quot;&quot;&quot;
    if isinstance(data, str):
        return [data]
    return data

# Python 3.10+ syntax
def process_modern(data: str | list[str]) -&gt; list[str]:
    if isinstance(data, str):
        return [data]
    return data
</code></pre>
<h3>1.5 Type Hints para Clases</h3>
<pre><code class="language-python">class Document:
    def __init__(self, doc_id: int, content: str) -&gt; None:
        self.doc_id: int = doc_id
        self.content: str = content
        self.tokens: list[str] = []

    def tokenize(self) -&gt; list[str]:
        &quot;&quot;&quot;Split content into tokens.&quot;&quot;&quot;
        self.tokens = self.content.lower().split()
        return self.tokens

    def word_count(self) -&gt; int:
        &quot;&quot;&quot;Return number of tokens.&quot;&quot;&quot;
        return len(self.tokens)
</code></pre>
<h3>1.6 VerificaciÃ³n con mypy</h3>
<pre><code class="language-bash"># Instalar mypy
pip install mypy

# Verificar un archivo
mypy src/document.py

# Verificar todo el proyecto
mypy src/

# ConfiguraciÃ³n en pyproject.toml
</code></pre>
<pre><code class="language-toml"># pyproject.toml
[tool.mypy]
python_version = &quot;3.11&quot;
warn_return_any = true
warn_unused_ignores = true
disallow_untyped_defs = true
</code></pre>
<hr />
<h2>2. Funciones Puras vs Impuras {#2-funciones-puras}</h2>
<h3>2.1 Â¿QuÃ© es una FunciÃ³n Pura?</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FUNCIÃ“N PURA                                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                  â”‚
â”‚  1. Mismo input â†’ siempre mismo output                          â”‚
â”‚  2. Sin efectos secundarios (no modifica estado externo)        â”‚
â”‚                                                                 â”‚
â”‚  VENTAJAS:                                                      â”‚
â”‚  âœ… FÃ¡cil de testear                                            â”‚
â”‚  âœ… FÃ¡cil de entender                                           â”‚
â”‚  âœ… Paralelizable                                               â”‚
â”‚  âœ… Cacheable (memoization)                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>2.2 Ejemplos Comparativos</h3>
<pre><code class="language-python"># âŒ IMPURA: modifica estado externo
results = []

def add_result_impure(value):
    results.append(value)  # Modifica lista externa
    return len(results)

# âœ… PURA: retorna nuevo valor sin modificar nada
def add_result_pure(results: list[int], value: int) -&gt; list[int]:
    return results + [value]  # Retorna nueva lista


# âŒ IMPURA: depende de estado externo
multiplier = 2

def multiply_impure(x):
    return x * multiplier  # Depende de variable externa

# âœ… PURA: todo lo necesario viene como parÃ¡metro
def multiply_pure(x: int, multiplier: int) -&gt; int:
    return x * multiplier
</code></pre>
<h3>2.3 Evitar MutaciÃ³n de Argumentos</h3>
<pre><code class="language-python"># âŒ PELIGROSO: modifica el argumento original
def remove_stopwords_bad(tokens: list[str], stopwords: set[str]) -&gt; list[str]:
    for word in list(tokens):  # Itera sobre copia para poder modificar
        if word in stopwords:
            tokens.remove(word)  # Â¡Modifica la lista original!
    return tokens

# âœ… SEGURO: crea nueva lista
def remove_stopwords_good(tokens: list[str], stopwords: set[str]) -&gt; list[str]:
    return [word for word in tokens if word not in stopwords]
</code></pre>
<h3>2.4 CuÃ¡ndo las Funciones Impuras Son Necesarias</h3>
<p>Algunas operaciones requieren efectos secundarios:<br />
- Escribir a disco<br />
- Imprimir a consola<br />
- Conectar a base de datos<br />
- Generar nÃºmeros aleatorios</p>
<p><strong>Estrategia:</strong> Aislar las funciones impuras y mantener la lÃ³gica de negocio pura.</p>
<pre><code class="language-python"># LÃ³gica pura (testeable)
def prepare_document(content: str) -&gt; dict[str, any]:
    tokens = content.lower().split()
    return {
        &quot;tokens&quot;: tokens,
        &quot;word_count&quot;: len(tokens),
        &quot;char_count&quot;: len(content)
    }

# FunciÃ³n impura aislada
def save_document(doc_data: dict[str, any], filepath: str) -&gt; None:
    with open(filepath, 'w') as f:
        json.dump(doc_data, f)
</code></pre>
<hr />
<h2>3. PEP8 y Estilo Consistente {#3-pep8}</h2>
<h3>3.1 Reglas Esenciales</h3>
<table>
<thead>
<tr>
<th>Regla</th>
<th>Ejemplo Correcto</th>
</tr>
</thead>
<tbody>
<tr>
<td>IndentaciÃ³n: 4 espacios</td>
<td><code>def func():âÂ·Â·Â·Â·code</code></td>
</tr>
<tr>
<td>LÃ­nea mÃ¡xima: 88-100 caracteres</td>
<td>Configurar en linter</td>
</tr>
<tr>
<td>Espacios alrededor de operadores</td>
<td><code>x = 1 + 2</code> (no <code>x=1+2</code>)</td>
</tr>
<tr>
<td>Nombres de variables: snake_case</td>
<td><code>word_count</code>, <code>doc_id</code></td>
</tr>
<tr>
<td>Nombres de clases: PascalCase</td>
<td><code>Document</code>, <code>InvertedIndex</code></td>
</tr>
<tr>
<td>Constantes: UPPER_CASE</td>
<td><code>MAX_TOKENS = 1000</code></td>
</tr>
</tbody>
</table>
<h3>3.2 Nombres Descriptivos</h3>
<pre><code class="language-python"># âŒ Nombres crÃ­pticos
def proc(d):
    r = []
    for i in d:
        if len(i) &gt; 3:
            r.append(i)
    return r

# âœ… Nombres descriptivos
def filter_short_words(tokens: list[str], min_length: int = 3) -&gt; list[str]:
    &quot;&quot;&quot;Remove tokens shorter than min_length.&quot;&quot;&quot;
    return [token for token in tokens if len(token) &gt; min_length]
</code></pre>
<h3>3.3 Configurar Linter (ruff)</h3>
<pre><code class="language-bash"># Instalar ruff (rÃ¡pido y moderno)
pip install ruff

# Verificar cÃ³digo
ruff check src/

# Corregir automÃ¡ticamente
ruff check --fix src/
</code></pre>
<pre><code class="language-toml"># pyproject.toml
[tool.ruff]
line-length = 88
select = [&quot;E&quot;, &quot;F&quot;, &quot;W&quot;, &quot;I&quot;, &quot;N&quot;, &quot;UP&quot;]

[tool.ruff.per-file-ignores]
&quot;tests/*&quot; = [&quot;S101&quot;]  # Permitir assert en tests
</code></pre>
<hr />
<h2>4. Docstrings Profesionales {#4-docstrings}</h2>
<h3>4.1 Formato Google Style</h3>
<pre><code class="language-python">def compute_tf(term: str, document: list[str]) -&gt; float:
    &quot;&quot;&quot;Compute Term Frequency for a term in a document.

    Term Frequency measures how often a term appears in a document,
    normalized by the total number of terms.

    Args:
        term: The word to search for.
        document: List of tokens in the document.

    Returns:
        The term frequency as a float between 0 and 1.

    Raises:
        ValueError: If document is empty.

    Example:
        &gt;&gt;&gt; compute_tf(&quot;hello&quot;, [&quot;hello&quot;, &quot;world&quot;, &quot;hello&quot;])
        0.6666666666666666
    &quot;&quot;&quot;
    if not document:
        raise ValueError(&quot;Document cannot be empty&quot;)

    count = document.count(term)
    return count / len(document)
</code></pre>
<h3>4.2 Docstrings para Clases</h3>
<pre><code class="language-python">class Document:
    &quot;&quot;&quot;Represents a text document with metadata.

    A Document holds the original content along with processed
    tokens and provides methods for text analysis.

    Attributes:
        doc_id: Unique identifier for the document.
        content: Original text content.
        tokens: List of processed tokens (populated after tokenize()).

    Example:
        &gt;&gt;&gt; doc = Document(1, &quot;Hello World&quot;)
        &gt;&gt;&gt; doc.tokenize()
        ['hello', 'world']
    &quot;&quot;&quot;

    def __init__(self, doc_id: int, content: str) -&gt; None:
        &quot;&quot;&quot;Initialize a Document.

        Args:
            doc_id: Unique identifier.
            content: Raw text content.
        &quot;&quot;&quot;
        self.doc_id = doc_id
        self.content = content
        self.tokens: list[str] = []
</code></pre>
<hr />
<h2>5. ConfiguraciÃ³n de Herramientas {#5-configuracion}</h2>
<h3>5.1 pyproject.toml Completo</h3>
<pre><code class="language-toml">[project]
name = &quot;archimedes-indexer&quot;
version = &quot;0.1.0&quot;
description = &quot;A search engine built from scratch&quot;
requires-python = &quot;&gt;=3.11&quot;

[tool.mypy]
python_version = &quot;3.11&quot;
warn_return_any = true
warn_unused_ignores = true
disallow_untyped_defs = true
ignore_missing_imports = true

[tool.ruff]
line-length = 88
select = [
    &quot;E&quot;,   # pycodestyle errors
    &quot;F&quot;,   # pyflakes
    &quot;W&quot;,   # pycodestyle warnings
    &quot;I&quot;,   # isort
    &quot;N&quot;,   # pep8-naming
    &quot;UP&quot;,  # pyupgrade
]

[tool.pytest.ini_options]
testpaths = [&quot;tests&quot;]
python_files = &quot;test_*.py&quot;
</code></pre>
<h3>5.2 Comandos de VerificaciÃ³n</h3>
<pre><code class="language-bash"># Verificar tipos
mypy src/

# Verificar estilo
ruff check src/

# Corregir estilo automÃ¡ticamente
ruff check --fix src/

# Todo junto (crear en Makefile)
make check
</code></pre>
<h3>5.3 Makefile BÃ¡sico</h3>
<pre><code class="language-makefile">.PHONY: check lint type-check test

check: lint type-check test

lint:
    ruff check src/ tests/

type-check:
    mypy src/

test:
    python -m pytest tests/ -v

fix:
    ruff check --fix src/ tests/
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes y CÃ³mo Evitarlos</h2>
<h3>Error 1: Type hints incorrectos</h3>
<pre><code class="language-python"># âŒ Error: list sin tipo genÃ©rico
def get_words(text: str) -&gt; list:  # mypy warning
    return text.split()

# âœ… Correcto
def get_words(text: str) -&gt; list[str]:
    return text.split()
</code></pre>
<h3>Error 2: Mutar argumentos por defecto</h3>
<pre><code class="language-python"># âŒ Bug clÃ¡sico: lista mutable como default
def add_word(word: str, words: list[str] = []) -&gt; list[str]:
    words.append(word)  # Â¡Se acumula entre llamadas!
    return words

# âœ… Correcto: usar None como default
def add_word(word: str, words: list[str] | None = None) -&gt; list[str]:
    if words is None:
        words = []
    return words + [word]
</code></pre>
<h3>Error 3: Olvidar el return type en <strong>init</strong></h3>
<pre><code class="language-python"># âŒ Incompleto
def __init__(self, doc_id: int):
    self.doc_id = doc_id

# âœ… Completo (siempre -&gt; None)
def __init__(self, doc_id: int) -&gt; None:
    self.doc_id = doc_id
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 1.1: Tipar una FunciÃ³n</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a> - Agregar type hints a funciÃ³n de tokenizaciÃ³n.</p>
<h3>Ejercicio 1.2: Convertir a FunciÃ³n Pura</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a> - Refactorizar funciÃ³n impura.</p>
<h3>Ejercicio 1.3: Configurar Linters</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a> - Crear pyproject.toml completo.</p>
<h3>Ejercicio 1.4: Escribir Docstrings</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a> - Documentar mÃ³dulo completo.</p>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://realpython.com/python-type-checking/">Real Python: Type Checking</a></td>
<td>Tutorial</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://peps.python.org/pep-0008/">PEP 8</a></td>
<td>DocumentaciÃ³n</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://mypy.readthedocs.io/">mypy Documentation</a></td>
<td>DocumentaciÃ³n</td>
<td>ğŸŸ¡ Recomendado</td>
</tr>
<tr>
<td><a href="https://google.github.io/styleguide/pyguide.html">Google Python Style Guide</a></td>
<td>GuÃ­a</td>
<td>ğŸŸ¢ Complementario</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ”— Referencias del Glosario</h2>
<ul>
<li><a href="#mod_GLOSARIO">Type Hint</a></li>
<li><a href="#mod_GLOSARIO">FunciÃ³n Pura</a></li>
<li><a href="#mod_GLOSARIO">PEP8</a></li>
<li><a href="#mod_GLOSARIO">Docstring</a></li>
<li><a href="#mod_GLOSARIO">Linter</a></li>
</ul>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_02_OOP_DESDE_CERO">02_OOP_DESDE_CERO</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_02_OOP_DESDE_CERO" class="cover-page">
            <a name="mod_02_OOP_DESDE_CERO"></a>
            <div class="cover-title">02 - OOP desde Cero</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>02 - OOP desde Cero</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> DiseÃ±ar clases profesionales que representen documentos y colecciones, aplicando principios SOLID bÃ¡sicos.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: La FÃ¡brica de Documentos</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   CLASE = PLANO DE FÃBRICA                                                  â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                 â”‚
â”‚   Document (plano)  â”€â”€â”€â”€â”€â”€â–º  doc1, doc2, doc3 (productos)                   â”‚
â”‚                                                                             â”‚
â”‚   El plano define:                                                          â”‚
â”‚   â€¢ QuÃ© propiedades tiene cada documento (id, contenido, tokens)            â”‚
â”‚   â€¢ QuÃ© puede hacer cada documento (tokenizar, contar palabras)             â”‚
â”‚                                                                             â”‚
â”‚   CORPUS = ALMACÃ‰N                                                          â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                         â”‚
â”‚   Corpus (almacÃ©n)  â”€â”€â”€â”€â”€â”€â–º  Contiene mÃºltiples documentos                  â”‚
â”‚                              Sabe agregar, buscar, iterar                   â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-clases-basicas">Clases y Objetos BÃ¡sicos</a></li>
<li><a href="#2-metodos-magicos">MÃ©todos MÃ¡gicos</a></li>
<li><a href="#3-properties">Properties y Encapsulamiento</a></li>
<li><a href="#4-composicion">ComposiciÃ³n vs Herencia</a></li>
<li><a href="#5-solid">Principios SOLID BÃ¡sicos</a></li>
<li><a href="#6-dataclasses">Dataclasses</a></li>
</ol>
<hr />
<h2>1. Clases y Objetos BÃ¡sicos {#1-clases-basicas}</h2>
<h3>1.1 AnatomÃ­a de una Clase</h3>
<pre><code class="language-python">class Document:
    &quot;&quot;&quot;Represents a single document in the corpus.&quot;&quot;&quot;

    # Atributo de clase (compartido por todas las instancias)
    document_count: int = 0

    def __init__(self, doc_id: int, content: str) -&gt; None:
        &quot;&quot;&quot;Initialize a new Document.

        Args:
            doc_id: Unique identifier for this document.
            content: Raw text content of the document.
        &quot;&quot;&quot;
        # Atributos de instancia (Ãºnicos para cada objeto)
        self.doc_id: int = doc_id
        self.content: str = content
        self.tokens: list[str] = []

        # Incrementar contador de clase
        Document.document_count += 1

    def tokenize(self) -&gt; list[str]:
        &quot;&quot;&quot;Split content into lowercase tokens.

        Returns:
            List of tokens extracted from content.
        &quot;&quot;&quot;
        self.tokens = self.content.lower().split()
        return self.tokens

    def word_count(self) -&gt; int:
        &quot;&quot;&quot;Return the number of tokens.

        Note:
            Must call tokenize() first, or returns 0.
        &quot;&quot;&quot;
        return len(self.tokens)
</code></pre>
<h3>1.2 Creando y Usando Objetos</h3>
<pre><code class="language-python"># Crear instancias (objetos)
doc1 = Document(1, &quot;Hello World&quot;)
doc2 = Document(2, &quot;Goodbye World&quot;)

# Llamar mÃ©todos
doc1.tokenize()
print(doc1.tokens)  # ['hello', 'world']
print(doc1.word_count())  # 2

# Acceder al atributo de clase
print(Document.document_count)  # 2
</code></pre>
<h3>1.3 Self: La Referencia al Objeto Actual</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  self = &quot;yo mismo&quot;                                              â”‚
â”‚                                                                 â”‚
â”‚  Cuando llamas doc1.tokenize(), Python traduce a:               â”‚
â”‚  Document.tokenize(doc1)                                        â”‚
â”‚                                                                 â”‚
â”‚  self es simplemente el objeto sobre el que se llama el mÃ©todo  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>2. MÃ©todos MÃ¡gicos (Dunder Methods) {#2-metodos-magicos}</h2>
<h3>2.1 Los MÃ¡s Importantes</h3>
<table>
<thead>
<tr>
<th>MÃ©todo</th>
<th>CuÃ¡ndo se llama</th>
<th>PropÃ³sito</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__init__</code></td>
<td>Al crear objeto</td>
<td>Inicializar atributos</td>
</tr>
<tr>
<td><code>__repr__</code></td>
<td><code>repr(obj)</code>, debugger</td>
<td>RepresentaciÃ³n tÃ©cnica</td>
</tr>
<tr>
<td><code>__str__</code></td>
<td><code>str(obj)</code>, <code>print(obj)</code></td>
<td>RepresentaciÃ³n legible</td>
</tr>
<tr>
<td><code>__eq__</code></td>
<td><code>obj1 == obj2</code></td>
<td>Comparar igualdad</td>
</tr>
<tr>
<td><code>__len__</code></td>
<td><code>len(obj)</code></td>
<td>Retornar "longitud"</td>
</tr>
<tr>
<td><code>__iter__</code></td>
<td><code>for x in obj</code></td>
<td>Hacer iterable</td>
</tr>
</tbody>
</table>
<h3>2.2 ImplementaciÃ³n Completa</h3>
<pre><code class="language-python">class Document:
    def __init__(self, doc_id: int, content: str) -&gt; None:
        self.doc_id = doc_id
        self.content = content
        self.tokens: list[str] = []

    def __repr__(self) -&gt; str:
        &quot;&quot;&quot;Technical representation for debugging.

        Example:
            &gt;&gt;&gt; doc = Document(1, &quot;Hello World&quot;)
            &gt;&gt;&gt; repr(doc)
            &quot;Document(doc_id=1, content='Hello World')&quot;
        &quot;&quot;&quot;
        return f&quot;Document(doc_id={self.doc_id}, content='{self.content[:20]}...')&quot;

    def __str__(self) -&gt; str:
        &quot;&quot;&quot;Human-readable representation.

        Example:
            &gt;&gt;&gt; print(doc)
            Document #1: Hello World (2 words)
        &quot;&quot;&quot;
        word_count = len(self.tokens) if self.tokens else &quot;not tokenized&quot;
        return f&quot;Document #{self.doc_id}: {self.content[:30]}... ({word_count} words)&quot;

    def __eq__(self, other: object) -&gt; bool:
        &quot;&quot;&quot;Check equality based on doc_id.

        Two documents are equal if they have the same doc_id.
        &quot;&quot;&quot;
        if not isinstance(other, Document):
            return NotImplemented
        return self.doc_id == other.doc_id

    def __len__(self) -&gt; int:
        &quot;&quot;&quot;Return number of tokens (after tokenization).&quot;&quot;&quot;
        return len(self.tokens)

    def __hash__(self) -&gt; int:
        &quot;&quot;&quot;Make Document hashable (usable in sets/dicts).&quot;&quot;&quot;
        return hash(self.doc_id)
</code></pre>
<h3>2.3 Uso de MÃ©todos MÃ¡gicos</h3>
<pre><code class="language-python">doc = Document(1, &quot;Hello World from Archimedes&quot;)
doc.tokenize()

# __repr__ (en debugger o consola)
&gt;&gt;&gt; doc
Document(doc_id=1, content='Hello World from Arc...')

# __str__ (con print)
&gt;&gt;&gt; print(doc)
Document #1: Hello World from Archimedes... (4 words)

# __len__
&gt;&gt;&gt; len(doc)
4

# __eq__
doc2 = Document(1, &quot;Different content&quot;)
&gt;&gt;&gt; doc == doc2
True  # Mismo doc_id

# __hash__ permite usar en sets
&gt;&gt;&gt; docs_set = {doc, doc2}
&gt;&gt;&gt; len(docs_set)
1  # Son &quot;iguales&quot; por doc_id
</code></pre>
<hr />
<h2>3. Properties y Encapsulamiento {#3-properties}</h2>
<h3>3.1 Â¿Por QuÃ© Encapsular?</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PROBLEMA: Acceso directo sin validaciÃ³n                        â”‚
â”‚                                                                 â”‚
â”‚  doc.doc_id = -5     # Â¿ID negativo? Â¡InvÃ¡lido!                 â”‚
â”‚  doc.content = None  # Â¿Contenido None? Â¡Error futuro!          â”‚
â”‚                                                                 â”‚
â”‚  SOLUCIÃ“N: Properties con validaciÃ³n                            â”‚
â”‚                                                                 â”‚
â”‚  doc.doc_id = -5     # Lanza ValueError                         â”‚
â”‚  doc.content = None  # Lanza TypeError                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>3.2 Implementando Properties</h3>
<pre><code class="language-python">class Document:
    def __init__(self, doc_id: int, content: str) -&gt; None:
        # Usar los setters para validar desde el inicio
        self._doc_id: int = 0  # Atributo &quot;privado&quot; (convenciÃ³n)
        self._content: str = &quot;&quot;

        # Estos llaman a los setters
        self.doc_id = doc_id
        self.content = content
        self.tokens: list[str] = []

    @property
    def doc_id(self) -&gt; int:
        &quot;&quot;&quot;Get document ID.&quot;&quot;&quot;
        return self._doc_id

    @doc_id.setter
    def doc_id(self, value: int) -&gt; None:
        &quot;&quot;&quot;Set document ID with validation.&quot;&quot;&quot;
        if not isinstance(value, int):
            raise TypeError(f&quot;doc_id must be int, got {type(value).__name__}&quot;)
        if value &lt; 0:
            raise ValueError(f&quot;doc_id must be non-negative, got {value}&quot;)
        self._doc_id = value

    @property
    def content(self) -&gt; str:
        &quot;&quot;&quot;Get document content.&quot;&quot;&quot;
        return self._content

    @content.setter
    def content(self, value: str) -&gt; None:
        &quot;&quot;&quot;Set content with validation.&quot;&quot;&quot;
        if not isinstance(value, str):
            raise TypeError(f&quot;content must be str, got {type(value).__name__}&quot;)
        if not value.strip():
            raise ValueError(&quot;content cannot be empty or whitespace only&quot;)
        self._content = value

    @property
    def is_tokenized(self) -&gt; bool:
        &quot;&quot;&quot;Check if document has been tokenized (read-only).&quot;&quot;&quot;
        return len(self.tokens) &gt; 0
</code></pre>
<h3>3.3 Uso de Properties</h3>
<pre><code class="language-python">doc = Document(1, &quot;Hello World&quot;)

# Lectura transparente (parece atributo normal)
print(doc.doc_id)  # 1

# Escritura con validaciÃ³n automÃ¡tica
doc.doc_id = 5     # OK
doc.doc_id = -1    # ValueError: doc_id must be non-negative

# Property de solo lectura
print(doc.is_tokenized)  # False
doc.tokenize()
print(doc.is_tokenized)  # True
# doc.is_tokenized = True  # AttributeError: can't set attribute
</code></pre>
<hr />
<h2>4. ComposiciÃ³n vs Herencia {#4-composicion}</h2>
<h3>4.1 La Regla de Oro</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚   &quot;Favor composition over inheritance&quot;                          â”‚
â”‚   (Prefiere composiciÃ³n sobre herencia)                         â”‚
â”‚                                                                 â”‚
â”‚   HERENCIA: &quot;ES UN&quot; (is-a)                                      â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                     â”‚
â”‚   Un Perro ES UN Animal                                         â”‚
â”‚   âœ… Tiene sentido                                              â”‚
â”‚                                                                 â”‚
â”‚   COMPOSICIÃ“N: &quot;TIENE UN&quot; (has-a)                               â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                               â”‚
â”‚   Un Corpus TIENE Documentos                                    â”‚
â”‚   âœ… MÃ¡s flexible                                               â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>4.2 ComposiciÃ³n: Corpus Contiene Documents</h3>
<pre><code class="language-python">class Corpus:
    &quot;&quot;&quot;A collection of documents.&quot;&quot;&quot;

    def __init__(self, name: str) -&gt; None:
        &quot;&quot;&quot;Initialize an empty corpus.

        Args:
            name: Name of this corpus.
        &quot;&quot;&quot;
        self.name: str = name
        self._documents: dict[int, Document] = {}  # ComposiciÃ³n: contiene Documents

    def add_document(self, doc: Document) -&gt; None:
        &quot;&quot;&quot;Add a document to the corpus.

        Args:
            doc: Document to add.

        Raises:
            ValueError: If document with same ID already exists.
        &quot;&quot;&quot;
        if doc.doc_id in self._documents:
            raise ValueError(f&quot;Document with id {doc.doc_id} already exists&quot;)
        self._documents[doc.doc_id] = doc

    def get_document(self, doc_id: int) -&gt; Document | None:
        &quot;&quot;&quot;Retrieve a document by ID.

        Args:
            doc_id: ID of document to retrieve.

        Returns:
            The Document if found, None otherwise.
        &quot;&quot;&quot;
        return self._documents.get(doc_id)

    def remove_document(self, doc_id: int) -&gt; bool:
        &quot;&quot;&quot;Remove a document by ID.

        Returns:
            True if document was removed, False if not found.
        &quot;&quot;&quot;
        if doc_id in self._documents:
            del self._documents[doc_id]
            return True
        return False

    def __len__(self) -&gt; int:
        &quot;&quot;&quot;Return number of documents in corpus.&quot;&quot;&quot;
        return len(self._documents)

    def __iter__(self):
        &quot;&quot;&quot;Iterate over documents.&quot;&quot;&quot;
        return iter(self._documents.values())

    def __contains__(self, doc_id: int) -&gt; bool:
        &quot;&quot;&quot;Check if document ID exists.&quot;&quot;&quot;
        return doc_id in self._documents
</code></pre>
<h3>4.3 CuÃ¡ndo Usar Herencia</h3>
<p>La herencia es apropiada cuando hay una relaciÃ³n "es un" clara:</p>
<pre><code class="language-python">from abc import ABC, abstractmethod

class Tokenizer(ABC):
    &quot;&quot;&quot;Abstract base class for tokenizers.&quot;&quot;&quot;

    @abstractmethod
    def tokenize(self, text: str) -&gt; list[str]:
        &quot;&quot;&quot;Tokenize text into words.&quot;&quot;&quot;
        pass

class SimpleTokenizer(Tokenizer):
    &quot;&quot;&quot;Basic whitespace tokenizer.&quot;&quot;&quot;

    def tokenize(self, text: str) -&gt; list[str]:
        return text.lower().split()

class AdvancedTokenizer(Tokenizer):
    &quot;&quot;&quot;Tokenizer that also removes punctuation.&quot;&quot;&quot;

    def __init__(self, min_length: int = 2) -&gt; None:
        self.min_length = min_length

    def tokenize(self, text: str) -&gt; list[str]:
        # Remove punctuation
        cleaned = ''.join(c if c.isalnum() or c.isspace() else ' ' for c in text)
        words = cleaned.lower().split()
        return [w for w in words if len(w) &gt;= self.min_length]
</code></pre>
<hr />
<h2>5. Principios SOLID BÃ¡sicos {#5-solid}</h2>
<h3>5.1 S - Single Responsibility Principle</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PRINCIPIO: Una clase debe tener una sola razÃ³n para cambiar    â”‚
â”‚                                                                 â”‚
â”‚  âŒ MAL: Document que hace todo                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                    â”‚
â”‚  class Document:                                                â”‚
â”‚      def tokenize(self): ...                                    â”‚
â”‚      def save_to_file(self): ...      # Persistencia            â”‚
â”‚      def compute_tfidf(self): ...     # CÃ¡lculo ML              â”‚
â”‚      def render_html(self): ...       # PresentaciÃ³n            â”‚
â”‚                                                                 â”‚
â”‚  âœ… BIEN: Responsabilidades separadas                           â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                             â”‚
â”‚  class Document:          # Solo datos del documento            â”‚
â”‚  class Tokenizer:         # Solo tokenizaciÃ³n                   â”‚
â”‚  class DocumentStorage:   # Solo persistencia                   â”‚
â”‚  class TFIDFCalculator:   # Solo cÃ¡lculos                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>5.2 O - Open/Closed Principle</h3>
<pre><code class="language-python"># âœ… Abierto para extensiÃ³n, cerrado para modificaciÃ³n

class Tokenizer(ABC):
    @abstractmethod
    def tokenize(self, text: str) -&gt; list[str]:
        pass

# Extender sin modificar la clase base
class SpanishTokenizer(Tokenizer):
    &quot;&quot;&quot;Tokenizer with Spanish stop words.&quot;&quot;&quot;

    STOP_WORDS = {&quot;el&quot;, &quot;la&quot;, &quot;los&quot;, &quot;las&quot;, &quot;de&quot;, &quot;en&quot;}

    def tokenize(self, text: str) -&gt; list[str]:
        words = text.lower().split()
        return [w for w in words if w not in self.STOP_WORDS]
</code></pre>
<h3>5.3 AplicaciÃ³n en el Proyecto</h3>
<pre><code class="language-python"># Cada clase tiene una responsabilidad clara:

class Document:
    &quot;&quot;&quot;Solo almacena datos de un documento.&quot;&quot;&quot;
    pass

class Corpus:
    &quot;&quot;&quot;Solo administra una colecciÃ³n de documentos.&quot;&quot;&quot;
    pass

class Tokenizer:
    &quot;&quot;&quot;Solo convierte texto en tokens.&quot;&quot;&quot;
    pass

class InvertedIndex:
    &quot;&quot;&quot;Solo indexa documentos para bÃºsqueda.&quot;&quot;&quot;
    pass

class SearchEngine:
    &quot;&quot;&quot;Orquesta los demÃ¡s componentes.&quot;&quot;&quot;
    pass
</code></pre>
<hr />
<h2>6. Dataclasses {#6-dataclasses}</h2>
<h3>6.1 Simplificando Clases de Datos</h3>
<pre><code class="language-python">from dataclasses import dataclass, field

# âŒ Mucho boilerplate
class DocumentOld:
    def __init__(self, doc_id: int, content: str, title: str = &quot;&quot;) -&gt; None:
        self.doc_id = doc_id
        self.content = content
        self.title = title

    def __repr__(self) -&gt; str:
        return f&quot;Document(doc_id={self.doc_id}, content='{self.content[:20]}...', title='{self.title}')&quot;

    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, DocumentOld):
            return NotImplemented
        return self.doc_id == other.doc_id and self.content == other.content

# âœ… Dataclass: automÃ¡tico
@dataclass
class Document:
    doc_id: int
    content: str
    title: str = &quot;&quot;
    tokens: list[str] = field(default_factory=list)

    # Puedes agregar mÃ©todos normalmente
    def tokenize(self) -&gt; list[str]:
        self.tokens = self.content.lower().split()
        return self.tokens
</code></pre>
<h3>6.2 Opciones de Dataclass</h3>
<pre><code class="language-python">@dataclass(frozen=True)  # Inmutable (no se puede modificar)
class ImmutableDocument:
    doc_id: int
    content: str

@dataclass(order=True)  # Permite comparar &lt;, &gt;, etc.
class RankedDocument:
    score: float  # Primer campo = criterio de ordenamiento
    doc_id: int
    content: str

# Uso
docs = [RankedDocument(0.8, 1, &quot;doc1&quot;), RankedDocument(0.9, 2, &quot;doc2&quot;)]
sorted_docs = sorted(docs, reverse=True)  # Ordenar por score
</code></pre>
<h3>6.3 CuÃ¡ndo Usar Dataclass</h3>
<table>
<thead>
<tr>
<th>Usa Dataclass cuando...</th>
<th>Usa Clase normal cuando...</th>
</tr>
</thead>
<tbody>
<tr>
<td>Principalmente almacena datos</td>
<td>LÃ³gica compleja de validaciÃ³n</td>
</tr>
<tr>
<td><strong>init</strong>, <strong>repr</strong>, <strong>eq</strong> estÃ¡ndar</td>
<td>Necesitas control total</td>
</tr>
<tr>
<td>Quieres cÃ³digo conciso</td>
<td>Properties con setters</td>
</tr>
</tbody>
</table>
<hr />
<h2>âš ï¸ Errores Comunes y CÃ³mo Evitarlos</h2>
<h3>Error 1: Olvidar self</h3>
<pre><code class="language-python"># âŒ Error: NameError: name 'doc_id' is not defined
class Document:
    def __init__(self, doc_id: int) -&gt; None:
        doc_id = doc_id  # Â¡No guarda nada!

# âœ… Correcto
class Document:
    def __init__(self, doc_id: int) -&gt; None:
        self.doc_id = doc_id
</code></pre>
<h3>Error 2: Mutar lista compartida</h3>
<pre><code class="language-python"># âŒ Bug: todos los documentos comparten la misma lista
class Document:
    tokens: list[str] = []  # Â¡Atributo de clase!

# âœ… Correcto: inicializar en __init__
class Document:
    def __init__(self) -&gt; None:
        self.tokens: list[str] = []  # Atributo de instancia
</code></pre>
<h3>Error 3: <strong>eq</strong> sin <strong>hash</strong></h3>
<pre><code class="language-python"># âŒ Si defines __eq__, Python elimina __hash__ por defecto
class Document:
    def __eq__(self, other): ...
    # No se puede usar en sets/dicts

# âœ… Definir ambos
class Document:
    def __eq__(self, other): ...
    def __hash__(self): return hash(self.doc_id)
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 2.1: Clase Document BÃ¡sica</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 2.2: MÃ©todos MÃ¡gicos</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 2.3: Properties con ValidaciÃ³n</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 2.4: Clase Corpus</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 2.5: Refactorizar a SOLID</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://realpython.com/python3-object-oriented-programming/">Real Python: OOP</a></td>
<td>Tutorial</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/dataclasses.html">Dataclasses Documentation</a></td>
<td>Docs</td>
<td>ğŸŸ¡ Recomendado</td>
</tr>
<tr>
<td><a href="https://realpython.com/solid-principles-python/">SOLID Principles</a></td>
<td>Tutorial</td>
<td>ğŸŸ¡ Recomendado</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ”— Referencias del Glosario</h2>
<ul>
<li><a href="#mod_GLOSARIO">Clase</a></li>
<li><a href="#mod_GLOSARIO">Instancia</a></li>
<li><a href="#mod_GLOSARIO">MÃ©todo MÃ¡gico</a></li>
<li><a href="#mod_GLOSARIO">Property</a></li>
<li><a href="#mod_GLOSARIO">ComposiciÃ³n</a></li>
<li><a href="#mod_GLOSARIO">SOLID</a></li>
</ul>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_01_PYTHON_PROFESIONAL">01_PYTHON_PROFESIONAL</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_03_LOGICA_DISCRETA">03_LOGICA_DISCRETA</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_03_LOGICA_DISCRETA" class="cover-page">
            <a name="mod_03_LOGICA_DISCRETA"></a>
            <div class="cover-title">03 - LÃ³gica y Big O</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>03 - LÃ³gica y MatemÃ¡ticas Discretas</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Dominar la teorÃ­a de conjuntos, lÃ³gica proposicional y la notaciÃ³n Big O para analizar algoritmos.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: El Lenguaje de las Computadoras</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   MATEMÃTICAS DISCRETAS = EL IDIOMA NATIVO DE LAS COMPUTADORAS              â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”‚
â”‚                                                                             â”‚
â”‚   Las computadoras no entienden &quot;mÃ¡s o menos&quot; ni &quot;aproximadamente&quot;          â”‚
â”‚   Solo entienden: SÃ/NO, 0/1, VERDADERO/FALSO                               â”‚
â”‚                                                                             â”‚
â”‚   CONJUNTOS â†’ Colecciones sin duplicados (sets en Python)                   â”‚
â”‚   LÃ“GICA    â†’ Condiciones y decisiones (if/and/or)                          â”‚
â”‚   BIG O     â†’ &quot;Â¿CuÃ¡nto tarda?&quot; sin medir con cronÃ³metro                     â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-conjuntos">TeorÃ­a de Conjuntos</a></li>
<li><a href="#2-operaciones">Operaciones de Conjuntos</a></li>
<li><a href="#3-logica">LÃ³gica Proposicional</a></li>
<li><a href="#4-big-o">IntroducciÃ³n a Big O</a></li>
<li><a href="#5-complejidad-python">Complejidad de Estructuras Python</a></li>
</ol>
<hr />
<h2>1. TeorÃ­a de Conjuntos {#1-conjuntos}</h2>
<h3>1.1 Â¿QuÃ© es un Conjunto?</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CONJUNTO = ColecciÃ³n de elementos ÃšNICOS sin orden             â”‚
â”‚                                                                 â”‚
â”‚  Lista:    [1, 2, 2, 3, 1]  â†’ Permite duplicados, tiene orden   â”‚
â”‚  Conjunto: {1, 2, 3}        â†’ Sin duplicados, sin orden         â”‚
â”‚                                                                 â”‚
â”‚  APLICACIÃ“N EN ARCHIMEDES:                                      â”‚
â”‚  â€¢ Stop words: {&quot;the&quot;, &quot;and&quot;, &quot;or&quot;, &quot;a&quot;, &quot;an&quot;}                  â”‚
â”‚  â€¢ Palabras Ãºnicas de un documento                              â”‚
â”‚  â€¢ Documentos que contienen una palabra                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>1.2 Sets en Python</h3>
<pre><code class="language-python"># Crear sets
stop_words: set[str] = {&quot;the&quot;, &quot;and&quot;, &quot;or&quot;, &quot;a&quot;, &quot;an&quot;, &quot;is&quot;, &quot;are&quot;}
empty_set: set[str] = set()  # No usar {} (eso es dict vacÃ­o)

# Crear set desde lista (elimina duplicados)
words = [&quot;hello&quot;, &quot;world&quot;, &quot;hello&quot;, &quot;python&quot;]
unique_words = set(words)  # {&quot;hello&quot;, &quot;world&quot;, &quot;python&quot;}

# Verificar pertenencia: O(1) promedio
if &quot;hello&quot; in unique_words:
    print(&quot;Found!&quot;)

# Agregar y eliminar
unique_words.add(&quot;new&quot;)
unique_words.remove(&quot;hello&quot;)  # KeyError si no existe
unique_words.discard(&quot;missing&quot;)  # No error si no existe
</code></pre>
<h3>1.3 frozenset: Conjuntos Inmutables</h3>
<pre><code class="language-python"># frozenset no se puede modificar
STOP_WORDS: frozenset[str] = frozenset({&quot;the&quot;, &quot;and&quot;, &quot;or&quot;, &quot;a&quot;, &quot;an&quot;})

# Ãštil como clave de diccionario o en otros sets
document_signatures: set[frozenset[str]] = set()
doc1_words = frozenset({&quot;hello&quot;, &quot;world&quot;})
document_signatures.add(doc1_words)  # OK con frozenset

# Con set normal no funciona:
# document_signatures.add({&quot;hello&quot;, &quot;world&quot;})  # TypeError: unhashable type: 'set'
</code></pre>
<hr />
<h2>2. Operaciones de Conjuntos {#2-operaciones}</h2>
<h3>2.1 Operaciones Fundamentales</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  A = {1, 2, 3}    B = {2, 3, 4}                                 â”‚
â”‚                                                                 â”‚
â”‚  UNIÃ“N (A âˆª B)         = {1, 2, 3, 4}   # Todos los elementos   â”‚
â”‚  INTERSECCIÃ“N (A âˆ© B)  = {2, 3}         # Elementos comunes     â”‚
â”‚  DIFERENCIA (A - B)    = {1}            # En A pero no en B     â”‚
â”‚  DIFERENCIA SIMÃ‰TRICA  = {1, 4}         # En uno pero no ambos  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>2.2 En Python</h3>
<pre><code class="language-python">A: set[int] = {1, 2, 3}
B: set[int] = {2, 3, 4}

# UniÃ³n
union = A | B                    # {1, 2, 3, 4}
union = A.union(B)               # Equivalente

# IntersecciÃ³n
intersection = A &amp; B             # {2, 3}
intersection = A.intersection(B) # Equivalente

# Diferencia
difference = A - B               # {1}
difference = A.difference(B)     # Equivalente

# Diferencia simÃ©trica
sym_diff = A ^ B                 # {1, 4}
sym_diff = A.symmetric_difference(B)
</code></pre>
<h3>2.3 AplicaciÃ³n: BÃºsqueda AND/OR</h3>
<pre><code class="language-python">def search_and(index: dict[str, set[int]], words: list[str]) -&gt; set[int]:
    &quot;&quot;&quot;Find documents containing ALL words (AND logic).

    Uses set intersection to find common documents.

    Example:
        &gt;&gt;&gt; index = {&quot;hello&quot;: {1, 2}, &quot;world&quot;: {2, 3}}
        &gt;&gt;&gt; search_and(index, [&quot;hello&quot;, &quot;world&quot;])
        {2}  # Only doc 2 contains both words
    &quot;&quot;&quot;
    if not words:
        return set()

    # Start with all docs containing first word
    result = index.get(words[0], set()).copy()

    # Intersect with docs containing each subsequent word
    for word in words[1:]:
        result &amp;= index.get(word, set())

    return result


def search_or(index: dict[str, set[int]], words: list[str]) -&gt; set[int]:
    &quot;&quot;&quot;Find documents containing ANY word (OR logic).

    Uses set union to combine all matching documents.

    Example:
        &gt;&gt;&gt; index = {&quot;hello&quot;: {1, 2}, &quot;world&quot;: {2, 3}}
        &gt;&gt;&gt; search_or(index, [&quot;hello&quot;, &quot;world&quot;])
        {1, 2, 3}  # Docs containing hello OR world
    &quot;&quot;&quot;
    result: set[int] = set()

    for word in words:
        result |= index.get(word, set())

    return result
</code></pre>
<h3>2.4 Subconjuntos y Superconjuntos</h3>
<pre><code class="language-python">A = {1, 2}
B = {1, 2, 3, 4}

A.issubset(B)    # True: A âŠ† B
B.issuperset(A)  # True: B âŠ‡ A
A &lt; B            # True: A es subconjunto propio (A âŠ‚ B)
A.isdisjoint({5, 6})  # True: sin elementos en comÃºn
</code></pre>
<hr />
<h2>3. LÃ³gica Proposicional {#3-logica}</h2>
<h3>3.1 Operadores LÃ³gicos</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  OPERADOR    SÃMBOLO    PYTHON    SIGNIFICADO                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”€â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                   â”‚
â”‚  AND         âˆ§          and       Ambos verdaderos              â”‚
â”‚  OR          âˆ¨          or        Al menos uno verdadero        â”‚
â”‚  NOT         Â¬          not       NegaciÃ³n                      â”‚
â”‚  IMPLICACIÃ“N â†’          if/then   Si A entonces B               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>3.2 Tablas de Verdad</h3>
<pre><code class="language-python"># AND: ambos deben ser True
#  A     B     A and B
# True  True   True
# True  False  False
# False True   False
# False False  False

# OR: al menos uno True
#  A     B     A or B
# True  True   True
# True  False  True
# False True   True
# False False  False

# NOT: invierte
#  A      not A
# True    False
# False   True
</code></pre>
<h3>3.3 Expresiones Complejas en Python</h3>
<pre><code class="language-python">def is_valid_document(doc: Document) -&gt; bool:
    &quot;&quot;&quot;Check if document meets all validation criteria.&quot;&quot;&quot;
    has_content = len(doc.content) &gt; 0
    has_valid_id = doc.doc_id &gt;= 0
    is_not_too_long = len(doc.content) &lt; 1_000_000

    # AND: todas las condiciones
    return has_content and has_valid_id and is_not_too_long


def should_index_word(word: str, stop_words: set[str]) -&gt; bool:
    &quot;&quot;&quot;Determine if word should be indexed.

    Index if:
    - Word is not a stop word, AND
    - Word has at least 2 characters, AND
    - Word is alphanumeric
    &quot;&quot;&quot;
    is_not_stopword = word not in stop_words
    is_long_enough = len(word) &gt;= 2
    is_alphanumeric = word.isalnum()

    return is_not_stopword and is_long_enough and is_alphanumeric
</code></pre>
<h3>3.4 Leyes de De Morgan</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LEY DE DE MORGAN                                               â”‚
â”‚                                                                 â”‚
â”‚  not (A and B) = (not A) or (not B)                             â”‚
â”‚  not (A or B)  = (not A) and (not B)                            â”‚
â”‚                                                                 â”‚
â”‚  ÃšTIL PARA SIMPLIFICAR CONDICIONES                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<pre><code class="language-python"># Ejemplo: &quot;no indexar si es stop word O es muy corta&quot;
# VersiÃ³n original
if not (word in stop_words or len(word) &lt; 2):
    index_word(word)

# Aplicando De Morgan: equivalente
if word not in stop_words and len(word) &gt;= 2:
    index_word(word)
</code></pre>
<hr />
<h2>4. IntroducciÃ³n a Big O {#4-big-o}</h2>
<h3>4.1 Â¿QuÃ© es Big O?</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BIG O = CÃ³mo crece el tiempo cuando crece la entrada           â”‚
â”‚                                                                 â”‚
â”‚  NO mide segundos exactos                                       â”‚
â”‚  SÃ mide: &quot;Â¿CuÃ¡nto peor se pone con mÃ¡s datos?&quot;                 â”‚
â”‚                                                                 â”‚
â”‚  AnalogÃ­a: Enviar un paquete                                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                     â”‚
â”‚  â€¢ O(1): Email (instantÃ¡neo, sin importar tamaÃ±o)               â”‚
â”‚  â€¢ O(n): Caminar (tiempo proporcional a distancia)              â”‚
â”‚  â€¢ O(nÂ²): Revisar todas las combinaciones de n personas         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>4.2 Complejidades Comunes</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  COMPLEJIDAD    NOMBRE          EJEMPLO                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€                         â”‚
â”‚  O(1)           Constante       Acceso a dict por clave         â”‚
â”‚  O(log n)       LogarÃ­tmica     Binary search                   â”‚
â”‚  O(n)           Lineal          Recorrer una lista              â”‚
â”‚  O(n log n)     LinearÃ­tmica    QuickSort, MergeSort            â”‚
â”‚  O(nÂ²)          CuadrÃ¡tica      Dos loops anidados              â”‚
â”‚  O(2^n)         Exponencial     Subconjuntos de n elementos     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>4.3 VisualizaciÃ³n del Crecimiento</h3>
<pre><code>Tiempo â–²
       â”‚                                          O(nÂ²)
       â”‚                                      â—
       â”‚                                  â—
       â”‚                              â—
       â”‚                          â—                    O(n)
       â”‚                      â—               â—â”€â”€â”€â”€â”€â”€â”€â”€â—
       â”‚                  â—           â—â”€â”€â”€â”€â”€â”€â”€
       â”‚              â—       â—â”€â”€â”€â”€â”€â”€â”€        O(log n)
       â”‚          â—   â—â”€â”€â”€â”€â”€â”€â”€        â—â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â—
       â”‚      â—â”€â”€â”€                    
       â”‚  â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  O(1)
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º n (elementos)
            10   20   30   40   50   60   70   80
</code></pre>
<h3>4.4 CÃ³mo Determinar Big O</h3>
<pre><code class="language-python"># O(1) - Constante: no depende del tamaÃ±o de entrada
def get_first(items: list) -&gt; any:
    return items[0]

# O(n) - Lineal: un loop sobre n elementos
def find_max(items: list[int]) -&gt; int:
    max_val = items[0]
    for item in items:  # n iteraciones
        if item &gt; max_val:
            max_val = item
    return max_val

# O(nÂ²) - CuadrÃ¡tica: loops anidados
def has_duplicate(items: list) -&gt; bool:
    for i in range(len(items)):      # n
        for j in range(len(items)):  # Ã— n
            if i != j and items[i] == items[j]:
                return True
    return False

# O(n) - Mejor versiÃ³n con set
def has_duplicate_fast(items: list) -&gt; bool:
    seen: set = set()
    for item in items:  # n iteraciones
        if item in seen:  # O(1) lookup
            return True
        seen.add(item)
    return False
</code></pre>
<h3>4.5 Reglas para Calcular Big O</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  REGLA 1: Ignorar constantes                                    â”‚
â”‚  O(2n) â†’ O(n)                                                   â”‚
â”‚  O(n + 100) â†’ O(n)                                              â”‚
â”‚                                                                 â”‚
â”‚  REGLA 2: Tomar el tÃ©rmino dominante                            â”‚
â”‚  O(nÂ² + n) â†’ O(nÂ²)                                              â”‚
â”‚  O(nÂ³ + nÂ² + n) â†’ O(nÂ³)                                         â”‚
â”‚                                                                 â”‚
â”‚  REGLA 3: Operaciones en secuencia se suman                     â”‚
â”‚  f() de O(n) + g() de O(nÂ²) â†’ O(n + nÂ²) â†’ O(nÂ²)                 â”‚
â”‚                                                                 â”‚
â”‚  REGLA 4: Loops anidados se multiplican                         â”‚
â”‚  for i in range(n):  # O(n)                                     â”‚
â”‚      for j in range(m):  # O(m)                                 â”‚
â”‚          ...             # â†’ O(n Ã— m)                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>5. Complejidad de Estructuras Python {#5-complejidad-python}</h2>
<h3>5.1 Tabla de Complejidades</h3>
<table>
<thead>
<tr>
<th>OperaciÃ³n</th>
<th>list</th>
<th>dict</th>
<th>set</th>
</tr>
</thead>
<tbody>
<tr>
<td>Acceso por Ã­ndice</td>
<td>O(1)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Buscar elemento</td>
<td>O(n)</td>
<td>O(1)*</td>
<td>O(1)*</td>
</tr>
<tr>
<td>Insertar al final</td>
<td>O(1)*</td>
<td>O(1)*</td>
<td>O(1)*</td>
</tr>
<tr>
<td>Insertar al inicio</td>
<td>O(n)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Eliminar por valor</td>
<td>O(n)</td>
<td>O(1)*</td>
<td>O(1)*</td>
</tr>
<tr>
<td>Iterar todo</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<p>*Amortizado: en promedio, aunque casos raros pueden ser peores.</p>
<h3>5.2 Por QuÃ© Esto Importa</h3>
<pre><code class="language-python"># âŒ O(n) por cada bÃºsqueda â†’ O(n Ã— m) total
def remove_stopwords_slow(tokens: list[str], stopwords: list[str]) -&gt; list[str]:
    &quot;&quot;&quot;Slow: O(n Ã— m) where n=tokens, m=stopwords.&quot;&quot;&quot;
    return [t for t in tokens if t not in stopwords]  # 'in' es O(m) en lista

# âœ… O(1) por cada bÃºsqueda â†’ O(n) total
def remove_stopwords_fast(tokens: list[str], stopwords: set[str]) -&gt; list[str]:
    &quot;&quot;&quot;Fast: O(n) where n=tokens.&quot;&quot;&quot;
    return [t for t in tokens if t not in stopwords]  # 'in' es O(1) en set
</code></pre>
<h3>5.3 Benchmark Real</h3>
<pre><code class="language-python">import time

# Crear datos de prueba
tokens = [&quot;word&quot; + str(i) for i in range(10000)]
stopwords_list = [&quot;word&quot; + str(i) for i in range(1000)]
stopwords_set = set(stopwords_list)

# Benchmark lista
start = time.time()
result = [t for t in tokens if t not in stopwords_list]
list_time = time.time() - start

# Benchmark set
start = time.time()
result = [t for t in tokens if t not in stopwords_set]
set_time = time.time() - start

print(f&quot;List: {list_time:.4f}s&quot;)  # ~0.5s
print(f&quot;Set:  {set_time:.4f}s&quot;)   # ~0.001s
print(f&quot;Set is {list_time/set_time:.0f}x faster&quot;)  # ~500x
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes</h2>
<h3>Error 1: Usar lista cuando set es mejor</h3>
<pre><code class="language-python"># âŒ Lento para bÃºsquedas frecuentes
stop_words = [&quot;the&quot;, &quot;and&quot;, &quot;or&quot;]
if word in stop_words:  # O(n) cada vez
    pass

# âœ… RÃ¡pido
stop_words = {&quot;the&quot;, &quot;and&quot;, &quot;or&quot;}
if word in stop_words:  # O(1) cada vez
    pass
</code></pre>
<h3>Error 2: No considerar el tamaÃ±o de entrada</h3>
<pre><code class="language-python"># Parece simple, pero es O(nÂ²)
def get_duplicates(items: list) -&gt; list:
    duplicates = []
    for item in items:
        if items.count(item) &gt; 1:  # count() es O(n)
            duplicates.append(item)
    return list(set(duplicates))

# Mejor: O(n)
from collections import Counter
def get_duplicates_fast(items: list) -&gt; list:
    counts = Counter(items)  # O(n)
    return [item for item, count in counts.items() if count &gt; 1]
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 3.1: Stop Words como Set</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 3.2: Operaciones de Conjuntos</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 3.3: Analizar Complejidad</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.bigocheatsheet.com/">Big O Cheat Sheet</a></td>
<td>Referencia</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://wiki.python.org/moin/TimeComplexity">Python Time Complexity</a></td>
<td>DocumentaciÃ³n</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://www.manning.com/books/grokking-algorithms">Grokking Algorithms Ch.1</a></td>
<td>Libro</td>
<td>ğŸŸ¡ Recomendado</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ”— Referencias del Glosario</h2>
<ul>
<li><a href="#mod_GLOSARIO">Conjunto (Set)</a></li>
<li><a href="#mod_GLOSARIO">Big O Notation</a></li>
<li><a href="#mod_GLOSARIO">Complejidad Temporal</a></li>
<li><a href="#mod_GLOSARIO">Hash Table</a></li>
</ul>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_02_OOP_DESDE_CERO">02_OOP_DESDE_CERO</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_04_ARRAYS_STRINGS">04_ARRAYS_STRINGS</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_04_ARRAYS_STRINGS" class="cover-page">
            <a name="mod_04_ARRAYS_STRINGS"></a>
            <div class="cover-title">04 - Arrays y Strings</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>04 - Arrays, Strings y Memoria</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Dominar la manipulaciÃ³n de listas y strings en Python, entendiendo su complejidad y construyendo un tokenizador bÃ¡sico.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: El Estante de Libros</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   LISTA = ESTANTE DE LIBROS NUMERADO                                        â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                        â”‚
â”‚                                                                             â”‚
â”‚   PosiciÃ³n:  [0]     [1]     [2]     [3]     [4]                            â”‚
â”‚              â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”                          â”‚
â”‚              â”‚ A â”‚   â”‚ B â”‚   â”‚ C â”‚   â”‚ D â”‚   â”‚ E â”‚                          â”‚
â”‚              â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜                          â”‚
â”‚                                                                             â”‚
â”‚   â€¢ Acceder a [2] â†’ Inmediato (O(1)): &quot;Voy al estante 2&quot;                    â”‚
â”‚   â€¢ Insertar al final â†’ RÃ¡pido: solo aÃ±adir al final                        â”‚
â”‚   â€¢ Insertar al inicio â†’ Lento: mover todos los demÃ¡s                       â”‚
â”‚                                                                             â”‚
â”‚   STRING = COLLAR DE CUENTAS (no puedes cambiar una cuenta)                 â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                 â”‚
â”‚   &quot;HELLO&quot; â†’ Si quieres cambiar 'E' por 'A', debes hacer nuevo collar        â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-listas">Listas en Python: Bajo Nivel</a></li>
<li><a href="#2-slicing">Slicing y Copias</a></li>
<li><a href="#3-complejidad">Complejidad de Operaciones</a></li>
<li><a href="#4-strings">Strings: Inmutabilidad</a></li>
<li><a href="#5-tokenizacion">TokenizaciÃ³n: Tu Primer Componente</a></li>
</ol>
<hr />
<h2>1. Listas en Python: Bajo Nivel {#1-listas}</h2>
<h3>1.1 CÃ³mo Funciona una Lista</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  INTERNAMENTE: Array dinÃ¡mico                                   â”‚
â”‚                                                                 â”‚
â”‚  Memoria:   [ptr0][ptr1][ptr2][ptr3][____][____]                â”‚
â”‚              â†“     â†“     â†“     â†“                                â”‚
â”‚            &quot;hi&quot; &quot;world&quot;  42   3.14                              â”‚
â”‚                                                                 â”‚
â”‚  La lista guarda PUNTEROS a los objetos, no los objetos         â”‚
â”‚  Tiene espacio extra para crecer sin reasignar                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>1.2 CreaciÃ³n y Acceso</h3>
<pre><code class="language-python"># Crear listas
words: list[str] = [&quot;hello&quot;, &quot;world&quot;, &quot;python&quot;]
numbers: list[int] = [1, 2, 3, 4, 5]
mixed: list = [1, &quot;two&quot;, 3.0, None]  # Evitar en cÃ³digo tipado

# Acceso por Ã­ndice: O(1)
first = words[0]      # &quot;hello&quot;
last = words[-1]      # &quot;python&quot; (desde el final)

# Longitud: O(1) (Python guarda el tamaÃ±o)
length = len(words)   # 3

# ModificaciÃ³n: O(1)
words[0] = &quot;hi&quot;       # [&quot;hi&quot;, &quot;world&quot;, &quot;python&quot;]
</code></pre>
<h3>1.3 Agregar y Eliminar</h3>
<pre><code class="language-python">words = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

# Agregar al final: O(1) amortizado
words.append(&quot;d&quot;)     # [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]

# Agregar al inicio: O(n) - Â¡LENTO!
words.insert(0, &quot;z&quot;)  # [&quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
# Todos los elementos deben moverse

# Extender con otra lista: O(k) donde k = len(otra_lista)
words.extend([&quot;e&quot;, &quot;f&quot;])  # [&quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]

# Eliminar del final: O(1)
last = words.pop()    # Retorna &quot;f&quot;, words = [&quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]

# Eliminar del inicio: O(n) - Â¡LENTO!
first = words.pop(0)  # Retorna &quot;z&quot;, todos deben moverse

# Eliminar por valor: O(n) - busca y luego mueve
words.remove(&quot;c&quot;)     # Busca &quot;c&quot; y lo elimina
</code></pre>
<hr />
<h2>2. Slicing y Copias {#2-slicing}</h2>
<h3>2.1 Slicing BÃ¡sico</h3>
<pre><code class="language-python">nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Sintaxis: list[start:stop:step]
nums[2:5]      # [2, 3, 4]      - desde Ã­ndice 2 hasta 5 (no incluido)
nums[:3]       # [0, 1, 2]      - desde inicio hasta 3
nums[7:]       # [7, 8, 9]      - desde 7 hasta el final
nums[::2]      # [0, 2, 4, 6, 8] - cada 2 elementos
nums[::-1]     # [9, 8, ..., 0]  - reverso

# Ãndices negativos
nums[-3:]      # [7, 8, 9]      - Ãºltimos 3
nums[:-2]      # [0, 1, ..., 7] - todos menos Ãºltimos 2
</code></pre>
<h3>2.2 Copia Superficial vs Profunda</h3>
<pre><code class="language-python"># âš ï¸ ASIGNACIÃ“N: NO ES COPIA, es alias
original = [1, 2, 3]
alias = original
alias[0] = 99
print(original)  # [99, 2, 3] Â¡Original modificado!

# âœ… COPIA SUPERFICIAL: nueva lista, mismos objetos internos
original = [1, 2, 3]
copy1 = original[:]       # Slicing
copy2 = original.copy()   # MÃ©todo copy
copy3 = list(original)    # Constructor

copy1[0] = 99
print(original)  # [1, 2, 3] Â¡Original intacto!

# âš ï¸ Con objetos anidados, copia superficial NO es suficiente
nested = [[1, 2], [3, 4]]
shallow = nested.copy()
shallow[0][0] = 99        # Modifica el objeto interno
print(nested)             # [[99, 2], [3, 4]] Â¡Modificado!

# âœ… COPIA PROFUNDA: copia todo recursivamente
import copy
nested = [[1, 2], [3, 4]]
deep = copy.deepcopy(nested)
deep[0][0] = 99
print(nested)             # [[1, 2], [3, 4]] Â¡Intacto!
</code></pre>
<h3>2.3 CuÃ¡ndo Importa</h3>
<pre><code class="language-python"># âŒ Bug comÃºn: modificar lista mientras se itera
def remove_short_words_bad(words: list[str]) -&gt; list[str]:
    for word in words:  # Itera sobre la misma lista
        if len(word) &lt; 3:
            words.remove(word)  # Â¡Modifica durante iteraciÃ³n!
    return words

# âœ… SoluciÃ³n 1: crear nueva lista
def remove_short_words_good(words: list[str]) -&gt; list[str]:
    return [w for w in words if len(w) &gt;= 3]

# âœ… SoluciÃ³n 2: iterar sobre copia
def remove_short_words_alt(words: list[str]) -&gt; list[str]:
    for word in words[:]:  # Copia con [:]
        if len(word) &lt; 3:
            words.remove(word)
    return words
</code></pre>
<hr />
<h2>3. Complejidad de Operaciones {#3-complejidad}</h2>
<h3>3.1 Tabla Completa</h3>
<table>
<thead>
<tr>
<th>OperaciÃ³n</th>
<th>Complejidad</th>
<th>Ejemplo</th>
</tr>
</thead>
<tbody>
<tr>
<td>Acceso <code>list[i]</code></td>
<td>O(1)</td>
<td><code>words[5]</code></td>
</tr>
<tr>
<td>Asignar <code>list[i] = x</code></td>
<td>O(1)</td>
<td><code>words[5] = "new"</code></td>
</tr>
<tr>
<td><code>len(list)</code></td>
<td>O(1)</td>
<td><code>len(words)</code></td>
</tr>
<tr>
<td><code>list.append(x)</code></td>
<td>O(1)*</td>
<td><code>words.append("x")</code></td>
</tr>
<tr>
<td><code>list.pop()</code></td>
<td>O(1)</td>
<td><code>words.pop()</code></td>
</tr>
<tr>
<td><code>list.insert(0, x)</code></td>
<td>O(n)</td>
<td><code>words.insert(0, "x")</code></td>
</tr>
<tr>
<td><code>list.pop(0)</code></td>
<td>O(n)</td>
<td><code>words.pop(0)</code></td>
</tr>
<tr>
<td><code>x in list</code></td>
<td>O(n)</td>
<td><code>"hello" in words</code></td>
</tr>
<tr>
<td><code>list.index(x)</code></td>
<td>O(n)</td>
<td><code>words.index("hello")</code></td>
</tr>
<tr>
<td><code>list.count(x)</code></td>
<td>O(n)</td>
<td><code>words.count("the")</code></td>
</tr>
<tr>
<td><code>list.remove(x)</code></td>
<td>O(n)</td>
<td><code>words.remove("hello")</code></td>
</tr>
<tr>
<td><code>list.sort()</code></td>
<td>O(n log n)</td>
<td><code>words.sort()</code></td>
</tr>
<tr>
<td>Slice <code>list[a:b]</code></td>
<td>O(b-a)</td>
<td><code>words[5:10]</code></td>
</tr>
<tr>
<td><code>list.extend(k)</code></td>
<td>O(k)</td>
<td><code>words.extend(["a","b"])</code></td>
</tr>
</tbody>
</table>
<p>*Amortizado: ocasionalmente O(n) cuando se reasigna memoria.</p>
<h3>3.2 Implicaciones PrÃ¡cticas</h3>
<pre><code class="language-python"># âŒ Ineficiente: insertar al inicio muchas veces â†’ O(nÂ²) total
def build_reversed_bad(items: list[str]) -&gt; list[str]:
    result = []
    for item in items:
        result.insert(0, item)  # O(n) cada vez
    return result

# âœ… Eficiente: append y luego revertir â†’ O(n) total
def build_reversed_good(items: list[str]) -&gt; list[str]:
    result = []
    for item in items:
        result.append(item)  # O(1) cada vez
    result.reverse()  # O(n) una vez
    return result

# âœ… MÃ¡s pythonic
def build_reversed_best(items: list[str]) -&gt; list[str]:
    return items[::-1]
</code></pre>
<hr />
<h2>4. Strings: Inmutabilidad {#4-strings}</h2>
<h3>4.1 Strings Son Inmutables</h3>
<pre><code class="language-python">text = &quot;Hello&quot;

# âŒ No puedes modificar un carÃ¡cter
text[0] = &quot;J&quot;  # TypeError: 'str' object does not support item assignment

# âœ… Debes crear un nuevo string
text = &quot;J&quot; + text[1:]  # &quot;Jello&quot;

# Cada operaciÃ³n crea un NUEVO string
text = &quot;Hello&quot;
text = text + &quot; World&quot;  # Nuevo objeto, no modificaciÃ³n
text = text.lower()     # Nuevo objeto
text = text.strip()     # Nuevo objeto
</code></pre>
<h3>4.2 ConcatenaciÃ³n Eficiente</h3>
<pre><code class="language-python"># âŒ Ineficiente: muchas concatenaciones â†’ O(nÂ²)
def build_string_bad(words: list[str]) -&gt; str:
    result = &quot;&quot;
    for word in words:
        result = result + word + &quot; &quot;  # Crea nuevo string cada vez
    return result.strip()

# âœ… Eficiente: join â†’ O(n)
def build_string_good(words: list[str]) -&gt; str:
    return &quot; &quot;.join(words)

# Benchmark con 10,000 palabras:
# build_string_bad:  ~0.1s
# build_string_good: ~0.001s (100x mÃ¡s rÃ¡pido)
</code></pre>
<h3>4.3 MÃ©todos de String Ãštiles</h3>
<pre><code class="language-python">text = &quot;  Hello, World! How are you?  &quot;

# Limpieza
text.strip()      # &quot;Hello, World! How are you?&quot;
text.lower()      # &quot;  hello, world! how are you?  &quot;
text.upper()      # &quot;  HELLO, WORLD! HOW ARE YOU?  &quot;

# BÃºsqueda
text.find(&quot;World&quot;)     # 9 (Ã­ndice) o -1 si no existe
text.count(&quot;o&quot;)        # 3
&quot;Hello&quot; in text        # True
text.startswith(&quot;  H&quot;) # True
text.endswith(&quot;?  &quot;)   # True

# DivisiÃ³n
text.split()           # [&quot;Hello,&quot;, &quot;World!&quot;, &quot;How&quot;, &quot;are&quot;, &quot;you?&quot;]
text.split(&quot;,&quot;)        # [&quot;  Hello&quot;, &quot; World! How are you?  &quot;]

# Reemplazo
text.replace(&quot;!&quot;, &quot;&quot;)  # Sin signos de exclamaciÃ³n
text.replace(&quot; &quot;, &quot;_&quot;) # Espacios por guiones bajos

# VerificaciÃ³n
&quot;hello&quot;.isalpha()      # True (solo letras)
&quot;hello123&quot;.isalnum()   # True (letras y nÃºmeros)
&quot;123&quot;.isdigit()        # True (solo dÃ­gitos)
&quot;   &quot;.isspace()        # True (solo espacios)
</code></pre>
<hr />
<h2>5. TokenizaciÃ³n: Tu Primer Componente {#5-tokenizacion}</h2>
<h3>5.1 Â¿QuÃ© es TokenizaciÃ³n?</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TOKENIZACIÃ“N = Convertir texto en unidades procesables         â”‚
â”‚                                                                 â”‚
â”‚  Entrada:  &quot;Hello, World! How are you?&quot;                         â”‚
â”‚  Salida:   [&quot;hello&quot;, &quot;world&quot;, &quot;how&quot;, &quot;are&quot;, &quot;you&quot;]              â”‚
â”‚                                                                 â”‚
â”‚  Pasos tÃ­picos:                                                 â”‚
â”‚  1. Convertir a minÃºsculas                                      â”‚
â”‚  2. Eliminar puntuaciÃ³n                                         â”‚
â”‚  3. Dividir por espacios                                        â”‚
â”‚  4. Filtrar palabras vacÃ­as (stop words)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>5.2 Tokenizador BÃ¡sico</h3>
<pre><code class="language-python">def tokenize_basic(text: str) -&gt; list[str]:
    &quot;&quot;&quot;Split text into lowercase words.

    Args:
        text: Input text to tokenize.

    Returns:
        List of lowercase tokens.

    Example:
        &gt;&gt;&gt; tokenize_basic(&quot;Hello, World!&quot;)
        ['hello,', 'world!']
    &quot;&quot;&quot;
    return text.lower().split()
</code></pre>
<h3>5.3 Tokenizador con Limpieza de PuntuaciÃ³n</h3>
<pre><code class="language-python">def remove_punctuation(text: str) -&gt; str:
    &quot;&quot;&quot;Remove all punctuation from text.

    Uses character-by-character filtering.

    Args:
        text: Text potentially containing punctuation.

    Returns:
        Text with punctuation replaced by spaces.
    &quot;&quot;&quot;
    result = []
    for char in text:
        if char.isalnum() or char.isspace():
            result.append(char)
        else:
            result.append(' ')  # Reemplazar puntuaciÃ³n por espacio
    return ''.join(result)


def tokenize_clean(text: str) -&gt; list[str]:
    &quot;&quot;&quot;Tokenize text with punctuation removal.

    Args:
        text: Input text.

    Returns:
        List of clean, lowercase tokens.

    Example:
        &gt;&gt;&gt; tokenize_clean(&quot;Hello, World! How are you?&quot;)
        ['hello', 'world', 'how', 'are', 'you']
    &quot;&quot;&quot;
    cleaned = remove_punctuation(text)
    return cleaned.lower().split()
</code></pre>
<h3>5.4 Tokenizador con Stop Words</h3>
<pre><code class="language-python"># Stop words comunes en inglÃ©s
STOP_WORDS: frozenset[str] = frozenset({
    &quot;a&quot;, &quot;an&quot;, &quot;the&quot;, &quot;and&quot;, &quot;or&quot;, &quot;but&quot;, &quot;is&quot;, &quot;are&quot;, &quot;was&quot;, &quot;were&quot;,
    &quot;be&quot;, &quot;been&quot;, &quot;being&quot;, &quot;have&quot;, &quot;has&quot;, &quot;had&quot;, &quot;do&quot;, &quot;does&quot;, &quot;did&quot;,
    &quot;will&quot;, &quot;would&quot;, &quot;could&quot;, &quot;should&quot;, &quot;may&quot;, &quot;might&quot;, &quot;must&quot;,
    &quot;i&quot;, &quot;you&quot;, &quot;he&quot;, &quot;she&quot;, &quot;it&quot;, &quot;we&quot;, &quot;they&quot;, &quot;me&quot;, &quot;him&quot;, &quot;her&quot;,
    &quot;us&quot;, &quot;them&quot;, &quot;my&quot;, &quot;your&quot;, &quot;his&quot;, &quot;its&quot;, &quot;our&quot;, &quot;their&quot;,
    &quot;this&quot;, &quot;that&quot;, &quot;these&quot;, &quot;those&quot;, &quot;what&quot;, &quot;which&quot;, &quot;who&quot;, &quot;whom&quot;,
    &quot;in&quot;, &quot;on&quot;, &quot;at&quot;, &quot;by&quot;, &quot;for&quot;, &quot;with&quot;, &quot;about&quot;, &quot;to&quot;, &quot;from&quot;,
    &quot;of&quot;, &quot;as&quot;, &quot;if&quot;, &quot;then&quot;, &quot;than&quot;, &quot;so&quot;, &quot;no&quot;, &quot;not&quot;, &quot;only&quot;
})


def tokenize(
    text: str,
    remove_stopwords: bool = True,
    min_length: int = 2
) -&gt; list[str]:
    &quot;&quot;&quot;Full tokenization pipeline.

    Args:
        text: Input text to tokenize.
        remove_stopwords: Whether to filter out stop words.
        min_length: Minimum token length to keep.

    Returns:
        List of processed tokens.

    Example:
        &gt;&gt;&gt; tokenize(&quot;The quick brown fox jumps over the lazy dog.&quot;)
        ['quick', 'brown', 'fox', 'jumps', 'over', 'lazy', 'dog']
    &quot;&quot;&quot;
    # 1. Remove punctuation
    cleaned = remove_punctuation(text)

    # 2. Lowercase and split
    tokens = cleaned.lower().split()

    # 3. Filter by length
    tokens = [t for t in tokens if len(t) &gt;= min_length]

    # 4. Remove stop words
    if remove_stopwords:
        tokens = [t for t in tokens if t not in STOP_WORDS]

    return tokens
</code></pre>
<h3>5.5 Clase Tokenizer (Aplicando OOP)</h3>
<pre><code class="language-python">class Tokenizer:
    &quot;&quot;&quot;Configurable text tokenizer.

    Attributes:
        stop_words: Set of words to filter out.
        min_length: Minimum token length.

    Example:
        &gt;&gt;&gt; tokenizer = Tokenizer()
        &gt;&gt;&gt; tokenizer.tokenize(&quot;Hello, World!&quot;)
        ['hello', 'world']
    &quot;&quot;&quot;

    DEFAULT_STOP_WORDS: frozenset[str] = STOP_WORDS

    def __init__(
        self,
        stop_words: set[str] | None = None,
        min_length: int = 2
    ) -&gt; None:
        &quot;&quot;&quot;Initialize tokenizer with configuration.

        Args:
            stop_words: Custom stop words (None uses defaults).
            min_length: Minimum token length to keep.
        &quot;&quot;&quot;
        self.stop_words: frozenset[str] = (
            frozenset(stop_words) if stop_words is not None
            else self.DEFAULT_STOP_WORDS
        )
        self.min_length: int = min_length

    def _remove_punctuation(self, text: str) -&gt; str:
        &quot;&quot;&quot;Remove punctuation from text.&quot;&quot;&quot;
        return ''.join(
            c if c.isalnum() or c.isspace() else ' '
            for c in text
        )

    def tokenize(self, text: str) -&gt; list[str]:
        &quot;&quot;&quot;Tokenize text into clean tokens.

        Args:
            text: Input text.

        Returns:
            List of processed tokens.
        &quot;&quot;&quot;
        cleaned = self._remove_punctuation(text)
        tokens = cleaned.lower().split()

        return [
            token for token in tokens
            if len(token) &gt;= self.min_length
            and token not in self.stop_words
        ]

    def __repr__(self) -&gt; str:
        return (
            f&quot;Tokenizer(stop_words={len(self.stop_words)} words, &quot;
            f&quot;min_length={self.min_length})&quot;
        )
</code></pre>
<h3>5.6 AnÃ¡lisis de Complejidad</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  COMPLEJIDAD DE tokenize(text)                                  â”‚
â”‚                                                                 â”‚
â”‚  Sea n = len(text), m = nÃºmero de tokens                        â”‚
â”‚                                                                 â”‚
â”‚  1. remove_punctuation: O(n) - recorre cada carÃ¡cter            â”‚
â”‚  2. lower(): O(n) - recorre cada carÃ¡cter                       â”‚
â”‚  3. split(): O(n) - recorre buscando espacios                   â”‚
â”‚  4. Filtrar por longitud: O(m) - recorre tokens                 â”‚
â”‚  5. Filtrar stop words: O(m) - lookup O(1) por token            â”‚
â”‚                                                                 â”‚
â”‚  TOTAL: O(n + m) â‰ˆ O(n) ya que m â‰¤ n                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes</h2>
<h3>Error 1: Modificar lista durante iteraciÃ³n</h3>
<pre><code class="language-python"># âŒ Bug: resultado impredecible
words = [&quot;a&quot;, &quot;the&quot;, &quot;b&quot;, &quot;an&quot;, &quot;c&quot;]
for word in words:
    if word in {&quot;the&quot;, &quot;an&quot;}:
        words.remove(word)
# Resultado: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] pero puede fallar

# âœ… Correcto: list comprehension
words = [w for w in words if w not in {&quot;the&quot;, &quot;an&quot;}]
</code></pre>
<h3>Error 2: Concatenar strings en loop</h3>
<pre><code class="language-python"># âŒ O(nÂ²) - crea nuevo string cada vez
result = &quot;&quot;
for word in words:
    result += word + &quot; &quot;

# âœ… O(n) - usa join
result = &quot; &quot;.join(words)
</code></pre>
<h3>Error 3: Olvidar que strings son inmutables</h3>
<pre><code class="language-python"># âŒ No hace nada
text = &quot;hello&quot;
text.upper()  # Retorna nuevo string, no modifica
print(text)   # &quot;hello&quot; (sin cambios)

# âœ… Asignar resultado
text = text.upper()
print(text)   # &quot;HELLO&quot;
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 4.1: ManipulaciÃ³n de Listas</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 4.2: Tokenizador BÃ¡sico</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 4.3: AnÃ¡lisis de Complejidad</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.python.org/3/tutorial/datastructures.html">Python Lists</a></td>
<td>Docs</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/stdtypes.html#string-methods">String Methods</a></td>
<td>Docs</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://wiki.python.org/moin/TimeComplexity">Time Complexity</a></td>
<td>Wiki</td>
<td>ğŸŸ¡ Recomendado</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ”— Referencias del Glosario</h2>
<ul>
<li><a href="#mod_GLOSARIO">Array</a></li>
<li><a href="#mod_GLOSARIO">String</a></li>
<li><a href="#mod_GLOSARIO">Inmutabilidad</a></li>
<li><a href="#mod_GLOSARIO">TokenizaciÃ³n</a></li>
</ul>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_03_LOGICA_DISCRETA">03_LOGICA_DISCRETA</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_05_HASHMAPS_SETS">05_HASHMAPS_SETS</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_05_HASHMAPS_SETS" class="cover-page">
            <a name="mod_05_HASHMAPS_SETS"></a>
            <div class="cover-title">05 - Hash Maps y Sets</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>05 - Hash Maps y Sets</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Dominar diccionarios y sets en Python, entendiendo por quÃ© son O(1) para bÃºsquedas y cÃ³mo usarlos eficientemente.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: El Ãndice de un Libro vs Leer PÃ¡gina por PÃ¡gina</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   LISTA = LIBRO SIN ÃNDICE                                                  â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                  â”‚
â”‚   Para encontrar &quot;recursiÃ³n&quot; debes leer pÃ¡gina por pÃ¡gina â†’ O(n)            â”‚
â”‚                                                                             â”‚
â”‚   DICCIONARIO = LIBRO CON ÃNDICE ALFABÃ‰TICO                                 â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                â”‚
â”‚   Buscas &quot;recursiÃ³n&quot; en el Ã­ndice â†’ pÃ¡gina 142 â†’ directo â†’ O(1)             â”‚
â”‚                                                                             â”‚
â”‚   Â¿CÃ“MO FUNCIONA EL &quot;ÃNDICE&quot;?                                               â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                              â”‚
â”‚   HASH FUNCTION: Convierte &quot;recursiÃ³n&quot; â†’ nÃºmero â†’ posiciÃ³n en memoria       â”‚
â”‚   &quot;recursiÃ³n&quot; â†’ hash() â†’ 7293847 â†’ slot 47 en el array interno              â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-como-funciona">CÃ³mo Funciona un Hash Map</a></li>
<li><a href="#2-diccionarios">Diccionarios en Python</a></li>
<li><a href="#3-sets">Sets: Conjuntos con Hash</a></li>
<li><a href="#4-colisiones">Colisiones y ResoluciÃ³n</a></li>
<li><a href="#5-aplicacion">AplicaciÃ³n: Contador de Frecuencias</a></li>
</ol>
<hr />
<h2>1. CÃ³mo Funciona un Hash Map {#1-como-funciona}</h2>
<h3>1.1 La FunciÃ³n Hash</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  HASH FUNCTION: Convierte cualquier dato en un nÃºmero           â”‚
â”‚                                                                 â”‚
â”‚  &quot;hello&quot; â†’ hash(&quot;hello&quot;) â†’ 2314058222102390712                  â”‚
â”‚  &quot;world&quot; â†’ hash(&quot;world&quot;) â†’ 6736076307280336625                  â”‚
â”‚                                                                 â”‚
â”‚  PROPIEDADES IMPORTANTES:                                       â”‚
â”‚  âœ… Mismo input â†’ siempre mismo output (determinista)          â”‚
â”‚  âœ… RÃ¡pido de calcular                                         â”‚
â”‚  âœ… Distribuye bien los valores (pocos &quot;choques&quot;)              â”‚
â”‚  âŒ Diferente input puede dar mismo output (colisiÃ³n)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>1.2 Del Hash a la PosiciÃ³n</h3>
<pre><code class="language-python"># Internamente, un diccionario es un array
# El hash determina dÃ³nde guardar el valor

def simplified_hash_position(key: str, array_size: int) -&gt; int:
    &quot;&quot;&quot;Simplified example of how position is calculated.

    Real implementation is more complex.
    &quot;&quot;&quot;
    hash_value = hash(key)
    position = hash_value % array_size  # MÃ³dulo para que quepa
    return position

# Ejemplo conceptual (NO es implementaciÃ³n real)
# dict con 8 slots internos:
# &quot;hello&quot; â†’ hash â†’ 2314058... â†’ 2314058 % 8 = 2 â†’ slot[2]
# &quot;world&quot; â†’ hash â†’ 6736076... â†’ 6736076 % 8 = 1 â†’ slot[1]
</code></pre>
<h3>1.3 Por QuÃ© es O(1)</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LISTA: Buscar &quot;hello&quot; en [&quot;world&quot;, &quot;python&quot;, &quot;hello&quot;, ...]     â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  1. Comparar con &quot;world&quot; â†’ NO                                   â”‚
â”‚  2. Comparar con &quot;python&quot; â†’ NO                                  â”‚
â”‚  3. Comparar con &quot;hello&quot; â†’ SÃ                                   â”‚
â”‚  â†’ Peor caso: revisar TODOS los n elementos â†’ O(n)              â”‚
â”‚                                                                 â”‚
â”‚  DICCIONARIO: Buscar &quot;hello&quot;                                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                   â”‚
â”‚  1. Calcular hash(&quot;hello&quot;) â†’ 2314058                            â”‚
â”‚  2. Ir directo a slot[2314058 % size]                           â”‚
â”‚  3. Verificar que la clave coincide                             â”‚
â”‚  â†’ Siempre ~3 pasos, sin importar tamaÃ±o â†’ O(1)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>2. Diccionarios en Python {#2-diccionarios}</h2>
<h3>2.1 CreaciÃ³n y Acceso BÃ¡sico</h3>
<pre><code class="language-python"># Crear diccionarios
word_counts: dict[str, int] = {&quot;hello&quot;: 5, &quot;world&quot;: 3}
empty: dict[str, int] = {}
from_pairs = dict([(&quot;a&quot;, 1), (&quot;b&quot;, 2)])

# Acceso: O(1)
count = word_counts[&quot;hello&quot;]  # 5
# word_counts[&quot;missing&quot;]  # KeyError!

# Acceso seguro: O(1)
count = word_counts.get(&quot;hello&quot;)      # 5
count = word_counts.get(&quot;missing&quot;)    # None
count = word_counts.get(&quot;missing&quot;, 0) # 0 (default)

# Verificar existencia: O(1)
if &quot;hello&quot; in word_counts:
    print(&quot;Found!&quot;)

# Asignar: O(1)
word_counts[&quot;new&quot;] = 10
word_counts[&quot;hello&quot;] = 6  # Sobrescribe
</code></pre>
<h3>2.2 MÃ©todos Importantes</h3>
<pre><code class="language-python">word_counts = {&quot;hello&quot;: 5, &quot;world&quot;: 3, &quot;python&quot;: 7}

# Obtener claves, valores, pares
keys = word_counts.keys()       # dict_keys(['hello', 'world', 'python'])
values = word_counts.values()   # dict_values([5, 3, 7])
items = word_counts.items()     # dict_items([('hello', 5), ...])

# Iterar
for word in word_counts:        # Itera sobre claves
    print(word)

for word, count in word_counts.items():
    print(f&quot;{word}: {count}&quot;)

# Eliminar: O(1)
del word_counts[&quot;hello&quot;]
count = word_counts.pop(&quot;world&quot;)  # Retorna valor y elimina
count = word_counts.pop(&quot;missing&quot;, 0)  # Default si no existe

# Actualizar con otro diccionario
word_counts.update({&quot;new&quot;: 1, &quot;python&quot;: 10})

# setdefault: obtener o insertar default
word_counts.setdefault(&quot;java&quot;, 0)  # Inserta &quot;java&quot;: 0 si no existe
</code></pre>
<h3>2.3 defaultdict: Diccionario con Default AutomÃ¡tico</h3>
<pre><code class="language-python">from collections import defaultdict

# âŒ Con dict normal, necesitas verificar existencia
word_counts: dict[str, int] = {}
for word in [&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;]:
    if word not in word_counts:
        word_counts[word] = 0
    word_counts[word] += 1

# âœ… Con defaultdict, el default se crea automÃ¡ticamente
word_counts: defaultdict[str, int] = defaultdict(int)  # int() = 0
for word in [&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;]:
    word_counts[word] += 1  # Si no existe, crea con valor 0

print(dict(word_counts))  # {'a': 3, 'b': 1, 'c': 1}

# defaultdict con lista
index: defaultdict[str, list[int]] = defaultdict(list)
index[&quot;hello&quot;].append(1)  # Crea lista vacÃ­a si no existe
index[&quot;hello&quot;].append(5)
print(dict(index))  # {'hello': [1, 5]}
</code></pre>
<h3>2.4 Counter: Diccionario para Contar</h3>
<pre><code class="language-python">from collections import Counter

words = [&quot;apple&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;cherry&quot;, &quot;banana&quot;, &quot;apple&quot;]

# Contar frecuencias
counts = Counter(words)
print(counts)  # Counter({'apple': 3, 'banana': 2, 'cherry': 1})

# Acceso como diccionario
print(counts[&quot;apple&quot;])   # 3
print(counts[&quot;missing&quot;]) # 0 (no KeyError!)

# MÃ©todos Ãºtiles
print(counts.most_common(2))  # [('apple', 3), ('banana', 2)]

# Operaciones matemÃ¡ticas
more_words = Counter([&quot;apple&quot;, &quot;date&quot;])
total = counts + more_words  # Suma conteos
</code></pre>
<hr />
<h2>3. Sets: Conjuntos con Hash {#3-sets}</h2>
<h3>3.1 Internamente, un Set es un Dict sin Valores</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SET: Solo almacena las claves, sin valores asociados           â”‚
â”‚                                                                 â”‚
â”‚  Internamente:                                                  â”‚
â”‚  set({&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}) â‰ˆ {&quot;a&quot;: None, &quot;b&quot;: None, &quot;c&quot;: None}       â”‚
â”‚                                                                 â”‚
â”‚  Por eso tiene las mismas complejidades O(1) que dict           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>3.2 Operaciones y Complejidad</h3>
<pre><code class="language-python">words: set[str] = {&quot;hello&quot;, &quot;world&quot;}

# Agregar: O(1)
words.add(&quot;python&quot;)

# Verificar: O(1) - Â¡Esta es la operaciÃ³n clave!
if &quot;hello&quot; in words:
    print(&quot;Found!&quot;)

# Eliminar: O(1)
words.remove(&quot;hello&quot;)     # KeyError si no existe
words.discard(&quot;missing&quot;)  # No error si no existe

# Operaciones de conjuntos: O(min(len(a), len(b)))
a = {1, 2, 3}
b = {2, 3, 4}
union = a | b          # {1, 2, 3, 4}
intersection = a &amp; b   # {2, 3}
difference = a - b     # {1}
</code></pre>
<h3>3.3 CuÃ¡ndo Usar Set vs List</h3>
<table>
<thead>
<tr>
<th>OperaciÃ³n</th>
<th>List</th>
<th>Set</th>
<th>Usar Set cuando...</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x in collection</code></td>
<td>O(n)</td>
<td>O(1)</td>
<td>Muchas bÃºsquedas</td>
</tr>
<tr>
<td>Mantener orden</td>
<td>âœ…</td>
<td>âŒ</td>
<td>Orden no importa</td>
</tr>
<tr>
<td>Permitir duplicados</td>
<td>âœ…</td>
<td>âŒ</td>
<td>Solo necesitas Ãºnicos</td>
</tr>
<tr>
<td>Acceso por Ã­ndice</td>
<td>âœ…</td>
<td>âŒ</td>
<td>No necesitas Ã­ndices</td>
</tr>
</tbody>
</table>
<pre><code class="language-python"># âŒ Lento: verificar stop words en lista
stop_words_list = [&quot;the&quot;, &quot;a&quot;, &quot;an&quot;, &quot;and&quot;, &quot;or&quot;, &quot;but&quot;, ...]

def is_stopword_slow(word: str) -&gt; bool:
    return word in stop_words_list  # O(n) cada vez

# âœ… RÃ¡pido: verificar en set
stop_words_set = {&quot;the&quot;, &quot;a&quot;, &quot;an&quot;, &quot;and&quot;, &quot;or&quot;, &quot;but&quot;, ...}

def is_stopword_fast(word: str) -&gt; bool:
    return word in stop_words_set  # O(1) cada vez
</code></pre>
<hr />
<h2>4. Colisiones y ResoluciÃ³n {#4-colisiones}</h2>
<h3>4.1 Â¿QuÃ© es una ColisiÃ³n?</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  COLISIÃ“N: Dos claves diferentes â†’ mismo slot                   â”‚
â”‚                                                                 â”‚
â”‚  &quot;hello&quot; â†’ hash â†’ 47293 % 8 = 5 â†’ slot[5]                       â”‚
â”‚  &quot;world&quot; â†’ hash â†’ 82645 % 8 = 5 â†’ slot[5]  â† Â¡MISMO SLOT!       â”‚
â”‚                                                                 â”‚
â”‚  Python resuelve esto con &quot;open addressing&quot;:                    â”‚
â”‚  Si slot[5] estÃ¡ ocupado, busca slot[6], slot[7], etc.          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>4.2 Por QuÃ© Sigue Siendo O(1)</h3>
<pre><code>Python mantiene el diccionario &quot;poco lleno&quot; (load factor &lt; 2/3)
Cuando se llena demasiado, lo hace mÃ¡s grande y redistribuye

Con buen factor de carga:
- Promedio: 1-2 comparaciones por bÃºsqueda â†’ O(1) amortizado
- Peor caso (muy raro): O(n) si todas las claves colisionan
</code></pre>
<h3>4.3 QuÃ© Puede Ser Clave de Diccionario</h3>
<pre><code class="language-python"># âœ… HASHABLE: tipos inmutables
d = {}
d[&quot;string&quot;] = 1        # str: OK
d[42] = 2              # int: OK
d[3.14] = 3            # float: OK
d[(1, 2, 3)] = 4       # tuple: OK
d[frozenset({1,2})] = 5  # frozenset: OK

# âŒ NO HASHABLE: tipos mutables
# d[[1, 2, 3]] = 6     # TypeError: unhashable type: 'list'
# d[{1, 2}] = 7        # TypeError: unhashable type: 'set'
# d[{&quot;a&quot;: 1}] = 8      # TypeError: unhashable type: 'dict'

# Â¿Por quÃ©? Si el objeto cambia, su hash cambiarÃ­a
# y no lo encontrarÃ­amos donde lo guardamos
</code></pre>
<hr />
<h2>5. AplicaciÃ³n: Contador de Frecuencias {#5-aplicacion}</h2>
<h3>5.1 Contador Manual</h3>
<pre><code class="language-python">def count_word_frequencies(tokens: list[str]) -&gt; dict[str, int]:
    &quot;&quot;&quot;Count frequency of each word in token list.

    Args:
        tokens: List of words to count.

    Returns:
        Dictionary mapping words to their counts.

    Complexity:
        O(n) where n = len(tokens)

    Example:
        &gt;&gt;&gt; count_word_frequencies([&quot;a&quot;, &quot;b&quot;, &quot;a&quot;])
        {'a': 2, 'b': 1}
    &quot;&quot;&quot;
    frequencies: dict[str, int] = {}

    for token in tokens:
        # O(1) lookup + O(1) assignment
        frequencies[token] = frequencies.get(token, 0) + 1

    return frequencies
</code></pre>
<h3>5.2 Con defaultdict</h3>
<pre><code class="language-python">from collections import defaultdict

def count_frequencies_defaultdict(tokens: list[str]) -&gt; dict[str, int]:
    &quot;&quot;&quot;Count frequencies using defaultdict.

    Cleaner than manual .get() approach.
    &quot;&quot;&quot;
    frequencies: defaultdict[str, int] = defaultdict(int)

    for token in tokens:
        frequencies[token] += 1

    return dict(frequencies)
</code></pre>
<h3>5.3 Con Counter (Una LÃ­nea)</h3>
<pre><code class="language-python">from collections import Counter

def count_frequencies_counter(tokens: list[str]) -&gt; dict[str, int]:
    &quot;&quot;&quot;Count frequencies using Counter.

    Most Pythonic approach.
    &quot;&quot;&quot;
    return dict(Counter(tokens))
</code></pre>
<h3>5.4 Benchmark Comparativo</h3>
<pre><code class="language-python">import time
from collections import Counter, defaultdict

def benchmark_frequency_counters(tokens: list[str]) -&gt; None:
    &quot;&quot;&quot;Compare performance of different counting methods.&quot;&quot;&quot;

    # Method 1: Manual with .get()
    start = time.time()
    freq = {}
    for t in tokens:
        freq[t] = freq.get(t, 0) + 1
    manual_time = time.time() - start

    # Method 2: defaultdict
    start = time.time()
    freq = defaultdict(int)
    for t in tokens:
        freq[t] += 1
    defaultdict_time = time.time() - start

    # Method 3: Counter
    start = time.time()
    freq = Counter(tokens)
    counter_time = time.time() - start

    print(f&quot;Manual:      {manual_time:.4f}s&quot;)
    print(f&quot;defaultdict: {defaultdict_time:.4f}s&quot;)
    print(f&quot;Counter:     {counter_time:.4f}s&quot;)

# Con 1,000,000 tokens:
# Manual:      0.0800s
# defaultdict: 0.0750s
# Counter:     0.0650s  â† MÃ¡s rÃ¡pido (implementado en C)
</code></pre>
<h3>5.5 Construyendo hacia el Ãndice Invertido</h3>
<pre><code class="language-python">from collections import defaultdict

def build_term_document_map(
    documents: list[tuple[int, list[str]]]
) -&gt; dict[str, set[int]]:
    &quot;&quot;&quot;Build mapping from terms to document IDs.

    This is the core of an inverted index.

    Args:
        documents: List of (doc_id, tokens) pairs.

    Returns:
        Dictionary mapping each term to set of doc IDs containing it.

    Example:
        &gt;&gt;&gt; docs = [(1, [&quot;hello&quot;, &quot;world&quot;]), (2, [&quot;hello&quot;, &quot;python&quot;])]
        &gt;&gt;&gt; build_term_document_map(docs)
        {'hello': {1, 2}, 'world': {1}, 'python': {2}}
    &quot;&quot;&quot;
    term_to_docs: defaultdict[str, set[int]] = defaultdict(set)

    for doc_id, tokens in documents:
        for token in tokens:
            term_to_docs[token].add(doc_id)

    return dict(term_to_docs)
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes</h2>
<h3>Error 1: Modificar dict mientras iteras</h3>
<pre><code class="language-python"># âŒ RuntimeError: dictionary changed size during iteration
word_counts = {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}
for word in word_counts:
    if word_counts[word] &lt; 2:
        del word_counts[word]

# âœ… Iterar sobre copia de claves
for word in list(word_counts.keys()):
    if word_counts[word] &lt; 2:
        del word_counts[word]

# âœ… O crear nuevo diccionario
word_counts = {w: c for w, c in word_counts.items() if c &gt;= 2}
</code></pre>
<h3>Error 2: Asumir orden en versiones antiguas</h3>
<pre><code class="language-python"># Python 3.7+: dict mantiene orden de inserciÃ³n
# Python &lt; 3.7: NO garantiza orden

# Si necesitas orden garantizado, usa:
from collections import OrderedDict
</code></pre>
<h3>Error 3: Usar objeto mutable como clave</h3>
<pre><code class="language-python"># âŒ TypeError
cache = {}
cache[[1, 2, 3]] = &quot;result&quot;  # Lista no es hashable

# âœ… Convertir a tupla
cache[tuple([1, 2, 3])] = &quot;result&quot;
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 5.1: Contador de Frecuencias</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 5.2: Benchmark List vs Set</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 5.3: Term-Document Map</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.youtube.com/watch?v=npw4s1QTmPg">Python Dict Implementation</a></td>
<td>Video</td>
<td>ğŸŸ¡ Recomendado</td>
</tr>
<tr>
<td><a href="https://wiki.python.org/moin/TimeComplexity">Time Complexity</a></td>
<td>Wiki</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/collections.html">collections Module</a></td>
<td>Docs</td>
<td>ğŸŸ¡ Recomendado</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ”— Referencias del Glosario</h2>
<ul>
<li><a href="#mod_GLOSARIO">Hash Map</a></li>
<li><a href="#mod_GLOSARIO">Hash Function</a></li>
<li><a href="#mod_GLOSARIO">ColisiÃ³n</a></li>
<li><a href="#mod_GLOSARIO">Set</a></li>
<li><a href="#mod_GLOSARIO">O(1) Amortizado</a></li>
</ul>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_04_ARRAYS_STRINGS">04_ARRAYS_STRINGS</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_06_INVERTED_INDEX">06_INVERTED_INDEX</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_06_INVERTED_INDEX" class="cover-page">
            <a name="mod_06_INVERTED_INDEX"></a>
            <div class="cover-title">06 - Ãndice Invertido</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>06 - Ãndice Invertido</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Construir el nÃºcleo del motor de bÃºsqueda: un Ã­ndice invertido que mapea palabras a documentos.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: El Ãndice de un Libro de Texto</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   LIBRO DE TEXTO: Ãndice al final                                           â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                           â”‚
â”‚                                                                             â”‚
â”‚   &quot;algoritmo&quot; .......... pÃ¡ginas 12, 45, 78, 134                            â”‚
â”‚   &quot;array&quot; .............. pÃ¡ginas 23, 56                                     â”‚
â”‚   &quot;bÃºsqueda binaria&quot; ... pÃ¡ginas 89, 90, 91                                 â”‚
â”‚   &quot;recursiÃ³n&quot; .......... pÃ¡ginas 67, 68, 150                                â”‚
â”‚                                                                             â”‚
â”‚   Sin este Ã­ndice: leer TODO el libro para encontrar &quot;recursiÃ³n&quot;            â”‚
â”‚   Con el Ã­ndice: ir directo a las pÃ¡ginas 67, 68, 150                       â”‚
â”‚                                                                             â”‚
â”‚   ÃNDICE INVERTIDO = Lo mismo, pero para TODOS los documentos               â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€               â”‚
â”‚                                                                             â”‚
â”‚   &quot;python&quot; â†’ [doc_1, doc_3, doc_7]                                          â”‚
â”‚   &quot;search&quot; â†’ [doc_2, doc_3]                                                 â”‚
â”‚   &quot;engine&quot; â†’ [doc_1, doc_2, doc_3]                                          â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-que-es">Â¿QuÃ© es un Ãndice Invertido?</a></li>
<li><a href="#2-estructura">Estructura de Datos</a></li>
<li><a href="#3-implementacion">ImplementaciÃ³n BÃ¡sica</a></li>
<li><a href="#4-busqueda">BÃºsqueda con AND/OR</a></li>
<li><a href="#5-frecuencias">Ãndice con Frecuencias</a></li>
<li><a href="#6-analisis">AnÃ¡lisis de Complejidad</a></li>
</ol>
<hr />
<h2>1. Â¿QuÃ© es un Ãndice Invertido? {#1-que-es}</h2>
<h3>1.1 Forward Index vs Inverted Index</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FORWARD INDEX (Ã­ndice directo)                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                  â”‚
â”‚  doc_1 â†’ [&quot;python&quot;, &quot;code&quot;, &quot;example&quot;]                          â”‚
â”‚  doc_2 â†’ [&quot;java&quot;, &quot;code&quot;, &quot;tutorial&quot;]                           â”‚
â”‚  doc_3 â†’ [&quot;python&quot;, &quot;tutorial&quot;, &quot;search&quot;]                       â”‚
â”‚                                                                 â”‚
â”‚  Para buscar &quot;python&quot;: revisar TODOS los documentos â†’ O(nÃ—m)    â”‚
â”‚                                                                 â”‚
â”‚  INVERTED INDEX (Ã­ndice invertido)                              â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                              â”‚
â”‚  &quot;python&quot;   â†’ [doc_1, doc_3]                                    â”‚
â”‚  &quot;code&quot;     â†’ [doc_1, doc_2]                                    â”‚
â”‚  &quot;tutorial&quot; â†’ [doc_2, doc_3]                                    â”‚
â”‚  &quot;example&quot;  â†’ [doc_1]                                           â”‚
â”‚  &quot;java&quot;     â†’ [doc_2]                                           â”‚
â”‚  &quot;search&quot;   â†’ [doc_3]                                           â”‚
â”‚                                                                 â”‚
â”‚  Para buscar &quot;python&quot;: lookup directo â†’ O(1)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>1.2 Por QuÃ© Todos los Buscadores lo Usan</h3>
<ul>
<li><strong>Google, Bing, DuckDuckGo:</strong> Ãndices invertidos masivos</li>
<li><strong>Elasticsearch, Solr:</strong> Bases de datos de bÃºsqueda basadas en Ã­ndices invertidos</li>
<li><strong>Bases de datos SQL:</strong> Ãndices B-tree para columnas buscables</li>
</ul>
<pre><code>Sin Ã­ndice: buscar en 1 billÃ³n de documentos â†’ 1 billÃ³n de comparaciones
Con Ã­ndice: buscar en 1 billÃ³n de documentos â†’ 1 lookup + leer lista de docs
</code></pre>
<hr />
<h2>2. Estructura de Datos {#2-estructura}</h2>
<h3>2.1 RepresentaciÃ³n BÃ¡sica</h3>
<pre><code class="language-python"># Estructura mÃ¡s simple: palabra â†’ lista de doc_ids
InvertedIndex = dict[str, list[int]]

# Ejemplo:
index: InvertedIndex = {
    &quot;python&quot;: [1, 3, 5],
    &quot;java&quot;: [2, 4],
    &quot;code&quot;: [1, 2, 3, 4, 5]
}
</code></pre>
<h3>2.2 RepresentaciÃ³n con Sets (Mejor para AND/OR)</h3>
<pre><code class="language-python"># Con sets: operaciones de conjuntos mÃ¡s eficientes
InvertedIndex = dict[str, set[int]]

index: InvertedIndex = {
    &quot;python&quot;: {1, 3, 5},
    &quot;java&quot;: {2, 4},
    &quot;code&quot;: {1, 2, 3, 4, 5}
}

# BÃºsqueda AND: documentos con &quot;python&quot; Y &quot;code&quot;
result = index[&quot;python&quot;] &amp; index[&quot;code&quot;]  # {1, 3, 5}

# BÃºsqueda OR: documentos con &quot;python&quot; O &quot;java&quot;
result = index[&quot;python&quot;] | index[&quot;java&quot;]  # {1, 2, 3, 4, 5}
</code></pre>
<h3>2.3 RepresentaciÃ³n con Frecuencias</h3>
<pre><code class="language-python"># Para ranking: guardar cuÃ¡ntas veces aparece cada palabra
# palabra â†’ {doc_id: frecuencia}
InvertedIndexWithFreq = dict[str, dict[int, int]]

index: InvertedIndexWithFreq = {
    &quot;python&quot;: {1: 3, 3: 1, 5: 2},  # doc_1 tiene &quot;python&quot; 3 veces
    &quot;java&quot;: {2: 5, 4: 1},
    &quot;code&quot;: {1: 1, 2: 1, 3: 2, 4: 1, 5: 1}
}
</code></pre>
<hr />
<h2>3. ImplementaciÃ³n BÃ¡sica {#3-implementacion}</h2>
<h3>3.1 Clase InvertedIndex</h3>
<pre><code class="language-python">from collections import defaultdict
from typing import Iterator


class InvertedIndex:
    &quot;&quot;&quot;Inverted index for text search.

    Maps terms to the set of document IDs containing them.

    Attributes:
        _index: Internal dictionary mapping terms to doc_id sets.
        _doc_count: Number of documents indexed.

    Example:
        &gt;&gt;&gt; idx = InvertedIndex()
        &gt;&gt;&gt; idx.add_document(1, [&quot;hello&quot;, &quot;world&quot;])
        &gt;&gt;&gt; idx.add_document(2, [&quot;hello&quot;, &quot;python&quot;])
        &gt;&gt;&gt; idx.search(&quot;hello&quot;)
        {1, 2}
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        &quot;&quot;&quot;Initialize empty inverted index.&quot;&quot;&quot;
        self._index: defaultdict[str, set[int]] = defaultdict(set)
        self._doc_count: int = 0
        self._doc_ids: set[int] = set()

    def add_document(self, doc_id: int, tokens: list[str]) -&gt; None:
        &quot;&quot;&quot;Add a document to the index.

        Args:
            doc_id: Unique identifier for the document.
            tokens: List of tokens (words) in the document.

        Raises:
            ValueError: If doc_id already exists in index.

        Complexity:
            O(t) where t = len(tokens)
        &quot;&quot;&quot;
        if doc_id in self._doc_ids:
            raise ValueError(f&quot;Document {doc_id} already indexed&quot;)

        self._doc_ids.add(doc_id)
        self._doc_count += 1

        for token in tokens:
            self._index[token].add(doc_id)

    def search(self, term: str) -&gt; set[int]:
        &quot;&quot;&quot;Find all documents containing a term.

        Args:
            term: Word to search for.

        Returns:
            Set of document IDs containing the term.

        Complexity:
            O(1) for lookup (returns reference to existing set)
        &quot;&quot;&quot;
        return self._index.get(term, set()).copy()

    def get_term_count(self) -&gt; int:
        &quot;&quot;&quot;Return number of unique terms in index.&quot;&quot;&quot;
        return len(self._index)

    def get_document_count(self) -&gt; int:
        &quot;&quot;&quot;Return number of indexed documents.&quot;&quot;&quot;
        return self._doc_count

    def contains_term(self, term: str) -&gt; bool:
        &quot;&quot;&quot;Check if term exists in index.&quot;&quot;&quot;
        return term in self._index

    def get_document_frequency(self, term: str) -&gt; int:
        &quot;&quot;&quot;Return number of documents containing term.

        Also known as DF (Document Frequency).
        &quot;&quot;&quot;
        return len(self._index.get(term, set()))

    def __repr__(self) -&gt; str:
        return (
            f&quot;InvertedIndex(terms={self.get_term_count()}, &quot;
            f&quot;documents={self._doc_count})&quot;
        )

    def __contains__(self, term: str) -&gt; bool:
        &quot;&quot;&quot;Allow 'term in index' syntax.&quot;&quot;&quot;
        return self.contains_term(term)

    def __len__(self) -&gt; int:
        &quot;&quot;&quot;Return number of terms.&quot;&quot;&quot;
        return self.get_term_count()
</code></pre>
<h3>3.2 Uso BÃ¡sico</h3>
<pre><code class="language-python"># Crear Ã­ndice
index = InvertedIndex()

# Agregar documentos (ya tokenizados)
index.add_document(1, [&quot;python&quot;, &quot;programming&quot;, &quot;tutorial&quot;])
index.add_document(2, [&quot;java&quot;, &quot;programming&quot;, &quot;guide&quot;])
index.add_document(3, [&quot;python&quot;, &quot;data&quot;, &quot;science&quot;])

# Buscar
print(index.search(&quot;python&quot;))       # {1, 3}
print(index.search(&quot;programming&quot;))  # {1, 2}
print(index.search(&quot;missing&quot;))      # set()

# InformaciÃ³n del Ã­ndice
print(index.get_term_count())       # 7 (tÃ©rminos Ãºnicos)
print(index.get_document_count())   # 3
print(index.get_document_frequency(&quot;python&quot;))  # 2
</code></pre>
<hr />
<h2>4. BÃºsqueda con AND/OR {#4-busqueda}</h2>
<h3>4.1 ImplementaciÃ³n de BÃºsqueda Multi-TÃ©rmino</h3>
<pre><code class="language-python">class InvertedIndex:
    # ... (mÃ©todos anteriores) ...

    def search_and(self, terms: list[str]) -&gt; set[int]:
        &quot;&quot;&quot;Find documents containing ALL terms.

        Args:
            terms: List of terms to search for.

        Returns:
            Set of doc IDs containing all terms.

        Example:
            &gt;&gt;&gt; idx.search_and([&quot;python&quot;, &quot;data&quot;])
            {3}  # Only doc 3 has both

        Complexity:
            O(t Ã— min_set_size) where t = len(terms)
        &quot;&quot;&quot;
        if not terms:
            return set()

        # Start with docs containing first term
        result = self.search(terms[0])

        # Intersect with docs containing each subsequent term
        for term in terms[1:]:
            result &amp;= self._index.get(term, set())

            # Early exit if no matches
            if not result:
                return set()

        return result

    def search_or(self, terms: list[str]) -&gt; set[int]:
        &quot;&quot;&quot;Find documents containing ANY term.

        Args:
            terms: List of terms to search for.

        Returns:
            Set of doc IDs containing at least one term.

        Example:
            &gt;&gt;&gt; idx.search_or([&quot;python&quot;, &quot;java&quot;])
            {1, 2, 3}  # All docs with either

        Complexity:
            O(t Ã— avg_set_size) where t = len(terms)
        &quot;&quot;&quot;
        result: set[int] = set()

        for term in terms:
            result |= self._index.get(term, set())

        return result

    def search_phrase(self, query: str) -&gt; set[int]:
        &quot;&quot;&quot;Search for documents matching query.

        Tokenizes query and performs AND search.

        Args:
            query: Search query string.

        Returns:
            Set of matching document IDs.
        &quot;&quot;&quot;
        # Simple tokenization (should use proper tokenizer)
        terms = query.lower().split()
        return self.search_and(terms)
</code></pre>
<h3>4.2 Ejemplo de BÃºsqueda</h3>
<pre><code class="language-python">index = InvertedIndex()
index.add_document(1, [&quot;python&quot;, &quot;web&quot;, &quot;flask&quot;])
index.add_document(2, [&quot;python&quot;, &quot;data&quot;, &quot;pandas&quot;])
index.add_document(3, [&quot;java&quot;, &quot;web&quot;, &quot;spring&quot;])
index.add_document(4, [&quot;python&quot;, &quot;web&quot;, &quot;django&quot;])

# AND: documentos con python Y web
result = index.search_and([&quot;python&quot;, &quot;web&quot;])
print(result)  # {1, 4}

# OR: documentos con flask O django
result = index.search_or([&quot;flask&quot;, &quot;django&quot;])
print(result)  # {1, 4}

# Combinado: (python AND web) OR java
python_web = index.search_and([&quot;python&quot;, &quot;web&quot;])
java_docs = index.search(&quot;java&quot;)
result = python_web | java_docs
print(result)  # {1, 3, 4}
</code></pre>
<hr />
<h2>5. Ãndice con Frecuencias {#5-frecuencias}</h2>
<h3>5.1 Para TF-IDF Necesitamos Frecuencias</h3>
<pre><code class="language-python">from collections import defaultdict
from typing import NamedTuple


class TermInfo(NamedTuple):
    &quot;&quot;&quot;Information about a term in a document.&quot;&quot;&quot;
    doc_id: int
    frequency: int


class InvertedIndexWithFreq:
    &quot;&quot;&quot;Inverted index that stores term frequencies.

    Needed for TF-IDF ranking.
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        # term â†’ {doc_id: frequency}
        self._index: defaultdict[str, dict[int, int]] = defaultdict(dict)
        self._doc_lengths: dict[int, int] = {}  # doc_id â†’ total tokens
        self._doc_count: int = 0

    def add_document(self, doc_id: int, tokens: list[str]) -&gt; None:
        &quot;&quot;&quot;Add document with frequency tracking.

        Args:
            doc_id: Unique document identifier.
            tokens: List of tokens in document.
        &quot;&quot;&quot;
        if doc_id in self._doc_lengths:
            raise ValueError(f&quot;Document {doc_id} already indexed&quot;)

        # Count frequencies
        token_counts: dict[str, int] = {}
        for token in tokens:
            token_counts[token] = token_counts.get(token, 0) + 1

        # Add to index
        for token, count in token_counts.items():
            self._index[token][doc_id] = count

        self._doc_lengths[doc_id] = len(tokens)
        self._doc_count += 1

    def get_term_frequency(self, term: str, doc_id: int) -&gt; int:
        &quot;&quot;&quot;Get frequency of term in specific document.

        Returns 0 if term not in document.
        &quot;&quot;&quot;
        return self._index.get(term, {}).get(doc_id, 0)

    def get_document_frequency(self, term: str) -&gt; int:
        &quot;&quot;&quot;Get number of documents containing term.&quot;&quot;&quot;
        return len(self._index.get(term, {}))

    def get_documents_for_term(self, term: str) -&gt; dict[int, int]:
        &quot;&quot;&quot;Get all documents containing term with frequencies.

        Returns:
            Dict mapping doc_id to term frequency.
        &quot;&quot;&quot;
        return self._index.get(term, {}).copy()

    def get_document_length(self, doc_id: int) -&gt; int:
        &quot;&quot;&quot;Get total token count for document.&quot;&quot;&quot;
        return self._doc_lengths.get(doc_id, 0)

    def get_all_doc_ids(self) -&gt; set[int]:
        &quot;&quot;&quot;Get set of all indexed document IDs.&quot;&quot;&quot;
        return set(self._doc_lengths.keys())

    @property
    def total_documents(self) -&gt; int:
        &quot;&quot;&quot;Total number of indexed documents.&quot;&quot;&quot;
        return self._doc_count
</code></pre>
<h3>5.2 Uso del Ãndice con Frecuencias</h3>
<pre><code class="language-python">index = InvertedIndexWithFreq()

# Documento 1: &quot;python&quot; aparece 3 veces
index.add_document(1, [&quot;python&quot;, &quot;python&quot;, &quot;code&quot;, &quot;python&quot;, &quot;tutorial&quot;])

# Documento 2: &quot;python&quot; aparece 1 vez
index.add_document(2, [&quot;java&quot;, &quot;code&quot;, &quot;python&quot;])

# Obtener frecuencias
print(index.get_term_frequency(&quot;python&quot;, 1))  # 3
print(index.get_term_frequency(&quot;python&quot;, 2))  # 1
print(index.get_term_frequency(&quot;python&quot;, 3))  # 0 (doc no existe)

# Document frequency (en cuÃ¡ntos docs aparece)
print(index.get_document_frequency(&quot;python&quot;))  # 2
print(index.get_document_frequency(&quot;java&quot;))    # 1

# Para TF-IDF
print(index.get_document_length(1))  # 5 tokens totales
print(index.total_documents)         # 2
</code></pre>
<hr />
<h2>6. AnÃ¡lisis de Complejidad {#6-analisis}</h2>
<h3>6.1 Complejidad de Operaciones</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  OPERACIÃ“N                      â”‚ COMPLEJIDAD                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                   â”‚
â”‚  add_document(doc_id, tokens)   â”‚ O(t) donde t = len(tokens)    â”‚
â”‚  search(term)                   â”‚ O(1) lookup + O(k) copia      â”‚
â”‚  search_and([terms])            â”‚ O(t Ã— s) t=terms, s=set size  â”‚
â”‚  search_or([terms])             â”‚ O(t Ã— s)                      â”‚
â”‚  get_document_frequency(term)   â”‚ O(1)                          â”‚
â”‚  contains_term(term)            â”‚ O(1)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Donde:
- t = nÃºmero de tokens
- k = nÃºmero de documentos que contienen el tÃ©rmino
- s = tamaÃ±o promedio de los sets de documentos
</code></pre>
<h3>6.2 Complejidad de Espacio</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ESPACIO DEL ÃNDICE                                             â”‚
â”‚                                                                 â”‚
â”‚  Si tenemos:                                                    â”‚
â”‚  - D documentos                                                 â”‚
â”‚  - V tÃ©rminos Ãºnicos (vocabulario)                              â”‚
â”‚  - T tokens totales                                             â”‚
â”‚                                                                 â”‚
â”‚  Ãndice bÃ¡sico (sin frecuencias):                               â”‚
â”‚  - Diccionario: O(V) entradas                                   â”‚
â”‚  - Sets: O(T) referencias a doc_ids en total                    â”‚
â”‚  - Total: O(V + T)                                              â”‚
â”‚                                                                 â”‚
â”‚  En la prÃ¡ctica:                                                â”‚
â”‚  - El Ã­ndice es MUCHO mÃ¡s pequeÃ±o que los documentos            â”‚
â”‚  - Solo guardamos doc_ids, no el texto completo                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>6.3 Ejemplo de AnÃ¡lisis</h3>
<pre><code class="language-python">&quot;&quot;&quot;
ANÃLISIS DE COMPLEJIDAD: add_document()

def add_document(self, doc_id: int, tokens: list[str]) -&gt; None:
    if doc_id in self._doc_ids:          # O(1) - set lookup
        raise ValueError(...)

    self._doc_ids.add(doc_id)            # O(1) - set add
    self._doc_count += 1                  # O(1)

    for token in tokens:                  # O(t) iteraciones
        self._index[token].add(doc_id)    # O(1) dict + set

TOTAL: O(1) + O(1) + O(1) + O(t Ã— 1) = O(t)

Donde t = len(tokens)
&quot;&quot;&quot;
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes</h2>
<h3>Error 1: Retornar referencia al set interno</h3>
<pre><code class="language-python"># âŒ Peligroso: permite modificar el Ã­ndice externamente
def search(self, term: str) -&gt; set[int]:
    return self._index.get(term, set())  # Retorna referencia

result = index.search(&quot;python&quot;)
result.add(999)  # Â¡Modifica el Ã­ndice!

# âœ… Seguro: retornar copia
def search(self, term: str) -&gt; set[int]:
    return self._index.get(term, set()).copy()
</code></pre>
<h3>Error 2: No manejar tÃ©rminos no encontrados</h3>
<pre><code class="language-python"># âŒ KeyError si el tÃ©rmino no existe
def search(self, term: str) -&gt; set[int]:
    return self._index[term]

# âœ… Retornar set vacÃ­o
def search(self, term: str) -&gt; set[int]:
    return self._index.get(term, set()).copy()
</code></pre>
<h3>Error 3: Indexar documento duplicado</h3>
<pre><code class="language-python"># âŒ Silenciosamente duplica
def add_document(self, doc_id: int, tokens: list[str]) -&gt; None:
    for token in tokens:
        self._index[token].add(doc_id)  # doc_id ya podrÃ­a estar

# âœ… Verificar y lanzar error
def add_document(self, doc_id: int, tokens: list[str]) -&gt; None:
    if doc_id in self._doc_ids:
        raise ValueError(f&quot;Document {doc_id} already indexed&quot;)
    # ...
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 6.1: Ãndice BÃ¡sico</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 6.2: BÃºsqueda AND/OR</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 6.3: Ãndice con Frecuencias</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://en.wikipedia.org/wiki/Inverted_index">Inverted Index - Wikipedia</a></td>
<td>Lectura</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://www.youtube.com/watch?v=JZBhBaznk0k">How Search Engines Work</a></td>
<td>Video</td>
<td>ğŸŸ¡ Recomendado</td>
</tr>
<tr>
<td><a href="https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up">Elasticsearch Internals</a></td>
<td>Blog</td>
<td>ğŸŸ¢ Complementario</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ”— Referencias del Glosario</h2>
<ul>
<li><a href="#mod_GLOSARIO">Ãndice Invertido</a></li>
<li><a href="#mod_GLOSARIO">Document Frequency</a></li>
<li><a href="#mod_GLOSARIO">Term Frequency</a></li>
<li><a href="#mod_GLOSARIO">Posting List</a></li>
</ul>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_05_HASHMAPS_SETS">05_HASHMAPS_SETS</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_07_RECURSION">07_RECURSION</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_13_LINKED_LISTS_STACKS_QUEUES" class="cover-page">
            <a name="mod_13_LINKED_LISTS_STACKS_QUEUES"></a>
            <div class="cover-title">13 - Linked Lists, Stacks, Queues</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>13 - Linked Lists, Stacks y Queues</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Dominar estructuras de datos lineales fundamentales que son base para Trees y Graphs.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: El Tren, la Pila de Platos y la Fila del Banco</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   LINKED LIST = UN TREN                                                     â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                     â”‚
â”‚   Cada vagÃ³n (nodo) tiene:                                                  â”‚
â”‚   â€¢ Pasajeros (datos)                                                       â”‚
â”‚   â€¢ Enganche al siguiente vagÃ³n (pointer)                                   â”‚
â”‚                                                                             â”‚
â”‚   [HEAD] â†’ [A|â†’] â†’ [B|â†’] â†’ [C|â†’] â†’ [D|âˆ…]                                    â”‚
â”‚                                                                             â”‚
â”‚   STACK = PILA DE PLATOS                                                    â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                    â”‚
â”‚   LIFO: Last In, First Out                                                  â”‚
â”‚   Solo puedes sacar el plato de arriba                                      â”‚
â”‚                                                                             â”‚
â”‚     â”Œâ”€â”€â”€â”                                                                   â”‚
â”‚     â”‚ C â”‚ â† top (Ãºltimo en entrar, primero en salir)                        â”‚
â”‚     â”œâ”€â”€â”€â”¤                                                                   â”‚
â”‚     â”‚ B â”‚                                                                   â”‚
â”‚     â”œâ”€â”€â”€â”¤                                                                   â”‚
â”‚     â”‚ A â”‚ â† bottom                                                          â”‚
â”‚     â””â”€â”€â”€â”˜                                                                   â”‚
â”‚                                                                             â”‚
â”‚   QUEUE = FILA DEL BANCO                                                    â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                    â”‚
â”‚   FIFO: First In, First Out                                                 â”‚
â”‚   El primero en llegar es el primero en ser atendido                        â”‚
â”‚                                                                             â”‚
â”‚   [A] â†’ [B] â†’ [C] â†’ [D]                                                     â”‚
â”‚    â†‘                  â†‘                                                     â”‚
â”‚   front             rear                                                    â”‚
â”‚   (sale)           (entra)                                                  â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-linked-lists">Linked Lists</a></li>
<li><a href="#2-stacks">Stacks</a></li>
<li><a href="#3-queues">Queues</a></li>
<li><a href="#4-comparacion">ComparaciÃ³n y CuÃ¡ndo Usar</a></li>
</ol>
<hr />
<h2>1. Linked Lists {#1-linked-lists}</h2>
<h3>1.1 Node y Linked List</h3>
<pre><code class="language-python">from typing import Generic, TypeVar, Optional

T = TypeVar('T')


class Node(Generic[T]):
    &quot;&quot;&quot;A node in a linked list.

    Attributes:
        data: The value stored in this node.
        next: Reference to the next node (or None).
    &quot;&quot;&quot;

    def __init__(self, data: T) -&gt; None:
        self.data: T = data
        self.next: Optional[Node[T]] = None

    def __repr__(self) -&gt; str:
        return f&quot;Node({self.data})&quot;


class LinkedList(Generic[T]):
    &quot;&quot;&quot;Singly linked list implementation.

    Time Complexities:
        - append: O(n) without tail, O(1) with tail
        - prepend: O(1)
        - search: O(n)
        - delete: O(n)
        - access by index: O(n)
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self.head: Optional[Node[T]] = None
        self._size: int = 0

    def is_empty(self) -&gt; bool:
        &quot;&quot;&quot;Check if list is empty. O(1)&quot;&quot;&quot;
        return self.head is None

    def __len__(self) -&gt; int:
        &quot;&quot;&quot;Return number of elements. O(1)&quot;&quot;&quot;
        return self._size

    def prepend(self, data: T) -&gt; None:
        &quot;&quot;&quot;Add element at the beginning. O(1)

        Args:
            data: Value to add.
        &quot;&quot;&quot;
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
        self._size += 1

    def append(self, data: T) -&gt; None:
        &quot;&quot;&quot;Add element at the end. O(n)

        Args:
            data: Value to add.
        &quot;&quot;&quot;
        new_node = Node(data)

        if self.is_empty():
            self.head = new_node
        else:
            current = self.head
            while current.next is not None:
                current = current.next
            current.next = new_node

        self._size += 1

    def search(self, data: T) -&gt; Optional[Node[T]]:
        &quot;&quot;&quot;Find node containing data. O(n)

        Returns:
            Node if found, None otherwise.
        &quot;&quot;&quot;
        current = self.head
        while current is not None:
            if current.data == data:
                return current
            current = current.next
        return None

    def delete(self, data: T) -&gt; bool:
        &quot;&quot;&quot;Delete first node with given data. O(n)

        Returns:
            True if deleted, False if not found.
        &quot;&quot;&quot;
        if self.is_empty():
            return False

        # Special case: delete head
        if self.head.data == data:
            self.head = self.head.next
            self._size -= 1
            return True

        # Search for node before the one to delete
        current = self.head
        while current.next is not None:
            if current.next.data == data:
                current.next = current.next.next
                self._size -= 1
                return True
            current = current.next

        return False

    def to_list(self) -&gt; list[T]:
        &quot;&quot;&quot;Convert to Python list. O(n)&quot;&quot;&quot;
        result = []
        current = self.head
        while current is not None:
            result.append(current.data)
            current = current.next
        return result

    def __repr__(self) -&gt; str:
        return f&quot;LinkedList({self.to_list()})&quot;

    def __iter__(self):
        &quot;&quot;&quot;Allow iteration over list.&quot;&quot;&quot;
        current = self.head
        while current is not None:
            yield current.data
            current = current.next
</code></pre>
<h3>1.2 Doubly Linked List</h3>
<pre><code class="language-python">class DNode(Generic[T]):
    &quot;&quot;&quot;Node for doubly linked list.&quot;&quot;&quot;

    def __init__(self, data: T) -&gt; None:
        self.data: T = data
        self.prev: Optional[DNode[T]] = None
        self.next: Optional[DNode[T]] = None


class DoublyLinkedList(Generic[T]):
    &quot;&quot;&quot;Doubly linked list with head and tail pointers.

    Advantages over singly linked:
    - O(1) append (with tail pointer)
    - O(1) delete from end
    - Can traverse backwards
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self.head: Optional[DNode[T]] = None
        self.tail: Optional[DNode[T]] = None
        self._size: int = 0

    def append(self, data: T) -&gt; None:
        &quot;&quot;&quot;Add at end. O(1) with tail pointer.&quot;&quot;&quot;
        new_node = DNode(data)

        if self.tail is None:
            self.head = self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node

        self._size += 1

    def prepend(self, data: T) -&gt; None:
        &quot;&quot;&quot;Add at beginning. O(1)&quot;&quot;&quot;
        new_node = DNode(data)

        if self.head is None:
            self.head = self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node

        self._size += 1

    def pop_last(self) -&gt; Optional[T]:
        &quot;&quot;&quot;Remove and return last element. O(1)&quot;&quot;&quot;
        if self.tail is None:
            return None

        data = self.tail.data

        if self.head == self.tail:
            self.head = self.tail = None
        else:
            self.tail = self.tail.prev
            self.tail.next = None

        self._size -= 1
        return data
</code></pre>
<h3>1.3 List vs Linked List</h3>
<table>
<thead>
<tr>
<th>OperaciÃ³n</th>
<th>Python list</th>
<th>Linked List</th>
</tr>
</thead>
<tbody>
<tr>
<td>Access [i]</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Append</td>
<td>O(1) amort</td>
<td>O(n) o O(1)*</td>
</tr>
<tr>
<td>Prepend</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Insert middle</td>
<td>O(n)</td>
<td>O(n) search + O(1) insert</td>
</tr>
<tr>
<td>Delete first</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Delete last</td>
<td>O(1)</td>
<td>O(n) o O(1)**</td>
</tr>
<tr>
<td>Search</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<p>* O(1) si guardamos tail pointer<br />
** O(1) con doubly linked list</p>
<hr />
<h2>2. Stacks {#2-stacks}</h2>
<h3>2.1 ImplementaciÃ³n con Lista</h3>
<pre><code class="language-python">class Stack(Generic[T]):
    &quot;&quot;&quot;Stack (LIFO) implementation using list.

    All operations are O(1).

    Example:
        &gt;&gt;&gt; s = Stack()
        &gt;&gt;&gt; s.push(1)
        &gt;&gt;&gt; s.push(2)
        &gt;&gt;&gt; s.pop()
        2
        &gt;&gt;&gt; s.peek()
        1
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self._items: list[T] = []

    def is_empty(self) -&gt; bool:
        &quot;&quot;&quot;Check if stack is empty. O(1)&quot;&quot;&quot;
        return len(self._items) == 0

    def push(self, item: T) -&gt; None:
        &quot;&quot;&quot;Add item to top. O(1)&quot;&quot;&quot;
        self._items.append(item)

    def pop(self) -&gt; T:
        &quot;&quot;&quot;Remove and return top item. O(1)

        Raises:
            IndexError: If stack is empty.
        &quot;&quot;&quot;
        if self.is_empty():
            raise IndexError(&quot;Pop from empty stack&quot;)
        return self._items.pop()

    def peek(self) -&gt; T:
        &quot;&quot;&quot;Return top item without removing. O(1)

        Raises:
            IndexError: If stack is empty.
        &quot;&quot;&quot;
        if self.is_empty():
            raise IndexError(&quot;Peek at empty stack&quot;)
        return self._items[-1]

    def __len__(self) -&gt; int:
        return len(self._items)

    def __repr__(self) -&gt; str:
        return f&quot;Stack({self._items})&quot;
</code></pre>
<h3>2.2 Aplicaciones de Stack</h3>
<pre><code class="language-python">def is_balanced_parentheses(expression: str) -&gt; bool:
    &quot;&quot;&quot;Check if parentheses are balanced.

    Example:
        &gt;&gt;&gt; is_balanced_parentheses(&quot;((()))&quot;)
        True
        &gt;&gt;&gt; is_balanced_parentheses(&quot;(()&quot;)
        False
    &quot;&quot;&quot;
    stack: Stack[str] = Stack()
    matching = {')': '(', ']': '[', '}': '{'}

    for char in expression:
        if char in '([{':
            stack.push(char)
        elif char in ')]}':
            if stack.is_empty():
                return False
            if stack.pop() != matching[char]:
                return False

    return stack.is_empty()


def reverse_string_with_stack(s: str) -&gt; str:
    &quot;&quot;&quot;Reverse string using stack.

    Demonstrates LIFO property.
    &quot;&quot;&quot;
    stack: Stack[str] = Stack()

    for char in s:
        stack.push(char)

    result = []
    while not stack.is_empty():
        result.append(stack.pop())

    return ''.join(result)
</code></pre>
<h3>2.3 Call Stack (Contexto de RecursiÃ³n)</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  EL CALL STACK ES UN STACK                                      â”‚
â”‚                                                                 â”‚
â”‚  factorial(3):                                                  â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                            â”‚
â”‚  â”‚ factorial(1)=1  â”‚ â† top (se resuelve primero)               â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                            â”‚
â”‚  â”‚ factorial(2)    â”‚ waiting for factorial(1)                  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                            â”‚
â”‚  â”‚ factorial(3)    â”‚ waiting for factorial(2)                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                            â”‚
â”‚                                                                 â”‚
â”‚  Por eso recursiÃ³n infinita causa &quot;Stack Overflow&quot;             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>3. Queues {#3-queues}</h2>
<h3>3.1 ImplementaciÃ³n con Deque</h3>
<pre><code class="language-python">from collections import deque


class Queue(Generic[T]):
    &quot;&quot;&quot;Queue (FIFO) implementation using deque.

    Using deque for O(1) operations at both ends.
    Using list would make dequeue O(n).

    Example:
        &gt;&gt;&gt; q = Queue()
        &gt;&gt;&gt; q.enqueue(1)
        &gt;&gt;&gt; q.enqueue(2)
        &gt;&gt;&gt; q.dequeue()
        1
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self._items: deque[T] = deque()

    def is_empty(self) -&gt; bool:
        &quot;&quot;&quot;Check if queue is empty. O(1)&quot;&quot;&quot;
        return len(self._items) == 0

    def enqueue(self, item: T) -&gt; None:
        &quot;&quot;&quot;Add item to rear. O(1)&quot;&quot;&quot;
        self._items.append(item)

    def dequeue(self) -&gt; T:
        &quot;&quot;&quot;Remove and return front item. O(1)

        Raises:
            IndexError: If queue is empty.
        &quot;&quot;&quot;
        if self.is_empty():
            raise IndexError(&quot;Dequeue from empty queue&quot;)
        return self._items.popleft()

    def front(self) -&gt; T:
        &quot;&quot;&quot;Return front item without removing. O(1)&quot;&quot;&quot;
        if self.is_empty():
            raise IndexError(&quot;Front of empty queue&quot;)
        return self._items[0]

    def __len__(self) -&gt; int:
        return len(self._items)

    def __repr__(self) -&gt; str:
        return f&quot;Queue({list(self._items)})&quot;
</code></pre>
<h3>3.2 Queue con Lista (Ineficiente)</h3>
<pre><code class="language-python">class QueueWithList(Generic[T]):
    &quot;&quot;&quot;Queue using list - INEFFICIENT for demonstration.

    dequeue is O(n) because list.pop(0) shifts all elements.
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self._items: list[T] = []

    def enqueue(self, item: T) -&gt; None:
        &quot;&quot;&quot;O(1)&quot;&quot;&quot;
        self._items.append(item)

    def dequeue(self) -&gt; T:
        &quot;&quot;&quot;O(n) - BAD! All elements shift.&quot;&quot;&quot;
        if not self._items:
            raise IndexError(&quot;Dequeue from empty queue&quot;)
        return self._items.pop(0)  # O(n)!
</code></pre>
<h3>3.3 Aplicaciones de Queue</h3>
<pre><code class="language-python">def bfs_preview(graph: dict, start: str) -&gt; list[str]:
    &quot;&quot;&quot;BFS uses a queue - preview for Graphs module.

    Visit nodes level by level.
    &quot;&quot;&quot;
    visited = []
    queue: Queue[str] = Queue()
    queue.enqueue(start)

    while not queue.is_empty():
        node = queue.dequeue()
        if node not in visited:
            visited.append(node)
            for neighbor in graph.get(node, []):
                queue.enqueue(neighbor)

    return visited
</code></pre>
<hr />
<h2>4. ComparaciÃ³n y CuÃ¡ndo Usar {#4-comparacion}</h2>
<h3>4.1 Tabla Resumen</h3>
<table>
<thead>
<tr>
<th>Estructura</th>
<th>Orden</th>
<th>OperaciÃ³n Principal</th>
<th>Uso TÃ­pico</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stack</td>
<td>LIFO</td>
<td>push/pop</td>
<td>Undo, parsing, DFS</td>
</tr>
<tr>
<td>Queue</td>
<td>FIFO</td>
<td>enqueue/dequeue</td>
<td>BFS, scheduling</td>
</tr>
<tr>
<td>Linked List</td>
<td>Insertion order</td>
<td>insert/delete</td>
<td>Cuando muchas inserciones/deletes</td>
</tr>
</tbody>
</table>
<h3>4.2 CuÃ¡ndo Usar Cada Una</h3>
<pre><code>USA STACK cuando:
â€¢ Necesitas deshacer operaciones (undo)
â€¢ Parsear expresiones (parÃ©ntesis balanceados)
â€¢ Implementar DFS
â€¢ Convertir recursiÃ³n a iteraciÃ³n

USA QUEUE cuando:
â€¢ Procesar en orden de llegada
â€¢ Implementar BFS
â€¢ Buffer de datos (producer-consumer)
â€¢ Scheduling de tareas

USA LINKED LIST cuando:
â€¢ Muchas inserciones/eliminaciones al inicio
â€¢ No necesitas acceso por Ã­ndice
â€¢ TamaÃ±o muy variable
â€¢ Implementar otras estructuras
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes</h2>
<h3>Error 1: Usar list para Queue</h3>
<pre><code class="language-python"># âŒ O(n) para dequeue
queue = []
queue.append(item)      # O(1)
item = queue.pop(0)     # O(n)!

# âœ… O(1) con deque
from collections import deque
queue = deque()
queue.append(item)      # O(1)
item = queue.popleft()  # O(1)
</code></pre>
<h3>Error 2: No verificar vacÃ­o antes de pop/dequeue</h3>
<pre><code class="language-python"># âŒ Error si estÃ¡ vacÃ­a
def bad_pop(stack):
    return stack.pop()  # IndexError!

# âœ… Verificar primero
def good_pop(stack):
    if stack.is_empty():
        raise IndexError(&quot;Stack is empty&quot;)
    return stack.pop()
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 13.1: Implementar Stack</h3>
<p>Implementar Stack con operaciones push, pop, peek, is_empty.</p>
<h3>Ejercicio 13.2: ParÃ©ntesis Balanceados</h3>
<p>Usar stack para verificar <code>()[]{}</code> balanceados.</p>
<h3>Ejercicio 13.3: Implementar Queue</h3>
<p>Implementar Queue con deque.</p>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://visualgo.net/en/list">Visualgo Linked List</a></td>
<td>Visual</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://www.youtube.com/watch?v=wjI1WNcIntg">Stack vs Queue</a></td>
<td>Video</td>
<td>ğŸŸ¡ Recomendado</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ”— Referencias del Glosario</h2>
<ul>
<li><a href="#mod_GLOSARIO">Linked List</a></li>
<li><a href="#mod_GLOSARIO">Stack</a></li>
<li><a href="#mod_GLOSARIO">Queue</a></li>
<li><a href="#mod_GLOSARIO">LIFO</a></li>
<li><a href="#mod_GLOSARIO">FIFO</a></li>
</ul>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_12_PROYECTO_INTEGRADOR">12_PROYECTO_INTEGRADOR</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_14_TREES">14_TREES</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_14_TREES" class="cover-page">
            <a name="mod_14_TREES"></a>
            <div class="cover-title">14 - Trees y BST</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>14 - Ãrboles y Binary Search Trees</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Dominar Ã¡rboles binarios, BST y sus traversals - <strong>tema CRÃTICO del Pathway</strong>.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: El Ãrbol GenealÃ³gico</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   ÃRBOL = Estructura jerÃ¡rquica como Ã¡rbol genealÃ³gico                      â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                     â”‚
â”‚                                                                             â”‚
â”‚                        [Abuelo]           â† ROOT (raÃ­z)                     â”‚
â”‚                        /      \                                             â”‚
â”‚                   [Padre]    [TÃ­o]        â† INTERNAL NODES                  â”‚
â”‚                   /    \        \                                           â”‚
â”‚               [Hijo1] [Hijo2]  [Primo]    â† LEAVES (hojas)                  â”‚
â”‚                                                                             â”‚
â”‚   TÃ‰RMINOS:                                                                 â”‚
â”‚   â€¢ Root: Nodo sin padre (el de arriba)                                     â”‚
â”‚   â€¢ Parent/Child: RelaciÃ³n directa                                          â”‚
â”‚   â€¢ Siblings: Nodos con mismo padre                                         â”‚
â”‚   â€¢ Leaf: Nodo sin hijos                                                    â”‚
â”‚   â€¢ Height: Distancia mÃ¡xima desde root a hoja                              â”‚
â”‚   â€¢ Depth: Distancia desde root a un nodo                                   â”‚
â”‚                                                                             â”‚
â”‚   BINARY TREE = Cada nodo tiene mÃ¡ximo 2 hijos (left, right)                â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-binary-tree">Binary Tree BÃ¡sico</a></li>
<li><a href="#2-traversals">Traversals (Recorridos)</a></li>
<li><a href="#3-bst">Binary Search Tree (BST)</a></li>
<li><a href="#4-operaciones">Operaciones en BST</a></li>
<li><a href="#5-analisis">AnÃ¡lisis de Complejidad</a></li>
</ol>
<hr />
<h2>1. Binary Tree BÃ¡sico {#1-binary-tree}</h2>
<h3>1.1 Estructura del Nodo</h3>
<pre><code class="language-python">from typing import Generic, TypeVar, Optional

T = TypeVar('T')


class TreeNode(Generic[T]):
    &quot;&quot;&quot;A node in a binary tree.

    Attributes:
        value: Data stored in this node.
        left: Reference to left child (or None).
        right: Reference to right child (or None).
    &quot;&quot;&quot;

    def __init__(self, value: T) -&gt; None:
        self.value: T = value
        self.left: Optional[TreeNode[T]] = None
        self.right: Optional[TreeNode[T]] = None

    def __repr__(self) -&gt; str:
        return f&quot;TreeNode({self.value})&quot;

    def is_leaf(self) -&gt; bool:
        &quot;&quot;&quot;Check if node has no children.&quot;&quot;&quot;
        return self.left is None and self.right is None


class BinaryTree(Generic[T]):
    &quot;&quot;&quot;Basic binary tree structure.&quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self.root: Optional[TreeNode[T]] = None

    def is_empty(self) -&gt; bool:
        return self.root is None
</code></pre>
<h3>1.2 Construir un Ãrbol Manualmente</h3>
<pre><code class="language-python">#        10
#       /  \
#      5    15
#     / \   / \
#    3   7 12  20

root = TreeNode(10)
root.left = TreeNode(5)
root.right = TreeNode(15)
root.left.left = TreeNode(3)
root.left.right = TreeNode(7)
root.right.left = TreeNode(12)
root.right.right = TreeNode(20)
</code></pre>
<hr />
<h2>2. Traversals (Recorridos) {#2-traversals}</h2>
<h3>2.1 Los Tres Traversals DFS</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TRES FORMAS DE RECORRER UN ÃRBOL (DFS)                         â”‚
â”‚                                                                 â”‚
â”‚        1                                                        â”‚
â”‚       / \                                                       â”‚
â”‚      2   3                                                      â”‚
â”‚     / \                                                         â”‚
â”‚    4   5                                                        â”‚
â”‚                                                                 â”‚
â”‚  INORDER (Left, Root, Right):   4, 2, 5, 1, 3                   â”‚
â”‚  â†’ En BST: Â¡sale ORDENADO!                                      â”‚
â”‚                                                                 â”‚
â”‚  PREORDER (Root, Left, Right):  1, 2, 4, 5, 3                   â”‚
â”‚  â†’ Ãštil para copiar/serializar Ã¡rbol                            â”‚
â”‚                                                                 â”‚
â”‚  POSTORDER (Left, Right, Root): 4, 5, 2, 3, 1                   â”‚
â”‚  â†’ Ãštil para eliminar Ã¡rbol (hijos antes que padre)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>2.2 ImplementaciÃ³n Recursiva</h3>
<pre><code class="language-python">def inorder_recursive(node: Optional[TreeNode[T]]) -&gt; list[T]:
    &quot;&quot;&quot;Inorder traversal: Left, Root, Right.

    For BST, returns elements in sorted order.

    Time: O(n) - visit each node once
    Space: O(h) - recursion stack, h = height
    &quot;&quot;&quot;
    if node is None:
        return []

    result = []
    result.extend(inorder_recursive(node.left))
    result.append(node.value)
    result.extend(inorder_recursive(node.right))
    return result


def preorder_recursive(node: Optional[TreeNode[T]]) -&gt; list[T]:
    &quot;&quot;&quot;Preorder traversal: Root, Left, Right.&quot;&quot;&quot;
    if node is None:
        return []

    result = [node.value]
    result.extend(preorder_recursive(node.left))
    result.extend(preorder_recursive(node.right))
    return result


def postorder_recursive(node: Optional[TreeNode[T]]) -&gt; list[T]:
    &quot;&quot;&quot;Postorder traversal: Left, Right, Root.&quot;&quot;&quot;
    if node is None:
        return []

    result = []
    result.extend(postorder_recursive(node.left))
    result.extend(postorder_recursive(node.right))
    result.append(node.value)
    return result
</code></pre>
<h3>2.3 ImplementaciÃ³n Iterativa (con Stack)</h3>
<pre><code class="language-python">def inorder_iterative(root: Optional[TreeNode[T]]) -&gt; list[T]:
    &quot;&quot;&quot;Inorder using explicit stack instead of recursion.

    Important: Shows how recursion uses the call stack.
    &quot;&quot;&quot;
    result = []
    stack: list[TreeNode[T]] = []
    current = root

    while current is not None or stack:
        # Go as far left as possible
        while current is not None:
            stack.append(current)
            current = current.left

        # Process current node
        current = stack.pop()
        result.append(current.value)

        # Move to right subtree
        current = current.right

    return result


def preorder_iterative(root: Optional[TreeNode[T]]) -&gt; list[T]:
    &quot;&quot;&quot;Preorder using stack.&quot;&quot;&quot;
    if root is None:
        return []

    result = []
    stack = [root]

    while stack:
        node = stack.pop()
        result.append(node.value)

        # Push right first so left is processed first (LIFO)
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)

    return result
</code></pre>
<h3>2.4 Level Order (BFS)</h3>
<pre><code class="language-python">from collections import deque


def level_order(root: Optional[TreeNode[T]]) -&gt; list[list[T]]:
    &quot;&quot;&quot;Level order traversal using queue (BFS).

    Returns nodes level by level.

    Example:
        [1]
        [2, 3]
        [4, 5]
    &quot;&quot;&quot;
    if root is None:
        return []

    result = []
    queue = deque([root])

    while queue:
        level_size = len(queue)
        current_level = []

        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.value)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        result.append(current_level)

    return result
</code></pre>
<hr />
<h2>3. Binary Search Tree (BST) {#3-bst}</h2>
<h3>3.1 Propiedad del BST</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BST PROPERTY:                                                  â”‚
â”‚  Para cada nodo:                                                â”‚
â”‚  â€¢ Todos los valores en subÃ¡rbol izquierdo &lt; valor del nodo     â”‚
â”‚  â€¢ Todos los valores en subÃ¡rbol derecho &gt; valor del nodo       â”‚
â”‚                                                                 â”‚
â”‚  VÃLIDO BST:           INVÃLIDO BST:                            â”‚
â”‚        10                    10                                 â”‚
â”‚       /  \                  /  \                                â”‚
â”‚      5    15               5    15                              â”‚
â”‚     / \                   / \                                   â”‚
â”‚    3   7                 3   12  â† 12 &gt; 10 pero estÃ¡ en left!   â”‚
â”‚                                                                 â”‚
â”‚  BENEFICIO: BÃºsqueda O(log n) en promedio                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>3.2 ImplementaciÃ³n de BST</h3>
<pre><code class="language-python">class BST(Generic[T]):
    &quot;&quot;&quot;Binary Search Tree implementation.

    Maintains BST property: left &lt; root &lt; right.

    Average case complexities (balanced):
        - search: O(log n)
        - insert: O(log n)
        - delete: O(log n)

    Worst case (unbalanced/skewed):
        - All operations: O(n)
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self.root: Optional[TreeNode[T]] = None
        self._size: int = 0

    def __len__(self) -&gt; int:
        return self._size

    def is_empty(self) -&gt; bool:
        return self.root is None

    def insert(self, value: T) -&gt; None:
        &quot;&quot;&quot;Insert value maintaining BST property. O(h)&quot;&quot;&quot;
        self.root = self._insert_recursive(self.root, value)
        self._size += 1

    def _insert_recursive(
        self,
        node: Optional[TreeNode[T]],
        value: T
    ) -&gt; TreeNode[T]:
        &quot;&quot;&quot;Recursive helper for insert.&quot;&quot;&quot;
        if node is None:
            return TreeNode(value)

        if value &lt; node.value:
            node.left = self._insert_recursive(node.left, value)
        elif value &gt; node.value:
            node.right = self._insert_recursive(node.right, value)
        # If equal, we don't insert (no duplicates)

        return node

    def search(self, value: T) -&gt; bool:
        &quot;&quot;&quot;Search for value in BST. O(h)&quot;&quot;&quot;
        return self._search_recursive(self.root, value)

    def _search_recursive(
        self,
        node: Optional[TreeNode[T]],
        value: T
    ) -&gt; bool:
        &quot;&quot;&quot;Recursive helper for search.&quot;&quot;&quot;
        if node is None:
            return False

        if value == node.value:
            return True
        elif value &lt; node.value:
            return self._search_recursive(node.left, value)
        else:
            return self._search_recursive(node.right, value)

    def search_iterative(self, value: T) -&gt; bool:
        &quot;&quot;&quot;Iterative search - often preferred.&quot;&quot;&quot;
        current = self.root

        while current is not None:
            if value == current.value:
                return True
            elif value &lt; current.value:
                current = current.left
            else:
                current = current.right

        return False

    def find_min(self) -&gt; Optional[T]:
        &quot;&quot;&quot;Find minimum value. O(h)&quot;&quot;&quot;
        if self.root is None:
            return None

        current = self.root
        while current.left is not None:
            current = current.left
        return current.value

    def find_max(self) -&gt; Optional[T]:
        &quot;&quot;&quot;Find maximum value. O(h)&quot;&quot;&quot;
        if self.root is None:
            return None

        current = self.root
        while current.right is not None:
            current = current.right
        return current.value

    def inorder(self) -&gt; list[T]:
        &quot;&quot;&quot;Return sorted list of all values.&quot;&quot;&quot;
        return inorder_recursive(self.root)
</code></pre>
<hr />
<h2>4. Operaciones en BST {#4-operaciones}</h2>
<h3>4.1 Delete (La MÃ¡s Compleja)</h3>
<pre><code class="language-python">def delete(self, value: T) -&gt; None:
    &quot;&quot;&quot;Delete value from BST. O(h)

    Three cases:
    1. Leaf node: just remove
    2. One child: replace with child
    3. Two children: replace with inorder successor
    &quot;&quot;&quot;
    self.root = self._delete_recursive(self.root, value)

def _delete_recursive(
    self,
    node: Optional[TreeNode[T]],
    value: T
) -&gt; Optional[TreeNode[T]]:
    &quot;&quot;&quot;Recursive helper for delete.&quot;&quot;&quot;
    if node is None:
        return None

    if value &lt; node.value:
        node.left = self._delete_recursive(node.left, value)
    elif value &gt; node.value:
        node.right = self._delete_recursive(node.right, value)
    else:
        # Found node to delete

        # Case 1: Leaf node
        if node.left is None and node.right is None:
            self._size -= 1
            return None

        # Case 2: One child
        if node.left is None:
            self._size -= 1
            return node.right
        if node.right is None:
            self._size -= 1
            return node.left

        # Case 3: Two children
        # Find inorder successor (smallest in right subtree)
        successor = self._find_min_node(node.right)
        node.value = successor.value
        node.right = self._delete_recursive(node.right, successor.value)

    return node

def _find_min_node(self, node: TreeNode[T]) -&gt; TreeNode[T]:
    &quot;&quot;&quot;Find node with minimum value in subtree.&quot;&quot;&quot;
    current = node
    while current.left is not None:
        current = current.left
    return current
</code></pre>
<h3>4.2 Validar si es BST</h3>
<pre><code class="language-python">def is_valid_bst(root: Optional[TreeNode[int]]) -&gt; bool:
    &quot;&quot;&quot;Check if tree is valid BST.

    Uses inorder traversal: should be sorted.
    &quot;&quot;&quot;
    def inorder(node: Optional[TreeNode[int]]) -&gt; list[int]:
        if node is None:
            return []
        return inorder(node.left) + [node.value] + inorder(node.right)

    values = inorder(root)

    # Check if sorted
    for i in range(len(values) - 1):
        if values[i] &gt;= values[i + 1]:
            return False
    return True


def is_valid_bst_efficient(
    root: Optional[TreeNode[int]],
    min_val: float = float('-inf'),
    max_val: float = float('inf')
) -&gt; bool:
    &quot;&quot;&quot;Check BST validity with range checking. O(n) time, O(h) space.&quot;&quot;&quot;
    if root is None:
        return True

    if root.value &lt;= min_val or root.value &gt;= max_val:
        return False

    return (
        is_valid_bst_efficient(root.left, min_val, root.value) and
        is_valid_bst_efficient(root.right, root.value, max_val)
    )
</code></pre>
<hr />
<h2>5. AnÃ¡lisis de Complejidad {#5-analisis}</h2>
<h3>5.1 Complejidades</h3>
<table>
<thead>
<tr>
<th>OperaciÃ³n</th>
<th>Balanced BST</th>
<th>Skewed BST</th>
</tr>
</thead>
<tbody>
<tr>
<td>Search</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Insert</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Delete</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Traversal</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Min/Max</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<h3>5.2 Por QuÃ© se Desbalancea</h3>
<pre><code>Insertar 1, 2, 3, 4, 5 en orden:

    1
     \
      2
       \
        3
         \
          4
           \
            5

â†’ Se convierte en linked list â†’ O(n) para todo
â†’ SoluciÃ³n: Ãrboles balanceados (AVL, Red-Black)
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes</h2>
<h3>Error 1: Confundir traversals</h3>
<pre><code class="language-python"># Memorizar: &quot;Inorder = In order&quot; (para BST)
# Inorder de BST siempre da elementos ORDENADOS
</code></pre>
<h3>Error 2: No manejar caso vacÃ­o</h3>
<pre><code class="language-python"># âŒ
def find_min(root):
    while root.left:  # AttributeError si root es None
        root = root.left

# âœ…
def find_min(root):
    if root is None:
        return None
    while root.left:
        root = root.left
    return root.value
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 14.1: Implementar BST con insert y search</h3>
<h3>Ejercicio 14.2: Implementar los 3 traversals</h3>
<h3>Ejercicio 14.3: Validar si Ã¡rbol es BST</h3>
<h3>Ejercicio 14.4: Encontrar altura del Ã¡rbol</h3>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://visualgo.net/en/bst">Visualgo BST</a></td>
<td>Visual</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://www.youtube.com/watch?v=qH6yxkw0u78">Abdul Bari Trees</a></td>
<td>Video</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_13_LINKED_LISTS_STACKS_QUEUES">13_LINKED_LISTS</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_15_GRAPHS">15_GRAPHS</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_15_GRAPHS" class="cover-page">
            <a name="mod_15_GRAPHS"></a>
            <div class="cover-title">15 - Graphs, BFS, DFS</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>15 - Grafos, BFS y DFS</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Dominar grafos y sus algoritmos de recorrido - <strong>tema CRÃTICO del Pathway</strong>.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: Mapa de Ciudades y Carreteras</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   GRAFO = RED DE CONEXIONES                                                 â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                 â”‚
â”‚                                                                             â”‚
â”‚   Ciudades = NODOS (vertices)                                               â”‚
â”‚   Carreteras = ARISTAS (edges)                                              â”‚
â”‚                                                                             â”‚
â”‚       [A]â”€â”€â”€â”€â”€â”€â”€[B]                                                         â”‚
â”‚        â”‚ \       â”‚                                                          â”‚
â”‚        â”‚  \      â”‚                                                          â”‚
â”‚        â”‚   \     â”‚                                                          â”‚
â”‚       [C]â”€â”€â”€[D]â”€â”€[E]                                                        â”‚
â”‚                                                                             â”‚
â”‚   TIPOS:                                                                    â”‚
â”‚   â€¢ Dirigido: calles de un solo sentido (Aâ†’B no implica Bâ†’A)                â”‚
â”‚   â€¢ No dirigido: calles de dos sentidos (Aâ†”B)                               â”‚
â”‚   â€¢ Ponderado: carreteras con distancias/costos                             â”‚
â”‚   â€¢ No ponderado: todas las conexiones iguales                              â”‚
â”‚                                                                             â”‚
â”‚   BFS = Explorar por NIVELES (cÃ­rculos concÃ©ntricos)                        â”‚
â”‚   DFS = Explorar PROFUNDO primero (ir hasta el fondo, luego volver)         â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-representacion">RepresentaciÃ³n de Grafos</a></li>
<li><a href="#2-bfs">BFS (Breadth-First Search)</a></li>
<li><a href="#3-dfs">DFS (Depth-First Search)</a></li>
<li><a href="#4-aplicaciones">Aplicaciones Comunes</a></li>
<li><a href="#5-comparacion">ComparaciÃ³n BFS vs DFS</a></li>
</ol>
<hr />
<h2>1. RepresentaciÃ³n de Grafos {#1-representacion}</h2>
<h3>1.1 Adjacency List (Lista de Adyacencia)</h3>
<pre><code class="language-python">from collections import defaultdict
from typing import TypeVar, Generic

T = TypeVar('T')


class Graph(Generic[T]):
    &quot;&quot;&quot;Unweighted graph using adjacency list.

    Most common representation. Good for sparse graphs.
    Space: O(V + E)
    &quot;&quot;&quot;

    def __init__(self, directed: bool = False) -&gt; None:
        self.adjacency: dict[T, list[T]] = defaultdict(list)
        self.directed = directed

    def add_vertex(self, vertex: T) -&gt; None:
        &quot;&quot;&quot;Add vertex without edges.&quot;&quot;&quot;
        if vertex not in self.adjacency:
            self.adjacency[vertex] = []

    def add_edge(self, source: T, destination: T) -&gt; None:
        &quot;&quot;&quot;Add edge between vertices.

        For undirected graph, adds both directions.
        &quot;&quot;&quot;
        self.adjacency[source].append(destination)

        if not self.directed:
            self.adjacency[destination].append(source)

    def get_neighbors(self, vertex: T) -&gt; list[T]:
        &quot;&quot;&quot;Get all neighbors of a vertex.&quot;&quot;&quot;
        return self.adjacency.get(vertex, [])

    def get_vertices(self) -&gt; list[T]:
        &quot;&quot;&quot;Get all vertices.&quot;&quot;&quot;
        return list(self.adjacency.keys())

    def __repr__(self) -&gt; str:
        return f&quot;Graph({dict(self.adjacency)})&quot;


# Ejemplo de uso
graph = Graph[str](directed=False)
graph.add_edge(&quot;A&quot;, &quot;B&quot;)
graph.add_edge(&quot;A&quot;, &quot;C&quot;)
graph.add_edge(&quot;B&quot;, &quot;D&quot;)
graph.add_edge(&quot;C&quot;, &quot;D&quot;)
print(graph.get_neighbors(&quot;A&quot;))  # ['B', 'C']
</code></pre>
<h3>1.2 Adjacency Matrix (Matriz de Adyacencia)</h3>
<pre><code class="language-python">class GraphMatrix:
    &quot;&quot;&quot;Graph using adjacency matrix.

    Good for dense graphs or when need O(1) edge lookup.
    Space: O(VÂ²)
    &quot;&quot;&quot;

    def __init__(self, num_vertices: int) -&gt; None:
        self.num_vertices = num_vertices
        # matrix[i][j] = 1 if edge from i to j
        self.matrix: list[list[int]] = [
            [0] * num_vertices for _ in range(num_vertices)
        ]

    def add_edge(self, source: int, dest: int) -&gt; None:
        &quot;&quot;&quot;Add edge (undirected).&quot;&quot;&quot;
        self.matrix[source][dest] = 1
        self.matrix[dest][source] = 1

    def has_edge(self, source: int, dest: int) -&gt; bool:
        &quot;&quot;&quot;Check if edge exists. O(1)&quot;&quot;&quot;
        return self.matrix[source][dest] == 1

    def get_neighbors(self, vertex: int) -&gt; list[int]:
        &quot;&quot;&quot;Get neighbors. O(V)&quot;&quot;&quot;
        return [i for i, val in enumerate(self.matrix[vertex]) if val == 1]
</code></pre>
<h3>1.3 CuÃ¡ndo Usar Cada RepresentaciÃ³n</h3>
<table>
<thead>
<tr>
<th>OperaciÃ³n</th>
<th>Adj List</th>
<th>Adj Matrix</th>
</tr>
</thead>
<tbody>
<tr>
<td>Space</td>
<td>O(V + E)</td>
<td>O(VÂ²)</td>
</tr>
<tr>
<td>Check edge</td>
<td>O(degree)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Get neighbors</td>
<td>O(1)</td>
<td>O(V)</td>
</tr>
<tr>
<td>Add edge</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>Mejor para</strong></td>
<td>Sparse graphs</td>
<td>Dense graphs</td>
</tr>
</tbody>
</table>
<hr />
<h2>2. BFS (Breadth-First Search) {#2-bfs}</h2>
<h3>2.1 Concepto</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BFS = Buscar por NIVELES (como ondas en el agua)               â”‚
â”‚                                                                 â”‚
â”‚  Desde A:                                                       â”‚
â”‚       [A]â”€â”€â”€[B]â”€â”€â”€[D]                                           â”‚
â”‚        â”‚     â”‚                                                  â”‚
â”‚       [C]â”€â”€â”€[E]                                                 â”‚
â”‚                                                                 â”‚
â”‚  Nivel 0: A                                                     â”‚
â”‚  Nivel 1: B, C (vecinos de A)                                   â”‚
â”‚  Nivel 2: D, E (vecinos de B y C no visitados)                  â”‚
â”‚                                                                 â”‚
â”‚  ORDEN DE VISITA: A â†’ B â†’ C â†’ D â†’ E                             â”‚
â”‚                                                                 â”‚
â”‚  USA QUEUE (FIFO) para procesar en orden de llegada             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>2.2 ImplementaciÃ³n</h3>
<pre><code class="language-python">from collections import deque


def bfs(graph: Graph[T], start: T) -&gt; list[T]:
    &quot;&quot;&quot;Breadth-First Search traversal.

    Visits nodes level by level using a queue.

    Args:
        graph: The graph to traverse.
        start: Starting vertex.

    Returns:
        List of vertices in BFS order.

    Time: O(V + E)
    Space: O(V) for visited set and queue
    &quot;&quot;&quot;
    visited: set[T] = set()
    result: list[T] = []
    queue: deque[T] = deque([start])

    visited.add(start)

    while queue:
        vertex = queue.popleft()  # FIFO
        result.append(vertex)

        for neighbor in graph.get_neighbors(vertex):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    return result


def bfs_with_levels(graph: Graph[T], start: T) -&gt; list[list[T]]:
    &quot;&quot;&quot;BFS that returns nodes grouped by level.&quot;&quot;&quot;
    visited: set[T] = set()
    levels: list[list[T]] = []
    queue: deque[T] = deque([start])

    visited.add(start)

    while queue:
        level_size = len(queue)
        current_level: list[T] = []

        for _ in range(level_size):
            vertex = queue.popleft()
            current_level.append(vertex)

            for neighbor in graph.get_neighbors(vertex):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)

        levels.append(current_level)

    return levels
</code></pre>
<h3>2.3 Shortest Path (Unweighted)</h3>
<pre><code class="language-python">def shortest_path_bfs(
    graph: Graph[T],
    start: T,
    end: T
) -&gt; list[T] | None:
    &quot;&quot;&quot;Find shortest path in unweighted graph.

    BFS guarantees shortest path in unweighted graphs
    because it explores level by level.

    Returns:
        List of vertices from start to end, or None if no path.
    &quot;&quot;&quot;
    if start == end:
        return [start]

    visited: set[T] = set()
    queue: deque[tuple[T, list[T]]] = deque([(start, [start])])
    visited.add(start)

    while queue:
        vertex, path = queue.popleft()

        for neighbor in graph.get_neighbors(vertex):
            if neighbor == end:
                return path + [neighbor]

            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))

    return None  # No path found
</code></pre>
<hr />
<h2>3. DFS (Depth-First Search) {#3-dfs}</h2>
<h3>3.1 Concepto</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  DFS = Ir lo mÃ¡s PROFUNDO posible, luego retroceder             â”‚
â”‚                                                                 â”‚
â”‚  Desde A:                                                       â”‚
â”‚       [A]â”€â”€â”€[B]â”€â”€â”€[D]                                           â”‚
â”‚        â”‚     â”‚                                                  â”‚
â”‚       [C]â”€â”€â”€[E]                                                 â”‚
â”‚                                                                 â”‚
â”‚  Camino: A â†’ B â†’ D (fondo!) â†’ back â†’ E â†’ back â†’ C               â”‚
â”‚                                                                 â”‚
â”‚  ORDEN DE VISITA: A â†’ B â†’ D â†’ E â†’ C                             â”‚
â”‚  (puede variar segÃºn orden de vecinos)                          â”‚
â”‚                                                                 â”‚
â”‚  USA STACK (LIFO) o RECURSIÃ“N                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>3.2 ImplementaciÃ³n Recursiva</h3>
<pre><code class="language-python">def dfs_recursive(graph: Graph[T], start: T) -&gt; list[T]:
    &quot;&quot;&quot;Depth-First Search using recursion.

    Time: O(V + E)
    Space: O(V) for visited + O(V) for call stack
    &quot;&quot;&quot;
    visited: set[T] = set()
    result: list[T] = []

    def _dfs(vertex: T) -&gt; None:
        visited.add(vertex)
        result.append(vertex)

        for neighbor in graph.get_neighbors(vertex):
            if neighbor not in visited:
                _dfs(neighbor)

    _dfs(start)
    return result
</code></pre>
<h3>3.3 ImplementaciÃ³n Iterativa (con Stack)</h3>
<pre><code class="language-python">def dfs_iterative(graph: Graph[T], start: T) -&gt; list[T]:
    &quot;&quot;&quot;Depth-First Search using explicit stack.

    Avoids recursion limit issues for large graphs.

    Note: Order may differ slightly from recursive
    due to stack vs recursion mechanics.
    &quot;&quot;&quot;
    visited: set[T] = set()
    result: list[T] = []
    stack: list[T] = [start]

    while stack:
        vertex = stack.pop()  # LIFO

        if vertex not in visited:
            visited.add(vertex)
            result.append(vertex)

            # Add neighbors to stack (reverse for same order as recursive)
            for neighbor in reversed(graph.get_neighbors(vertex)):
                if neighbor not in visited:
                    stack.append(neighbor)

    return result
</code></pre>
<h3>3.4 Detectar Ciclos con DFS</h3>
<pre><code class="language-python">def has_cycle_undirected(graph: Graph[T]) -&gt; bool:
    &quot;&quot;&quot;Detect cycle in undirected graph using DFS.&quot;&quot;&quot;
    visited: set[T] = set()

    def _dfs(vertex: T, parent: T | None) -&gt; bool:
        visited.add(vertex)

        for neighbor in graph.get_neighbors(vertex):
            if neighbor not in visited:
                if _dfs(neighbor, vertex):
                    return True
            elif neighbor != parent:
                # Found visited node that's not parent = cycle
                return True

        return False

    # Check all components (graph may be disconnected)
    for vertex in graph.get_vertices():
        if vertex not in visited:
            if _dfs(vertex, None):
                return True

    return False
</code></pre>
<hr />
<h2>4. Aplicaciones Comunes {#4-aplicaciones}</h2>
<h3>4.1 Encontrar Todos los Caminos</h3>
<pre><code class="language-python">def find_all_paths(
    graph: Graph[T],
    start: T,
    end: T
) -&gt; list[list[T]]:
    &quot;&quot;&quot;Find all paths from start to end using DFS.&quot;&quot;&quot;
    all_paths: list[list[T]] = []

    def _dfs(vertex: T, path: list[T]) -&gt; None:
        if vertex == end:
            all_paths.append(path.copy())
            return

        for neighbor in graph.get_neighbors(vertex):
            if neighbor not in path:  # Avoid cycles
                path.append(neighbor)
                _dfs(neighbor, path)
                path.pop()  # Backtrack

    _dfs(start, [start])
    return all_paths
</code></pre>
<h3>4.2 Componentes Conexos</h3>
<pre><code class="language-python">def count_connected_components(graph: Graph[T]) -&gt; int:
    &quot;&quot;&quot;Count number of connected components.&quot;&quot;&quot;
    visited: set[T] = set()
    count = 0

    for vertex in graph.get_vertices():
        if vertex not in visited:
            # BFS/DFS from this vertex marks all reachable
            bfs_mark_visited(graph, vertex, visited)
            count += 1

    return count


def bfs_mark_visited(
    graph: Graph[T],
    start: T,
    visited: set[T]
) -&gt; None:
    &quot;&quot;&quot;Mark all reachable vertices as visited.&quot;&quot;&quot;
    queue: deque[T] = deque([start])
    visited.add(start)

    while queue:
        vertex = queue.popleft()
        for neighbor in graph.get_neighbors(vertex):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
</code></pre>
<hr />
<h2>5. ComparaciÃ³n BFS vs DFS {#5-comparacion}</h2>
<h3>5.1 CuÃ¡ndo Usar Cada Uno</h3>
<table>
<thead>
<tr>
<th>Aspecto</th>
<th>BFS</th>
<th>DFS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Estructura</td>
<td>Queue</td>
<td>Stack/RecursiÃ³n</td>
</tr>
<tr>
<td>Explora</td>
<td>Por niveles</td>
<td>Por profundidad</td>
</tr>
<tr>
<td>Shortest Path</td>
<td>âœ… Garantizado*</td>
<td>âŒ No garantizado</td>
</tr>
<tr>
<td>Memoria</td>
<td>O(ancho del grafo)</td>
<td>O(profundidad)</td>
</tr>
<tr>
<td>Grafos anchos</td>
<td>âŒ Mucha memoria</td>
<td>âœ… Mejor</td>
</tr>
<tr>
<td>Grafos profundos</td>
<td>âœ… Mejor</td>
<td>âŒ Stack overflow</td>
</tr>
</tbody>
</table>
<p>* Solo para grafos no ponderados</p>
<h3>5.2 Resumen de Uso</h3>
<pre><code>USA BFS cuando:
â€¢ Necesitas shortest path (no ponderado)
â€¢ Explorar por niveles
â€¢ Grafos muy profundos (evita stack overflow)

USA DFS cuando:
â€¢ Necesitas explorar todos los caminos
â€¢ Detectar ciclos
â€¢ Topological sort
â€¢ Grafos muy anchos (menos memoria)
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes</h2>
<h3>Error 1: Olvidar marcar como visitado ANTES de agregar a queue/stack</h3>
<pre><code class="language-python"># âŒ Puede agregar mismo nodo mÃºltiples veces
if neighbor not in visited:
    queue.append(neighbor)
    # visited.add(neighbor)  # Â¡Falta!

# âœ… Marcar inmediatamente
if neighbor not in visited:
    visited.add(neighbor)  # Antes de agregar
    queue.append(neighbor)
</code></pre>
<h3>Error 2: No manejar grafos desconectados</h3>
<pre><code class="language-python"># âŒ Solo visita un componente
def bfs_bad(graph, start):
    # Solo desde start...

# âœ… Iterar sobre todos los vÃ©rtices
def bfs_all(graph):
    visited = set()
    for vertex in graph.get_vertices():
        if vertex not in visited:
            bfs(graph, vertex)  # Visita este componente
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 15.1: Implementar BFS</h3>
<h3>Ejercicio 15.2: Implementar DFS recursivo e iterativo</h3>
<h3>Ejercicio 15.3: Shortest path con BFS</h3>
<h3>Ejercicio 15.4: Detectar ciclo en grafo</h3>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://visualgo.net/en/dfsbfs">Visualgo Graph</a></td>
<td>Visual</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://www.youtube.com/watch?v=pcKY4hjDrxk">Abdul Bari BFS/DFS</a></td>
<td>Video</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_14_TREES">14_TREES</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_16_DYNAMIC_PROGRAMMING">16_DYNAMIC_PROGRAMMING</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_07_RECURSION" class="cover-page">
            <a name="mod_07_RECURSION"></a>
            <div class="cover-title">07 - RecursiÃ³n</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>07 - RecursiÃ³n y Divide &amp; Conquer</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Dominar el pensamiento recursivo como base para implementar QuickSort y otros algoritmos fundamentales.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: Las MuÃ±ecas Rusas (Matryoshkas)</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   RECURSIÃ“N = Resolver un problema resolviÃ©ndolo para una versiÃ³n menor     â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚                                                                             â”‚
â”‚   MuÃ±ecas Rusas:                                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                       â”‚
â”‚   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚                                                       â”‚
â”‚   â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚                                                       â”‚
â”‚   â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚                                                       â”‚
â”‚   â”‚ â”‚ â”‚ â”‚ â—   â”‚ â”‚ â”‚ â”‚  â† Caso base: la muÃ±eca mÃ¡s pequeÃ±a (sÃ³lida)          â”‚
â”‚   â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚                                                       â”‚
â”‚   â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚  â† Cada muÃ±eca &quot;contiene&quot; una versiÃ³n menor           â”‚
â”‚   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚                                                       â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                       â”‚
â”‚                                                                             â”‚
â”‚   Para abrir TODAS las muÃ±ecas:                                             â”‚
â”‚   1. Â¿Es la muÃ±eca sÃ³lida? â†’ PARAR (caso base)                              â”‚
â”‚   2. Si no, abrir esta muÃ±eca y REPETIR con la de adentro                   â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-que-es">Â¿QuÃ© es RecursiÃ³n?</a></li>
<li><a href="#2-casos">Caso Base y Caso Recursivo</a></li>
<li><a href="#3-call-stack">El Call Stack</a></li>
<li><a href="#4-ejemplos">Ejemplos ClÃ¡sicos</a></li>
<li><a href="#5-divide-conquer">Divide &amp; Conquer</a></li>
<li><a href="#6-memoization">OptimizaciÃ³n con Memoization</a></li>
</ol>
<hr />
<h2>1. Â¿QuÃ© es RecursiÃ³n? {#1-que-es}</h2>
<h3>1.1 DefiniciÃ³n</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  RECURSIÃ“N: Una funciÃ³n que se llama a sÃ­ misma                 â”‚
â”‚                                                                 â”‚
â”‚  def funcion():                                                 â”‚
â”‚      ...                                                        â”‚
â”‚      funcion()  â† Se llama a sÃ­ misma                           â”‚
â”‚      ...                                                        â”‚
â”‚                                                                 â”‚
â”‚  âš ï¸ Sin condiciÃ³n de parada â†’ recursiÃ³n infinita â†’ crash        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>1.2 Â¿Por QuÃ© Usar RecursiÃ³n?</h3>
<pre><code>PROBLEMAS NATURALMENTE RECURSIVOS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Estructuras de datos recursivas
   - Ãrboles: un nodo tiene hijos que son Ã¡rboles
   - Listas enlazadas: una lista es un nodo + otra lista
   - Sistemas de archivos: carpetas contienen carpetas

2. Problemas que se reducen a versiones menores
   - Factorial: n! = n Ã— (n-1)!
   - Fibonacci: fib(n) = fib(n-1) + fib(n-2)
   - Ordenamiento: ordenar lista = ordenar sublistas + combinar
</code></pre>
<hr />
<h2>2. Caso Base y Caso Recursivo {#2-casos}</h2>
<h3>2.1 Los Dos Ingredientes Esenciales</h3>
<pre><code class="language-python">def recursive_function(problem):
    # 1. CASO BASE: problema tan pequeÃ±o que se resuelve directamente
    if problem_is_trivial(problem):
        return trivial_solution

    # 2. CASO RECURSIVO: reducir el problema y llamar recursivamente
    smaller_problem = reduce(problem)
    return combine(recursive_function(smaller_problem))
</code></pre>
<h3>2.2 Ejemplo: Factorial</h3>
<pre><code class="language-python">def factorial(n: int) -&gt; int:
    &quot;&quot;&quot;Calculate n! = n Ã— (n-1) Ã— (n-2) Ã— ... Ã— 1

    Base case: 0! = 1
    Recursive: n! = n Ã— (n-1)!

    Example:
        &gt;&gt;&gt; factorial(5)
        120  # 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1
    &quot;&quot;&quot;
    # Caso base
    if n &lt;= 1:
        return 1

    # Caso recursivo
    return n * factorial(n - 1)


# Traza de ejecuciÃ³n:
# factorial(4)
#   â†’ 4 * factorial(3)
#       â†’ 3 * factorial(2)
#           â†’ 2 * factorial(1)
#               â†’ 1  (caso base)
#           â†’ 2 * 1 = 2
#       â†’ 3 * 2 = 6
#   â†’ 4 * 6 = 24
</code></pre>
<h3>2.3 Ejemplo: Suma de Lista</h3>
<pre><code class="language-python">def sum_list(numbers: list[int]) -&gt; int:
    &quot;&quot;&quot;Sum all numbers in list using recursion.

    Base case: empty list â†’ 0
    Recursive: sum = first + sum(rest)

    Example:
        &gt;&gt;&gt; sum_list([1, 2, 3, 4])
        10
    &quot;&quot;&quot;
    # Caso base: lista vacÃ­a
    if not numbers:
        return 0

    # Caso recursivo: primer elemento + suma del resto
    return numbers[0] + sum_list(numbers[1:])


# Alternativa mÃ¡s eficiente (evita crear sublistas)
def sum_list_efficient(numbers: list[int], index: int = 0) -&gt; int:
    &quot;&quot;&quot;Sum using index instead of slicing.&quot;&quot;&quot;
    # Caso base: Ã­ndice fuera de rango
    if index &gt;= len(numbers):
        return 0

    # Caso recursivo
    return numbers[index] + sum_list_efficient(numbers, index + 1)
</code></pre>
<hr />
<h2>3. El Call Stack {#3-call-stack}</h2>
<h3>3.1 VisualizaciÃ³n del Stack</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CALL STACK: Pila de llamadas a funciones                       â”‚
â”‚                                                                 â”‚
â”‚  Cada llamada recursiva agrega un &quot;frame&quot; al stack              â”‚
â”‚  Cuando termina, se &quot;desapila&quot; y retorna al anterior            â”‚
â”‚                                                                 â”‚
â”‚  factorial(4):                                                  â”‚
â”‚                                                                 â”‚
â”‚  LLAMANDO (stack crece â†’)          RETORNANDO (stack decrece â†) â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ factorial(1) = 1 â”‚ â†base       â”‚ factorial(1) = 1 â”‚ â†’return  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”‚
â”‚  â”‚ factorial(2)     â”‚              â”‚ factorial(2) = 2 â”‚ â†’return â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”‚
â”‚  â”‚ factorial(3)     â”‚              â”‚ factorial(3) = 6 â”‚ â†’return â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”‚
â”‚  â”‚ factorial(4)     â”‚              â”‚ factorial(4) = 24â”‚ â†’return â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>3.2 LÃ­mite de RecursiÃ³n</h3>
<pre><code class="language-python">import sys

# Python tiene un lÃ­mite por defecto
print(sys.getrecursionlimit())  # 1000 (tÃ­picamente)

# Excederlo causa RecursionError
def infinite_recursion():
    return infinite_recursion()

# infinite_recursion()  # RecursionError: maximum recursion depth exceeded

# Puedes aumentar el lÃ­mite (con cuidado)
sys.setrecursionlimit(2000)
</code></pre>
<h3>3.3 Visualizar la RecursiÃ³n</h3>
<pre><code class="language-python">def factorial_verbose(n: int, depth: int = 0) -&gt; int:
    &quot;&quot;&quot;Factorial with execution trace.&quot;&quot;&quot;
    indent = &quot;  &quot; * depth
    print(f&quot;{indent}factorial({n})&quot;)

    if n &lt;= 1:
        print(f&quot;{indent}â†’ returning 1 (base case)&quot;)
        return 1

    result = n * factorial_verbose(n - 1, depth + 1)
    print(f&quot;{indent}â†’ returning {n} * ... = {result}&quot;)
    return result

# factorial_verbose(4) muestra:
# factorial(4)
#   factorial(3)
#     factorial(2)
#       factorial(1)
#       â†’ returning 1 (base case)
#     â†’ returning 2 * ... = 2
#   â†’ returning 3 * ... = 6
# â†’ returning 4 * ... = 24
</code></pre>
<hr />
<h2>4. Ejemplos ClÃ¡sicos {#4-ejemplos}</h2>
<h3>4.1 Fibonacci</h3>
<pre><code class="language-python">def fibonacci(n: int) -&gt; int:
    &quot;&quot;&quot;Calculate nth Fibonacci number.

    Sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, ...

    Base cases: fib(0) = 0, fib(1) = 1
    Recursive: fib(n) = fib(n-1) + fib(n-2)

    âš ï¸ This naive version is O(2^n) - very slow!
    See memoization section for optimization.
    &quot;&quot;&quot;
    if n &lt;= 0:
        return 0
    if n == 1:
        return 1

    return fibonacci(n - 1) + fibonacci(n - 2)
</code></pre>
<h3>4.2 BÃºsqueda en Lista</h3>
<pre><code class="language-python">def search_recursive(
    items: list[any],
    target: any,
    index: int = 0
) -&gt; int:
    &quot;&quot;&quot;Search for target in list, return index or -1.

    Base cases:
    - Index out of bounds â†’ not found (-1)
    - Found target â†’ return index

    Recursive: check next index
    &quot;&quot;&quot;
    # Caso base: fin de lista
    if index &gt;= len(items):
        return -1

    # Caso base: encontrado
    if items[index] == target:
        return index

    # Caso recursivo: buscar en el resto
    return search_recursive(items, target, index + 1)
</code></pre>
<h3>4.3 Contar Ocurrencias</h3>
<pre><code class="language-python">def count_occurrences(items: list[any], target: any) -&gt; int:
    &quot;&quot;&quot;Count how many times target appears in list.

    Base case: empty list â†’ 0
    Recursive: (1 if first matches else 0) + count(rest)
    &quot;&quot;&quot;
    if not items:
        return 0

    first_match = 1 if items[0] == target else 0
    return first_match + count_occurrences(items[1:], target)
</code></pre>
<h3>4.4 Invertir String</h3>
<pre><code class="language-python">def reverse_string(s: str) -&gt; str:
    &quot;&quot;&quot;Reverse a string recursively.

    Base case: empty or single char â†’ return as is
    Recursive: last char + reverse(rest)

    Example:
        &gt;&gt;&gt; reverse_string(&quot;hello&quot;)
        'olleh'
    &quot;&quot;&quot;
    if len(s) &lt;= 1:
        return s

    return s[-1] + reverse_string(s[:-1])
</code></pre>
<h3>4.5 PalÃ­ndromo</h3>
<pre><code class="language-python">def is_palindrome(s: str) -&gt; bool:
    &quot;&quot;&quot;Check if string is a palindrome.

    Base cases:
    - Length 0 or 1 â†’ True
    - First != Last â†’ False

    Recursive: check first == last, then inner string

    Example:
        &gt;&gt;&gt; is_palindrome(&quot;radar&quot;)
        True
    &quot;&quot;&quot;
    # Normalizar: quitar espacios y minÃºsculas
    s = s.lower().replace(&quot; &quot;, &quot;&quot;)

    if len(s) &lt;= 1:
        return True

    if s[0] != s[-1]:
        return False

    return is_palindrome(s[1:-1])
</code></pre>
<hr />
<h2>5. Divide &amp; Conquer {#5-divide-conquer}</h2>
<h3>5.1 El PatrÃ³n</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  DIVIDE &amp; CONQUER (Divide y VencerÃ¡s)                           â”‚
â”‚                                                                 â”‚
â”‚  1. DIVIDIR: Partir el problema en subproblemas mÃ¡s pequeÃ±os    â”‚
â”‚  2. CONQUISTAR: Resolver cada subproblema (recursivamente)      â”‚
â”‚  3. COMBINAR: Unir las soluciones parciales                     â”‚
â”‚                                                                 â”‚
â”‚  Ejemplos clÃ¡sicos:                                             â”‚
â”‚  - MergeSort: dividir lista, ordenar mitades, combinar          â”‚
â”‚  - QuickSort: particionar, ordenar particiones                  â”‚
â”‚  - Binary Search: buscar en mitad correcta                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>5.2 Merge Sort (Ejemplo Perfecto)</h3>
<pre><code class="language-python">def merge_sort(items: list[int]) -&gt; list[int]:
    &quot;&quot;&quot;Sort list using merge sort algorithm.

    Divide: split list in half
    Conquer: recursively sort each half
    Combine: merge sorted halves

    Complexity: O(n log n) always
    &quot;&quot;&quot;
    # Base case: 0 or 1 elements already sorted
    if len(items) &lt;= 1:
        return items

    # DIVIDE: split in half
    mid = len(items) // 2
    left = items[:mid]
    right = items[mid:]

    # CONQUER: sort each half recursively
    left_sorted = merge_sort(left)
    right_sorted = merge_sort(right)

    # COMBINE: merge sorted halves
    return merge(left_sorted, right_sorted)


def merge(left: list[int], right: list[int]) -&gt; list[int]:
    &quot;&quot;&quot;Merge two sorted lists into one sorted list.

    Uses two-pointer technique.
    Complexity: O(n + m)
    &quot;&quot;&quot;
    result = []
    i = j = 0

    # Compare elements from both lists
    while i &lt; len(left) and j &lt; len(right):
        if left[i] &lt;= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    # Add remaining elements
    result.extend(left[i:])
    result.extend(right[j:])

    return result
</code></pre>
<h3>5.3 VisualizaciÃ³n de Merge Sort</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  merge_sort([38, 27, 43, 3, 9, 82, 10])                         â”‚
â”‚                                                                 â”‚
â”‚  DIVIDIR:                                                       â”‚
â”‚                    [38, 27, 43, 3, 9, 82, 10]                   â”‚
â”‚                           /            \                        â”‚
â”‚               [38, 27, 43]              [3, 9, 82, 10]          â”‚
â”‚                /       \                  /        \            â”‚
â”‚           [38, 27]    [43]           [3, 9]    [82, 10]         â”‚
â”‚            /    \                     /   \      /    \         â”‚
â”‚          [38]  [27]               [3]   [9]  [82]  [10]         â”‚
â”‚                                                                 â”‚
â”‚  COMBINAR (merge):                                              â”‚
â”‚          [27, 38] â† merge [38],[27]   [3, 9] [10, 82]           â”‚
â”‚                \    /                    \    /                 â”‚
â”‚             [27, 38, 43]            [3, 9, 10, 82]              â”‚
â”‚                     \                  /                        â”‚
â”‚                [3, 9, 10, 27, 38, 43, 82]                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>5.4 MÃ¡ximo de Lista (Divide &amp; Conquer)</h3>
<pre><code class="language-python">def find_max_dc(items: list[int]) -&gt; int:
    &quot;&quot;&quot;Find maximum using divide and conquer.

    Base cases:
    - Single element â†’ that element
    - Two elements â†’ larger of the two

    Recursive: max of (max left half, max right half)
    &quot;&quot;&quot;
    if len(items) == 0:
        raise ValueError(&quot;Cannot find max of empty list&quot;)

    if len(items) == 1:
        return items[0]

    if len(items) == 2:
        return items[0] if items[0] &gt; items[1] else items[1]

    mid = len(items) // 2
    left_max = find_max_dc(items[:mid])
    right_max = find_max_dc(items[mid:])

    return left_max if left_max &gt; right_max else right_max
</code></pre>
<hr />
<h2>6. OptimizaciÃ³n con Memoization {#6-memoization}</h2>
<h3>6.1 El Problema con Fibonacci Naive</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  fib(5) calcula fib(3) DOS veces, fib(2) TRES veces, etc.       â”‚
â”‚                                                                 â”‚
â”‚                      fib(5)                                     â”‚
â”‚                    /        \                                   â”‚
â”‚               fib(4)        fib(3)        â† fib(3) calculado 2x â”‚
â”‚              /     \        /    \                              â”‚
â”‚          fib(3)  fib(2)  fib(2) fib(1)   â† fib(2) calculado 3x  â”‚
â”‚          /   \                                                  â”‚
â”‚      fib(2) fib(1)                                              â”‚
â”‚                                                                 â”‚
â”‚  Complejidad: O(2^n) - Â¡Exponencial!                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>6.2 Memoization: Recordar Resultados</h3>
<pre><code class="language-python">def fibonacci_memo(n: int, cache: dict[int, int] | None = None) -&gt; int:
    &quot;&quot;&quot;Fibonacci with memoization.

    Cache stores already computed values to avoid redundant work.

    Complexity: O(n) time, O(n) space
    &quot;&quot;&quot;
    if cache is None:
        cache = {}

    # Check cache first
    if n in cache:
        return cache[n]

    # Base cases
    if n &lt;= 0:
        return 0
    if n == 1:
        return 1

    # Compute and cache
    result = fibonacci_memo(n - 1, cache) + fibonacci_memo(n - 2, cache)
    cache[n] = result

    return result


# ComparaciÃ³n de tiempos:
# fibonacci(35)      â†’ ~3 segundos
# fibonacci_memo(35) â†’ &lt;0.001 segundos
</code></pre>
<h3>6.3 Usando functools.lru_cache</h3>
<pre><code class="language-python">from functools import lru_cache

@lru_cache(maxsize=None)  # Cache ilimitado
def fibonacci_cached(n: int) -&gt; int:
    &quot;&quot;&quot;Fibonacci with automatic memoization.&quot;&quot;&quot;
    if n &lt;= 0:
        return 0
    if n == 1:
        return 1
    return fibonacci_cached(n - 1) + fibonacci_cached(n - 2)


# Ver estadÃ­sticas del cache
print(fibonacci_cached.cache_info())
# CacheInfo(hits=48, misses=51, maxsize=None, currsize=51)

# Limpiar cache
fibonacci_cached.cache_clear()
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes</h2>
<h3>Error 1: Olvidar el caso base</h3>
<pre><code class="language-python"># âŒ Sin caso base â†’ RecursionError
def countdown_bad(n):
    print(n)
    countdown_bad(n - 1)  # Nunca termina

# âœ… Con caso base
def countdown_good(n):
    if n &lt;= 0:
        print(&quot;Done!&quot;)
        return
    print(n)
    countdown_good(n - 1)
</code></pre>
<h3>Error 2: No reducir el problema</h3>
<pre><code class="language-python"># âŒ El problema no se reduce
def broken_sum(items):
    if not items:
        return 0
    return items[0] + broken_sum(items)  # Misma lista!

# âœ… Reducir correctamente
def working_sum(items):
    if not items:
        return 0
    return items[0] + working_sum(items[1:])  # Lista mÃ¡s corta
</code></pre>
<h3>Error 3: Crear copias innecesarias</h3>
<pre><code class="language-python"># âŒ Ineficiente: crea nueva lista cada vez
def sum_slow(items):
    if not items:
        return 0
    return items[0] + sum_slow(items[1:])  # items[1:] crea copia

# âœ… Eficiente: usar Ã­ndice
def sum_fast(items, index=0):
    if index &gt;= len(items):
        return 0
    return items[index] + sum_fast(items, index + 1)
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 7.1: Factorial y Fibonacci</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 7.2: Suma y MÃ¡ximo Recursivos</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 7.3: Merge de Listas Ordenadas</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.manning.com/books/grokking-algorithms">Grokking Algorithms Ch.3-4</a></td>
<td>Libro</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://recursion.vercel.app/">Recursion Visualizer</a></td>
<td>Herramienta</td>
<td>ğŸŸ¡ Recomendado</td>
</tr>
<tr>
<td><a href="https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-spring-2020/">MIT Divide &amp; Conquer</a></td>
<td>Curso</td>
<td>ğŸŸ¢ Complementario</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ”— Referencias del Glosario</h2>
<ul>
<li><a href="#mod_GLOSARIO">RecursiÃ³n</a></li>
<li><a href="#mod_GLOSARIO">Caso Base</a></li>
<li><a href="#mod_GLOSARIO">Call Stack</a></li>
<li><a href="#mod_GLOSARIO">Divide &amp; Conquer</a></li>
<li><a href="#mod_GLOSARIO">Memoization</a></li>
</ul>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_06_INVERTED_INDEX">06_INVERTED_INDEX</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_08_SORTING">08_SORTING</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_08_SORTING" class="cover-page">
            <a name="mod_08_SORTING"></a>
            <div class="cover-title">08 - Algoritmos de Ordenamiento</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>08 - Algoritmos de Ordenamiento</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Implementar QuickSort y MergeSort desde cero, entendiendo su funcionamiento y complejidad.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: Ordenando Cartas</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   QUICKSORT = El mÃ©todo del &quot;pivote&quot;                                        â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                        â”‚
â”‚                                                                             â”‚
â”‚   1. Elige una carta (pivote): por ejemplo, el 7                            â”‚
â”‚   2. Separa: menores a la izquierda, mayores a la derecha                   â”‚
â”‚   3. Ahora el 7 estÃ¡ en su lugar correcto                                   â”‚
â”‚   4. Repite con cada grupo                                                  â”‚
â”‚                                                                             â”‚
â”‚   [3, 8, 2, 7, 1, 9, 4]  â†’ pivote = 7                                       â”‚
â”‚   [3, 2, 1, 4] [7] [8, 9]  â†’ 7 en su lugar                                  â”‚
â”‚   Repetir para [3,2,1,4] y [8,9]                                            â”‚
â”‚                                                                             â”‚
â”‚   MERGESORT = El mÃ©todo de &quot;dividir y fusionar&quot;                             â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                             â”‚
â”‚                                                                             â”‚
â”‚   1. Divide el mazo en dos mitades                                          â”‚
â”‚   2. Ordena cada mitad (recursivamente)                                     â”‚
â”‚   3. Fusiona las dos mitades ordenadas                                      â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-importancia">Por QuÃ© Importan los Algoritmos de Sorting</a></li>
<li><a href="#2-quicksort">QuickSort: El Favorito en la PrÃ¡ctica</a></li>
<li><a href="#3-mergesort">MergeSort: Estable y Predecible</a></li>
<li><a href="#4-comparacion">ComparaciÃ³n y CuÃ¡ndo Usar Cada Uno</a></li>
<li><a href="#5-analisis">AnÃ¡lisis de Complejidad Detallado</a></li>
</ol>
<hr />
<h2>1. Por QuÃ© Importan los Algoritmos de Sorting {#1-importancia}</h2>
<h3>1.1 Sorting es Fundamental</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  APLICACIONES DE SORTING                                        â”‚
â”‚                                                                 â”‚
â”‚  â€¢ BÃºsqueda binaria: requiere datos ordenados                   â”‚
â”‚  â€¢ Ranking de resultados: ordenar por relevancia                â”‚
â”‚  â€¢ EliminaciÃ³n de duplicados: ordenar + recorrer                â”‚
â”‚  â€¢ Mediana, percentiles: ordenar + acceder por Ã­ndice           â”‚
â”‚  â€¢ Sistemas de bases de datos: Ã­ndices ordenados                â”‚
â”‚                                                                 â”‚
â”‚  EN ARCHIMEDES INDEXER:                                         â”‚
â”‚  Ordenar resultados de bÃºsqueda por score de relevancia         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>1.2 Complejidades de Referencia</h3>
<table>
<thead>
<tr>
<th>Algoritmo</th>
<th>Mejor</th>
<th>Promedio</th>
<th>Peor</th>
<th>Espacio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bubble Sort</td>
<td>O(n)</td>
<td>O(nÂ²)</td>
<td>O(nÂ²)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Selection Sort</td>
<td>O(nÂ²)</td>
<td>O(nÂ²)</td>
<td>O(nÂ²)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Insertion Sort</td>
<td>O(n)</td>
<td>O(nÂ²)</td>
<td>O(nÂ²)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>QuickSort</strong></td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(nÂ²)</td>
<td>O(log n)</td>
</tr>
<tr>
<td><strong>MergeSort</strong></td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Python's Timsort</td>
<td>O(n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<hr />
<h2>2. QuickSort: El Favorito en la PrÃ¡ctica {#2-quicksort}</h2>
<h3>2.1 El Algoritmo</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  QUICKSORT - Pasos:                                             â”‚
â”‚                                                                 â”‚
â”‚  1. Si la lista tiene 0 o 1 elementos, ya estÃ¡ ordenada         â”‚
â”‚  2. Elegir un PIVOTE (elemento de referencia)                   â”‚
â”‚  3. PARTICIONAR: reorganizar para que:                          â”‚
â”‚     - Elementos &lt; pivote queden a la izquierda                  â”‚
â”‚     - Elementos &gt;= pivote queden a la derecha                   â”‚
â”‚  4. Recursivamente ordenar izquierda y derecha                  â”‚
â”‚  5. Concatenar: izquierda + pivote + derecha                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>2.2 ImplementaciÃ³n BÃ¡sica (FÃ¡cil de Entender)</h3>
<pre><code class="language-python">def quicksort_simple(items: list[int]) -&gt; list[int]:
    &quot;&quot;&quot;QuickSort with simple partitioning.

    This version creates new lists (not in-place).
    Easier to understand but uses more memory.

    Complexity:
        Time: O(n log n) average, O(nÂ²) worst
        Space: O(n) for new lists

    Example:
        &gt;&gt;&gt; quicksort_simple([3, 1, 4, 1, 5, 9, 2, 6])
        [1, 1, 2, 3, 4, 5, 6, 9]
    &quot;&quot;&quot;
    # Base case: already sorted
    if len(items) &lt;= 1:
        return items

    # Choose pivot (last element for simplicity)
    pivot = items[-1]

    # Partition into three groups
    less = [x for x in items[:-1] if x &lt; pivot]
    equal = [x for x in items if x == pivot]
    greater = [x for x in items[:-1] if x &gt; pivot]

    # Recursively sort and concatenate
    return quicksort_simple(less) + equal + quicksort_simple(greater)
</code></pre>
<h3>2.3 ImplementaciÃ³n In-Place (Eficiente en Memoria)</h3>
<pre><code class="language-python">def quicksort(items: list[int]) -&gt; list[int]:
    &quot;&quot;&quot;QuickSort with in-place partitioning.

    Modifies the original list.

    Returns:
        The same list, now sorted.
    &quot;&quot;&quot;
    _quicksort_helper(items, 0, len(items) - 1)
    return items


def _quicksort_helper(items: list[int], low: int, high: int) -&gt; None:
    &quot;&quot;&quot;Recursive helper for in-place quicksort.&quot;&quot;&quot;
    if low &lt; high:
        # Partition and get pivot position
        pivot_index = _partition(items, low, high)

        # Recursively sort elements before and after partition
        _quicksort_helper(items, low, pivot_index - 1)
        _quicksort_helper(items, pivot_index + 1, high)


def _partition(items: list[int], low: int, high: int) -&gt; int:
    &quot;&quot;&quot;Partition array around pivot (last element).

    Lomuto partition scheme.

    Returns:
        Final position of pivot.
    &quot;&quot;&quot;
    pivot = items[high]
    i = low - 1  # Index of smaller element

    for j in range(low, high):
        if items[j] &lt; pivot:
            i += 1
            items[i], items[j] = items[j], items[i]

    # Place pivot in correct position
    items[i + 1], items[high] = items[high], items[i + 1]
    return i + 1
</code></pre>
<h3>2.4 VisualizaciÃ³n de ParticiÃ³n</h3>
<pre><code>Inicial: [8, 3, 1, 7, 0, 10, 2]  (pivot = 2)

j=0: 8 &lt; 2? NO  â†’ [8, 3, 1, 7, 0, 10, 2]  i=-1
j=1: 3 &lt; 2? NO  â†’ [8, 3, 1, 7, 0, 10, 2]  i=-1
j=2: 1 &lt; 2? SÃ  â†’ [1, 3, 8, 7, 0, 10, 2]  i=0 (swap 8â†”1)
j=3: 7 &lt; 2? NO  â†’ [1, 3, 8, 7, 0, 10, 2]  i=0
j=4: 0 &lt; 2? SÃ  â†’ [1, 0, 8, 7, 3, 10, 2]  i=1 (swap 3â†”0)
j=5: 10&lt; 2? NO  â†’ [1, 0, 8, 7, 3, 10, 2]  i=1

Final: colocar pivot en i+1=2
       [1, 0, 2, 7, 3, 10, 8]
              â†‘ pivot en posiciÃ³n correcta

Izquierda: [1, 0] (todos &lt; 2)
Derecha:   [7, 3, 10, 8] (todos &gt; 2)
</code></pre>
<h3>2.5 Random Pivot (Evitar O(nÂ²))</h3>
<pre><code class="language-python">import random


def quicksort_random(items: list[int]) -&gt; list[int]:
    &quot;&quot;&quot;QuickSort with random pivot selection.

    Random pivot prevents worst case O(nÂ²) on sorted input.
    &quot;&quot;&quot;
    _quicksort_random_helper(items, 0, len(items) - 1)
    return items


def _quicksort_random_helper(items: list[int], low: int, high: int) -&gt; None:
    if low &lt; high:
        pivot_index = _partition_random(items, low, high)
        _quicksort_random_helper(items, low, pivot_index - 1)
        _quicksort_random_helper(items, pivot_index + 1, high)


def _partition_random(items: list[int], low: int, high: int) -&gt; int:
    &quot;&quot;&quot;Partition with random pivot.&quot;&quot;&quot;
    # Choose random pivot and swap to end
    random_index = random.randint(low, high)
    items[random_index], items[high] = items[high], items[random_index]

    return _partition(items, low, high)
</code></pre>
<hr />
<h2>3. MergeSort: Estable y Predecible {#3-mergesort}</h2>
<h3>3.1 El Algoritmo</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MERGESORT - Pasos:                                             â”‚
â”‚                                                                 â”‚
â”‚  1. Si la lista tiene 0 o 1 elementos, ya estÃ¡ ordenada         â”‚
â”‚  2. DIVIDIR: partir la lista en dos mitades                     â”‚
â”‚  3. CONQUISTAR: ordenar cada mitad recursivamente               â”‚
â”‚  4. COMBINAR: fusionar las dos mitades ordenadas                â”‚
â”‚                                                                 â”‚
â”‚  La &quot;magia&quot; estÃ¡ en el paso de MERGE:                           â”‚
â”‚  - Dos listas ordenadas se pueden fusionar en O(n)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>3.2 ImplementaciÃ³n Completa</h3>
<pre><code class="language-python">def mergesort(items: list[int]) -&gt; list[int]:
    &quot;&quot;&quot;Sort list using merge sort algorithm.

    Creates new lists (not in-place).

    Complexity:
        Time: O(n log n) always
        Space: O(n) for temporary arrays

    Example:
        &gt;&gt;&gt; mergesort([3, 1, 4, 1, 5, 9, 2, 6])
        [1, 1, 2, 3, 4, 5, 6, 9]
    &quot;&quot;&quot;
    # Base case
    if len(items) &lt;= 1:
        return items.copy()

    # Divide
    mid = len(items) // 2
    left = items[:mid]
    right = items[mid:]

    # Conquer (recursively sort)
    left_sorted = mergesort(left)
    right_sorted = mergesort(right)

    # Combine (merge)
    return _merge(left_sorted, right_sorted)


def _merge(left: list[int], right: list[int]) -&gt; list[int]:
    &quot;&quot;&quot;Merge two sorted lists into one sorted list.

    Uses two-pointer technique.

    Complexity: O(n + m) where n, m are list lengths
    &quot;&quot;&quot;
    result = []
    i = j = 0

    # Compare elements from both lists
    while i &lt; len(left) and j &lt; len(right):
        if left[i] &lt;= right[j]:  # &lt;= makes it stable
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    # Add remaining elements (one list is exhausted)
    result.extend(left[i:])
    result.extend(right[j:])

    return result
</code></pre>
<h3>3.3 VisualizaciÃ³n de Merge</h3>
<pre><code>Fusionar [1, 3, 5] con [2, 4, 6]:

i=0, j=0: 1 vs 2 â†’ tomar 1    result=[1]
i=1, j=0: 3 vs 2 â†’ tomar 2    result=[1, 2]
i=1, j=1: 3 vs 4 â†’ tomar 3    result=[1, 2, 3]
i=2, j=1: 5 vs 4 â†’ tomar 4    result=[1, 2, 3, 4]
i=2, j=2: 5 vs 6 â†’ tomar 5    result=[1, 2, 3, 4, 5]
i=3, j=2: (left agotada)      result=[1, 2, 3, 4, 5, 6]

Final: [1, 2, 3, 4, 5, 6]
</code></pre>
<h3>3.4 MergeSort In-Place (Opcional, MÃ¡s Complejo)</h3>
<pre><code class="language-python">def mergesort_inplace(items: list[int]) -&gt; list[int]:
    &quot;&quot;&quot;In-place merge sort using auxiliary array.

    More memory efficient than creating many small lists.
    &quot;&quot;&quot;
    aux = items.copy()
    _mergesort_inplace_helper(items, aux, 0, len(items) - 1)
    return items


def _mergesort_inplace_helper(
    items: list[int],
    aux: list[int],
    low: int,
    high: int
) -&gt; None:
    if low &gt;= high:
        return

    mid = (low + high) // 2
    _mergesort_inplace_helper(items, aux, low, mid)
    _mergesort_inplace_helper(items, aux, mid + 1, high)
    _merge_inplace(items, aux, low, mid, high)


def _merge_inplace(
    items: list[int],
    aux: list[int],
    low: int,
    mid: int,
    high: int
) -&gt; None:
    # Copy to auxiliary array
    for k in range(low, high + 1):
        aux[k] = items[k]

    i = low
    j = mid + 1

    for k in range(low, high + 1):
        if i &gt; mid:
            items[k] = aux[j]
            j += 1
        elif j &gt; high:
            items[k] = aux[i]
            i += 1
        elif aux[j] &lt; aux[i]:
            items[k] = aux[j]
            j += 1
        else:
            items[k] = aux[i]
            i += 1
</code></pre>
<hr />
<h2>4. ComparaciÃ³n y CuÃ¡ndo Usar Cada Uno {#4-comparacion}</h2>
<h3>4.1 Tabla Comparativa</h3>
<table>
<thead>
<tr>
<th>Aspecto</th>
<th>QuickSort</th>
<th>MergeSort</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Complejidad promedio</strong></td>
<td>O(n log n)</td>
<td>O(n log n)</td>
</tr>
<tr>
<td><strong>Peor caso</strong></td>
<td>O(nÂ²)</td>
<td>O(n log n)</td>
</tr>
<tr>
<td><strong>Espacio</strong></td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>Estable</strong></td>
<td>âŒ No</td>
<td>âœ… SÃ­</td>
</tr>
<tr>
<td><strong>In-place</strong></td>
<td>âœ… SÃ­</td>
<td>âŒ No (tÃ­picamente)</td>
</tr>
<tr>
<td><strong>Cache-friendly</strong></td>
<td>âœ… Mejor</td>
<td>âŒ Peor</td>
</tr>
</tbody>
</table>
<h3>4.2 Â¿QuÃ© Significa "Estable"?</h3>
<pre><code class="language-python"># Elementos con mismo valor mantienen orden relativo

data = [(&quot;Alice&quot;, 25), (&quot;Bob&quot;, 30), (&quot;Carol&quot;, 25)]

# Ordenar por edad
# ESTABLE: Alice antes de Carol (original order preserved)
# sorted_stable = [(&quot;Alice&quot;, 25), (&quot;Carol&quot;, 25), (&quot;Bob&quot;, 30)]

# NO ESTABLE: Carol podrÃ­a quedar antes de Alice
# sorted_unstable = [(&quot;Carol&quot;, 25), (&quot;Alice&quot;, 25), (&quot;Bob&quot;, 30)]
</code></pre>
<h3>4.3 CuÃ¡ndo Usar Cada Uno</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  USA QUICKSORT cuando:                                          â”‚
â”‚  â€¢ Memoria es limitada (in-place)                               â”‚
â”‚  â€¢ No necesitas estabilidad                                     â”‚
â”‚  â€¢ Datos son aleatorios (no ya ordenados)                       â”‚
â”‚  â€¢ Quieres mejor rendimiento promedio en prÃ¡ctica               â”‚
â”‚                                                                 â”‚
â”‚  USA MERGESORT cuando:                                          â”‚
â”‚  â€¢ Necesitas garantÃ­a O(n log n) siempre                        â”‚
â”‚  â€¢ Necesitas ordenamiento estable                               â”‚
â”‚  â€¢ Memoria no es problema                                       â”‚
â”‚  â€¢ Datos podrÃ­an estar casi ordenados                           â”‚
â”‚                                                                 â”‚
â”‚  EN ARCHIMEDES:                                                 â”‚
â”‚  Usaremos QuickSort para ordenar resultados por score           â”‚
â”‚  porque raramente estÃ¡n pre-ordenados y queremos velocidad      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>5. AnÃ¡lisis de Complejidad Detallado {#5-analisis}</h2>
<h3>5.1 QuickSort: Por QuÃ© O(n log n) Promedio</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MEJOR CASO: Pivote divide perfectamente por la mitad           â”‚
â”‚                                                                 â”‚
â”‚  Nivel 0: 1 problema de tamaÃ±o n                                â”‚
â”‚  Nivel 1: 2 problemas de tamaÃ±o n/2                             â”‚
â”‚  Nivel 2: 4 problemas de tamaÃ±o n/4                             â”‚
â”‚  ...                                                            â”‚
â”‚  Nivel log n: n problemas de tamaÃ±o 1                           â”‚
â”‚                                                                 â”‚
â”‚  Trabajo por nivel: O(n) (particiÃ³n)                            â”‚
â”‚  NÃºmero de niveles: O(log n)                                    â”‚
â”‚  Total: O(n) Ã— O(log n) = O(n log n)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>5.2 QuickSort: Por QuÃ© O(nÂ²) Peor Caso</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PEOR CASO: Lista ya ordenada + pivot siempre el Ãºltimo         â”‚
â”‚                                                                 â”‚
â”‚  [1, 2, 3, 4, 5]  pivot=5 â†’ [1,2,3,4] [] + [5]                  â”‚
â”‚  [1, 2, 3, 4]     pivot=4 â†’ [1,2,3]   [] + [4]                  â”‚
â”‚  [1, 2, 3]        pivot=3 â†’ [1,2]     [] + [3]                  â”‚
â”‚  [1, 2]           pivot=2 â†’ [1]       [] + [2]                  â”‚
â”‚                                                                 â”‚
â”‚  Cada nivel quita solo 1 elemento â†’ n niveles                   â”‚
â”‚  Trabajo por nivel: O(n), O(n-1), O(n-2), ...                   â”‚
â”‚  Total: n + (n-1) + ... + 1 = n(n+1)/2 = O(nÂ²)                  â”‚
â”‚                                                                 â”‚
â”‚  SOLUCIÃ“N: Random pivot evita esto en la prÃ¡ctica               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>5.3 MergeSort: Siempre O(n log n)</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SIEMPRE divide exactamente por la mitad                        â”‚
â”‚                                                                 â”‚
â”‚  T(n) = 2Ã—T(n/2) + O(n)                                         â”‚
â”‚         â†‘         â†‘                                             â”‚
â”‚    2 subproblemas  merge                                        â”‚
â”‚    de tamaÃ±o n/2                                                â”‚
â”‚                                                                 â”‚
â”‚  Por Master Theorem:                                            â”‚
â”‚  T(n) = O(n log n)                                              â”‚
â”‚                                                                 â”‚
â”‚  No hay peor caso porque la divisiÃ³n es siempre balanceada      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>5.4 AnÃ¡lisis de Espacio</h3>
<pre><code class="language-python"># QuickSort: O(log n) espacio para call stack
# - Cada llamada recursiva usa espacio constante
# - Profundidad mÃ¡xima: log n (caso promedio)
# - Profundidad mÃ¡xima: n (peor caso)

# MergeSort: O(n) espacio para arrays temporales
# - Cada merge crea nuevo array
# - El array mÃ¡s grande es de tamaÃ±o n
# - Plus O(log n) para call stack
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes</h2>
<h3>Error 1: Off-by-one en partition</h3>
<pre><code class="language-python"># âŒ Error comÃºn: incluir pivote en recursiÃ³n
_quicksort_helper(items, low, pivot_index)  # Incluye pivote
_quicksort_helper(items, pivot_index, high)  # Pivote otra vez!

# âœ… Correcto: excluir pivote (ya estÃ¡ en su lugar)
_quicksort_helper(items, low, pivot_index - 1)
_quicksort_helper(items, pivot_index + 1, high)
</code></pre>
<h3>Error 2: No manejar lista vacÃ­a</h3>
<pre><code class="language-python"># âŒ Falla con lista vacÃ­a
def quicksort_bad(items):
    pivot = items[-1]  # IndexError!

# âœ… Manejar caso base
def quicksort_good(items):
    if len(items) &lt;= 1:
        return items
    pivot = items[-1]
</code></pre>
<h3>Error 3: Modificar lista durante iteraciÃ³n</h3>
<pre><code class="language-python"># âŒ Confuso y propenso a errores
for i, item in enumerate(items):
    items[i], items[j] = ...  # Modifica mientras itera

# âœ… Usar Ã­ndices explÃ­citos
for j in range(low, high):
    if items[j] &lt; pivot:
        i += 1
        items[i], items[j] = items[j], items[i]
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 8.1: Implementar QuickSort</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 8.2: Implementar MergeSort</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 8.3: Ordenar por Score</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a> - Aplicar al ranking de Archimedes</p>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://visualgo.net/en/sorting">Visualgo Sorting</a></td>
<td>VisualizaciÃ³n</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://www.manning.com/books/grokking-algorithms">Grokking Algorithms Ch.4</a></td>
<td>Libro</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://www.youtube.com/watch?v=uXBnyYuwPe8">QuickSort Analysis</a></td>
<td>Video</td>
<td>ğŸŸ¡ Recomendado</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ”— Referencias del Glosario</h2>
<ul>
<li><a href="#mod_GLOSARIO">QuickSort</a></li>
<li><a href="#mod_GLOSARIO">MergeSort</a></li>
<li><a href="#mod_GLOSARIO">Partition</a></li>
<li><a href="#mod_GLOSARIO">Estabilidad</a></li>
<li><a href="#mod_GLOSARIO">In-Place</a></li>
</ul>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_07_RECURSION">07_RECURSION</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_09_BINARY_SEARCH">09_BINARY_SEARCH</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_09_BINARY_SEARCH" class="cover-page">
            <a name="mod_09_BINARY_SEARCH"></a>
            <div class="cover-title">09 - BÃºsqueda Binaria</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>09 - BÃºsqueda Binaria</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Implementar Binary Search sin errores off-by-one, entendiendo cuÃ¡ndo y cÃ³mo aplicarla.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: El Juego de las 20 Preguntas</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   BÃšSQUEDA LINEAL = Adivinar nÃºmero del 1 al 100                            â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                          â”‚
â”‚   &quot;Â¿Es el 1?&quot; No. &quot;Â¿Es el 2?&quot; No. &quot;Â¿Es el 3?&quot; No...                         â”‚
â”‚   Peor caso: 100 intentos â†’ O(n)                                            â”‚
â”‚                                                                             â”‚
â”‚   BÃšSQUEDA BINARIA = El juego inteligente                                   â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                   â”‚
â”‚   &quot;Â¿Es mayor que 50?&quot; SÃ­. â†’ Descartar 1-50                                  â”‚
â”‚   &quot;Â¿Es mayor que 75?&quot; No. â†’ Descartar 76-100                                â”‚
â”‚   &quot;Â¿Es mayor que 62?&quot; SÃ­. â†’ Descartar 51-62                                 â”‚
â”‚   ...                                                                       â”‚
â”‚   MÃ¡ximo: 7 intentos para 100 nÃºmeros â†’ O(log n)                            â”‚
â”‚                                                                             â”‚
â”‚   REQUISITO: Los datos deben estar ORDENADOS                                â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-algoritmo">El Algoritmo Fundamental</a></li>
<li><a href="#2-implementacion">ImplementaciÃ³n Sin Errores</a></li>
<li><a href="#3-off-by-one">Off-by-One: El Error ClÃ¡sico</a></li>
<li><a href="#4-variantes">Variantes Importantes</a></li>
<li><a href="#5-aplicacion">AplicaciÃ³n en Archimedes</a></li>
</ol>
<hr />
<h2>1. El Algoritmo Fundamental {#1-algoritmo}</h2>
<h3>1.1 Idea Central</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BINARY SEARCH: Dividir el espacio de bÃºsqueda a la mitad       â”‚
â”‚                                                                 â”‚
â”‚  Buscar 7 en [1, 3, 5, 7, 9, 11, 13]                            â”‚
â”‚                                                                 â”‚
â”‚  Paso 1: low=0, high=6, mid=3 â†’ items[3]=7                      â”‚
â”‚          [1, 3, 5, 7, 9, 11, 13]                                â”‚
â”‚                   â†‘                                             â”‚
â”‚          Â¡Encontrado! Retornar 3                                â”‚
â”‚                                                                 â”‚
â”‚  Buscar 9:                                                      â”‚
â”‚  Paso 1: mid=3 â†’ items[3]=7 &lt; 9 â†’ buscar en derecha             â”‚
â”‚  Paso 2: low=4, high=6, mid=5 â†’ items[5]=11 &gt; 9 â†’ izquierda     â”‚
â”‚  Paso 3: low=4, high=4, mid=4 â†’ items[4]=9 â†’ Â¡Encontrado!       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>1.2 Complejidad</h3>
<pre><code>n elementos â†’ mÃ¡ximo logâ‚‚(n) comparaciones

n = 1,000      â†’ 10 comparaciones
n = 1,000,000  â†’ 20 comparaciones
n = 1,000,000,000 â†’ 30 comparaciones

Â¡IncreÃ­blemente eficiente!
</code></pre>
<hr />
<h2>2. ImplementaciÃ³n Sin Errores {#2-implementacion}</h2>
<h3>2.1 VersiÃ³n Iterativa (Recomendada)</h3>
<pre><code class="language-python">def binary_search(items: list[int], target: int) -&gt; int:
    &quot;&quot;&quot;Find target in sorted list using binary search.

    Args:
        items: Sorted list of integers.
        target: Value to find.

    Returns:
        Index of target if found, -1 otherwise.

    Complexity:
        Time: O(log n)
        Space: O(1)

    Example:
        &gt;&gt;&gt; binary_search([1, 3, 5, 7, 9], 5)
        2
        &gt;&gt;&gt; binary_search([1, 3, 5, 7, 9], 4)
        -1
    &quot;&quot;&quot;
    left = 0
    right = len(items) - 1

    while left &lt;= right:
        # Prevent integer overflow (not an issue in Python, but good practice)
        mid = left + (right - left) // 2

        if items[mid] == target:
            return mid
        elif items[mid] &lt; target:
            left = mid + 1  # Target is in right half
        else:
            right = mid - 1  # Target is in left half

    return -1  # Not found
</code></pre>
<h3>2.2 VersiÃ³n Recursiva</h3>
<pre><code class="language-python">def binary_search_recursive(
    items: list[int],
    target: int,
    left: int = 0,
    right: int | None = None
) -&gt; int:
    &quot;&quot;&quot;Binary search using recursion.

    Complexity:
        Time: O(log n)
        Space: O(log n) for call stack
    &quot;&quot;&quot;
    if right is None:
        right = len(items) - 1

    # Base case: search space exhausted
    if left &gt; right:
        return -1

    mid = left + (right - left) // 2

    if items[mid] == target:
        return mid
    elif items[mid] &lt; target:
        return binary_search_recursive(items, target, mid + 1, right)
    else:
        return binary_search_recursive(items, target, left, mid - 1)
</code></pre>
<h3>2.3 VisualizaciÃ³n Paso a Paso</h3>
<pre><code class="language-python">def binary_search_verbose(items: list[int], target: int) -&gt; int:
    &quot;&quot;&quot;Binary search with debug output.&quot;&quot;&quot;
    left = 0
    right = len(items) - 1
    step = 0

    while left &lt;= right:
        mid = left + (right - left) // 2
        step += 1

        print(f&quot;Step {step}: left={left}, right={right}, mid={mid}&quot;)
        print(f&quot;  Checking items[{mid}] = {items[mid]}&quot;)

        if items[mid] == target:
            print(f&quot;  Found {target} at index {mid}&quot;)
            return mid
        elif items[mid] &lt; target:
            print(f&quot;  {items[mid]} &lt; {target}, searching right half&quot;)
            left = mid + 1
        else:
            print(f&quot;  {items[mid]} &gt; {target}, searching left half&quot;)
            right = mid - 1

    print(f&quot;  {target} not found after {step} steps&quot;)
    return -1

# binary_search_verbose([1, 3, 5, 7, 9, 11, 13], 9)
# Step 1: left=0, right=6, mid=3
#   Checking items[3] = 7
#   7 &lt; 9, searching right half
# Step 2: left=4, right=6, mid=5
#   Checking items[5] = 11
#   11 &gt; 9, searching left half
# Step 3: left=4, right=4, mid=4
#   Checking items[4] = 9
#   Found 9 at index 4
</code></pre>
<hr />
<h2>3. Off-by-One: El Error ClÃ¡sico {#3-off-by-one}</h2>
<h3>3.1 Los Puntos CrÃ­ticos</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ERRORES COMUNES:                                               â”‚
â”‚                                                                 â”‚
â”‚  1. while left &lt; right vs while left &lt;= right                   â”‚
â”‚     â†’ left &lt; right: puede no revisar Ãºltimo elemento            â”‚
â”‚     â†’ left &lt;= right: CORRECTO, revisa cuando left == right      â”‚
â”‚                                                                 â”‚
â”‚  2. right = mid vs right = mid - 1                              â”‚
â”‚     â†’ right = mid: puede causar loop infinito                   â”‚
â”‚     â†’ right = mid - 1: CORRECTO, excluye mid ya revisado        â”‚
â”‚                                                                 â”‚
â”‚  3. left = mid vs left = mid + 1                                â”‚
â”‚     â†’ left = mid: puede causar loop infinito                    â”‚
â”‚     â†’ left = mid + 1: CORRECTO, excluye mid ya revisado         â”‚
â”‚                                                                 â”‚
â”‚  4. mid = (left + right) / 2                                    â”‚
â”‚     â†’ Overflow en otros lenguajes (no en Python)                â”‚
â”‚     â†’ Mejor: mid = left + (right - left) // 2                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>3.2 Ejemplo del Loop Infinito</h3>
<pre><code class="language-python"># âŒ Bug: loop infinito
def binary_search_buggy(items, target):
    left, right = 0, len(items) - 1
    while left &lt; right:  # Bug 1: deberÃ­a ser &lt;=
        mid = (left + right) // 2
        if items[mid] &lt; target:
            left = mid  # Bug 2: deberÃ­a ser mid + 1
        else:
            right = mid
    return left if items[left] == target else -1

# Con items=[1, 3], target=3:
# left=0, right=1, mid=0
# items[0]=1 &lt; 3, left=0 (no cambia!)
# Loop infinito porque left nunca avanza
</code></pre>
<h3>3.3 Template a Prueba de Errores</h3>
<pre><code class="language-python">def binary_search_template(items: list[int], target: int) -&gt; int:
    &quot;&quot;&quot;Template seguro para binary search.

    Reglas de oro:
    1. while left &lt;= right (incluir caso left == right)
    2. left = mid + 1 (excluir mid de bÃºsqueda futura)
    3. right = mid - 1 (excluir mid de bÃºsqueda futura)
    4. mid = left + (right - left) // 2 (evitar overflow)
    &quot;&quot;&quot;
    left = 0
    right = len(items) - 1

    while left &lt;= right:  # Regla 1: incluir igualdad
        mid = left + (right - left) // 2  # Regla 4: evitar overflow

        if items[mid] == target:
            return mid
        elif items[mid] &lt; target:
            left = mid + 1  # Regla 2: excluir mid
        else:
            right = mid - 1  # Regla 3: excluir mid

    return -1
</code></pre>
<hr />
<h2>4. Variantes Importantes {#4-variantes}</h2>
<h3>4.1 Encontrar Primera Ocurrencia</h3>
<pre><code class="language-python">def find_first(items: list[int], target: int) -&gt; int:
    &quot;&quot;&quot;Find index of first occurrence of target.

    Returns -1 if target not found.

    Example:
        &gt;&gt;&gt; find_first([1, 2, 2, 2, 3], 2)
        1  # First 2 is at index 1
    &quot;&quot;&quot;
    left = 0
    right = len(items) - 1
    result = -1

    while left &lt;= right:
        mid = left + (right - left) // 2

        if items[mid] == target:
            result = mid  # Guardar y seguir buscando a la izquierda
            right = mid - 1
        elif items[mid] &lt; target:
            left = mid + 1
        else:
            right = mid - 1

    return result
</code></pre>
<h3>4.2 Encontrar Ãšltima Ocurrencia</h3>
<pre><code class="language-python">def find_last(items: list[int], target: int) -&gt; int:
    &quot;&quot;&quot;Find index of last occurrence of target.

    Example:
        &gt;&gt;&gt; find_last([1, 2, 2, 2, 3], 2)
        3  # Last 2 is at index 3
    &quot;&quot;&quot;
    left = 0
    right = len(items) - 1
    result = -1

    while left &lt;= right:
        mid = left + (right - left) // 2

        if items[mid] == target:
            result = mid  # Guardar y seguir buscando a la derecha
            left = mid + 1
        elif items[mid] &lt; target:
            left = mid + 1
        else:
            right = mid - 1

    return result
</code></pre>
<h3>4.3 Encontrar Punto de InserciÃ³n</h3>
<pre><code class="language-python">def find_insert_position(items: list[int], target: int) -&gt; int:
    &quot;&quot;&quot;Find index where target should be inserted to maintain sorted order.

    Equivalent to bisect_left from bisect module.

    Example:
        &gt;&gt;&gt; find_insert_position([1, 3, 5, 7], 4)
        2  # Insert 4 at index 2 â†’ [1, 3, 4, 5, 7]
        &gt;&gt;&gt; find_insert_position([1, 3, 5, 7], 5)
        2  # Insert before existing 5
    &quot;&quot;&quot;
    left = 0
    right = len(items)  # Note: len(items), not len(items) - 1

    while left &lt; right:  # Note: &lt;, not &lt;=
        mid = left + (right - left) // 2

        if items[mid] &lt; target:
            left = mid + 1
        else:
            right = mid

    return left
</code></pre>
<h3>4.4 Contar Ocurrencias</h3>
<pre><code class="language-python">def count_occurrences(items: list[int], target: int) -&gt; int:
    &quot;&quot;&quot;Count how many times target appears in sorted list.

    Uses find_first and find_last.

    Complexity: O(log n)

    Example:
        &gt;&gt;&gt; count_occurrences([1, 2, 2, 2, 3], 2)
        3
    &quot;&quot;&quot;
    first = find_first(items, target)

    if first == -1:
        return 0

    last = find_last(items, target)
    return last - first + 1
</code></pre>
<h3>4.5 BÃºsqueda en Rango</h3>
<pre><code class="language-python">def search_in_range(
    items: list[int],
    low_target: int,
    high_target: int
) -&gt; list[int]:
    &quot;&quot;&quot;Find all elements in [low_target, high_target] range.

    Returns list of indices.

    Example:
        &gt;&gt;&gt; search_in_range([1, 3, 5, 7, 9, 11], 4, 8)
        [2, 3]  # Indices of 5 and 7
    &quot;&quot;&quot;
    # Find first element &gt;= low_target
    start = find_insert_position(items, low_target)

    # Find first element &gt; high_target
    end = find_insert_position(items, high_target + 1)

    return list(range(start, end))
</code></pre>
<hr />
<h2>5. AplicaciÃ³n en Archimedes {#5-aplicacion}</h2>
<h3>5.1 BÃºsqueda en Posting Lists Ordenadas</h3>
<pre><code class="language-python">def search_in_posting_list(
    posting_list: list[int],
    doc_id: int
) -&gt; bool:
    &quot;&quot;&quot;Check if doc_id exists in sorted posting list.

    Posting lists in inverted index are often sorted by doc_id.
    Binary search is perfect for checking membership.
    &quot;&quot;&quot;
    return binary_search(posting_list, doc_id) != -1
</code></pre>
<h3>5.2 IntersecciÃ³n de Posting Lists</h3>
<pre><code class="language-python">def intersect_posting_lists(
    list1: list[int],
    list2: list[int]
) -&gt; list[int]:
    &quot;&quot;&quot;Intersect two sorted posting lists.

    Uses binary search for smaller list against larger list.

    Complexity: O(m log n) where m &lt; n
    &quot;&quot;&quot;
    # Ensure list1 is smaller
    if len(list1) &gt; len(list2):
        list1, list2 = list2, list1

    result = []
    for doc_id in list1:
        if binary_search(list2, doc_id) != -1:
            result.append(doc_id)

    return result
</code></pre>
<h3>5.3 BÃºsqueda de Umbral de Score</h3>
<pre><code class="language-python">from typing import NamedTuple


class ScoredDocument(NamedTuple):
    doc_id: int
    score: float


def find_docs_above_threshold(
    ranked_docs: list[ScoredDocument],
    min_score: float
) -&gt; list[ScoredDocument]:
    &quot;&quot;&quot;Find documents with score &gt;= min_score.

    Assumes ranked_docs is sorted by score DESCENDING.

    Example:
        &gt;&gt;&gt; docs = [ScoredDocument(1, 0.9), ScoredDocument(2, 0.7), 
        ...         ScoredDocument(3, 0.5), ScoredDocument(4, 0.3)]
        &gt;&gt;&gt; find_docs_above_threshold(docs, 0.6)
        [ScoredDocument(1, 0.9), ScoredDocument(2, 0.7)]
    &quot;&quot;&quot;
    if not ranked_docs:
        return []

    # Binary search for last document with score &gt;= min_score
    left = 0
    right = len(ranked_docs) - 1
    result_end = -1

    while left &lt;= right:
        mid = left + (right - left) // 2

        if ranked_docs[mid].score &gt;= min_score:
            result_end = mid
            left = mid + 1  # Buscar mÃ¡s a la derecha
        else:
            right = mid - 1

    if result_end == -1:
        return []

    return ranked_docs[:result_end + 1]
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes</h2>
<h3>Error 1: Olvidar que la lista debe estar ordenada</h3>
<pre><code class="language-python"># âŒ Binary search en lista no ordenada
items = [3, 1, 4, 1, 5, 9, 2, 6]
binary_search(items, 5)  # Â¡Resultado incorrecto o no encontrado!

# âœ… Ordenar primero (o usar estructura ya ordenada)
items = sorted(items)
binary_search(items, 5)  # Correcto
</code></pre>
<h3>Error 2: Usar &gt;= en lugar de &gt; (o viceversa)</h3>
<pre><code class="language-python"># âŒ CondiciÃ³n incorrecta para primera ocurrencia
if items[mid] &gt;= target:  # &gt;= encontrarÃ¡ cualquier ocurrencia
    right = mid - 1

# âœ… Para primera ocurrencia, guardar y seguir buscando
if items[mid] == target:
    result = mid
    right = mid - 1  # Seguir buscando a la izquierda
</code></pre>
<h3>Error 3: Ãndices fuera de rango</h3>
<pre><code class="language-python"># âŒ Acceder sin verificar
def search_bad(items, target):
    mid = len(items) // 2
    return items[mid] == target  # IndexError si lista vacÃ­a!

# âœ… Verificar primero
def search_good(items, target):
    if not items:
        return False
    # ... binary search
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 9.1: Binary Search BÃ¡sica</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 9.2: Primera y Ãšltima Ocurrencia</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 9.3: BÃºsqueda en Archimedes</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.cs.usfca.edu/~galles/visualization/Search.html">Binary Search Visualization</a></td>
<td>Herramienta</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://leetcode.com/tag/binary-search/">LeetCode Binary Search</a></td>
<td>PrÃ¡ctica</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/bisect.html">bisect Module</a></td>
<td>Docs</td>
<td>ğŸŸ¡ Recomendado</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ”— Referencias del Glosario</h2>
<ul>
<li><a href="#mod_GLOSARIO">Binary Search</a></li>
<li><a href="#mod_GLOSARIO">Off-by-One Error</a></li>
<li><a href="#mod_GLOSARIO">Logarithmic Complexity</a></li>
</ul>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_08_SORTING">08_SORTING</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_10_ALGEBRA_LINEAL">10_ALGEBRA_LINEAL</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_16_DYNAMIC_PROGRAMMING" class="cover-page">
            <a name="mod_16_DYNAMIC_PROGRAMMING"></a>
            <div class="cover-title">16 - Dynamic Programming</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>16 - Dynamic Programming</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Dominar la tÃ©cnica de DP para resolver problemas de optimizaciÃ³n - <strong>tema CRÃTICO del Pathway</strong>.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: No Calcular lo Mismo Dos Veces</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   DYNAMIC PROGRAMMING = Recordar para no recalcular                         â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                         â”‚
â”‚                                                                             â”‚
â”‚   FIBONACCI NAIVE:                                                          â”‚
â”‚                fib(5)                                                       â”‚
â”‚               /      \                                                      â”‚
â”‚          fib(4)      fib(3)          â† fib(3) se calcula 2 veces!           â”‚
â”‚          /    \       /   \                                                 â”‚
â”‚      fib(3) fib(2) fib(2) fib(1)     â† fib(2) se calcula 3 veces!           â”‚
â”‚       ...                                                                   â”‚
â”‚                                                                             â”‚
â”‚   DYNAMIC PROGRAMMING:                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                         â”‚
â”‚   â”‚ Ya calculÃ© fib(3)? â†’ Buscar   â”‚                                         â”‚
â”‚   â”‚ No calculado? â†’ Calcular y    â”‚                                         â”‚
â”‚   â”‚                 GUARDAR       â”‚                                         â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                         â”‚
â”‚                                                                             â”‚
â”‚   REQUISITOS para usar DP:                                                  â”‚
â”‚   1. OPTIMAL SUBSTRUCTURE: SoluciÃ³n Ã³ptima usa soluciones Ã³ptimas de        â”‚
â”‚      subproblemas                                                           â”‚
â”‚   2. OVERLAPPING SUBPROBLEMS: Los mismos subproblemas se repiten            â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-conceptos">Conceptos Fundamentales</a></li>
<li><a href="#2-top-down">Top-Down (Memoization)</a></li>
<li><a href="#3-bottom-up">Bottom-Up (Tabulation)</a></li>
<li><a href="#4-clasicos">Problemas ClÃ¡sicos</a></li>
<li><a href="#5-framework">Framework para Resolver DP</a></li>
</ol>
<hr />
<h2>1. Conceptos Fundamentales {#1-conceptos}</h2>
<h3>1.1 Â¿QuÃ© es Dynamic Programming?</h3>
<pre><code>DP = TÃ©cnica de optimizaciÃ³n que:
1. Divide problema en subproblemas
2. Resuelve cada subproblema UNA SOLA VEZ
3. Guarda resultados para reusar

NO es:
- Un algoritmo especÃ­fico
- Solo memorizaciÃ³n
- Aplicable a cualquier problema
</code></pre>
<h3>1.2 Dos Enfoques</h3>
<table>
<thead>
<tr>
<th>Top-Down (Memoization)</th>
<th>Bottom-Up (Tabulation)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Recursivo + cache</td>
<td>Iterativo + tabla</td>
</tr>
<tr>
<td>Empieza del problema grande</td>
<td>Empieza de casos base</td>
</tr>
<tr>
<td>Solo calcula lo necesario</td>
<td>Calcula todo</td>
</tr>
<tr>
<td>MÃ¡s intuitivo</td>
<td>MÃ¡s eficiente (no call stack)</td>
</tr>
</tbody>
</table>
<hr />
<h2>2. Top-Down (Memoization) {#2-top-down}</h2>
<h3>2.1 Fibonacci con Memoization</h3>
<pre><code class="language-python">def fibonacci_memo(n: int, memo: dict[int, int] | None = None) -&gt; int:
    &quot;&quot;&quot;Fibonacci with memoization (top-down DP).

    Time: O(n) - each value computed once
    Space: O(n) - for memo dict + call stack

    Example:
        &gt;&gt;&gt; fibonacci_memo(10)
        55
    &quot;&quot;&quot;
    if memo is None:
        memo = {}

    # Check cache first
    if n in memo:
        return memo[n]

    # Base cases
    if n &lt;= 1:
        return n

    # Compute and cache
    memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)
    return memo[n]


# Con decorator
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci_lru(n: int) -&gt; int:
    &quot;&quot;&quot;Fibonacci with automatic memoization.&quot;&quot;&quot;
    if n &lt;= 1:
        return n
    return fibonacci_lru(n - 1) + fibonacci_lru(n - 2)
</code></pre>
<h3>2.2 Template Top-Down</h3>
<pre><code class="language-python">def solve_top_down(problem):
    memo = {}

    def dp(state):
        # 1. Check cache
        if state in memo:
            return memo[state]

        # 2. Base case
        if is_base_case(state):
            return base_value

        # 3. Recurrence relation
        result = combine(dp(smaller_states))

        # 4. Cache and return
        memo[state] = result
        return result

    return dp(initial_state)
</code></pre>
<hr />
<h2>3. Bottom-Up (Tabulation) {#3-bottom-up}</h2>
<h3>3.1 Fibonacci Bottom-Up</h3>
<pre><code class="language-python">def fibonacci_bottom_up(n: int) -&gt; int:
    &quot;&quot;&quot;Fibonacci with tabulation (bottom-up DP).

    Builds solution from base cases up.

    Time: O(n)
    Space: O(n) for the table

    Example:
        &gt;&gt;&gt; fibonacci_bottom_up(10)
        55
    &quot;&quot;&quot;
    if n &lt;= 1:
        return n

    # Table to store computed values
    dp = [0] * (n + 1)

    # Base cases
    dp[0] = 0
    dp[1] = 1

    # Fill table from base cases up
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]


def fibonacci_optimized(n: int) -&gt; int:
    &quot;&quot;&quot;Fibonacci with O(1) space.

    Only need previous two values.
    &quot;&quot;&quot;
    if n &lt;= 1:
        return n

    prev2 = 0  # fib(i-2)
    prev1 = 1  # fib(i-1)

    for _ in range(2, n + 1):
        current = prev1 + prev2
        prev2 = prev1
        prev1 = current

    return prev1
</code></pre>
<h3>3.2 Template Bottom-Up</h3>
<pre><code class="language-python">def solve_bottom_up(problem):
    # 1. Define table size and initialize
    dp = initialize_table(problem_size)

    # 2. Set base cases
    dp[base_indices] = base_values

    # 3. Fill table iteratively
    for state in all_states_in_order:
        dp[state] = combine(dp[smaller_states])

    # 4. Return final answer
    return dp[final_state]
</code></pre>
<hr />
<h2>4. Problemas ClÃ¡sicos {#4-clasicos}</h2>
<h3>4.1 Climbing Stairs</h3>
<pre><code class="language-python">def climb_stairs(n: int) -&gt; int:
    &quot;&quot;&quot;Number of ways to climb n stairs (1 or 2 steps at a time).

    Recurrence: ways(n) = ways(n-1) + ways(n-2)
    (Same as Fibonacci!)

    Example:
        &gt;&gt;&gt; climb_stairs(4)
        5  # [1,1,1,1], [1,1,2], [1,2,1], [2,1,1], [2,2]
    &quot;&quot;&quot;
    if n &lt;= 2:
        return n

    prev2 = 1  # ways to reach step 1
    prev1 = 2  # ways to reach step 2

    for _ in range(3, n + 1):
        current = prev1 + prev2
        prev2 = prev1
        prev1 = current

    return prev1
</code></pre>
<h3>4.2 Coin Change (Minimum Coins)</h3>
<pre><code class="language-python">def coin_change(coins: list[int], amount: int) -&gt; int:
    &quot;&quot;&quot;Find minimum coins needed to make amount.

    Classic DP problem.

    Recurrence:
        dp[a] = min(dp[a - coin] + 1) for all coins where coin &lt;= a

    Example:
        &gt;&gt;&gt; coin_change([1, 2, 5], 11)
        3  # 5 + 5 + 1

    Time: O(amount * len(coins))
    Space: O(amount)
    &quot;&quot;&quot;
    # dp[i] = minimum coins to make amount i
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # 0 coins to make amount 0

    for a in range(1, amount + 1):
        for coin in coins:
            if coin &lt;= a and dp[a - coin] != float('inf'):
                dp[a] = min(dp[a], dp[a - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1
</code></pre>
<h3>4.3 Longest Common Subsequence (LCS)</h3>
<pre><code class="language-python">def lcs(text1: str, text2: str) -&gt; int:
    &quot;&quot;&quot;Find length of longest common subsequence.

    Subsequence: characters in same order but not necessarily contiguous.

    Example:
        &gt;&gt;&gt; lcs(&quot;abcde&quot;, &quot;ace&quot;)
        3  # &quot;ace&quot;

    Recurrence:
        If text1[i] == text2[j]: dp[i][j] = dp[i-1][j-1] + 1
        Else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    Time: O(m * n)
    Space: O(m * n)
    &quot;&quot;&quot;
    m, n = len(text1), len(text2)

    # dp[i][j] = LCS of text1[:i] and text2[:j]
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]
</code></pre>
<h3>4.4 0/1 Knapsack</h3>
<pre><code class="language-python">def knapsack(weights: list[int], values: list[int], capacity: int) -&gt; int:
    &quot;&quot;&quot;0/1 Knapsack: maximize value within weight capacity.

    Each item can be taken at most once.

    Example:
        &gt;&gt;&gt; knapsack([1, 2, 3], [6, 10, 12], 5)
        22  # items with weight 2 and 3

    Recurrence:
        dp[i][w] = max(
            dp[i-1][w],                        # don't take item i
            dp[i-1][w-weight[i]] + value[i]    # take item i
        )

    Time: O(n * capacity)
    Space: O(n * capacity) or O(capacity) optimized
    &quot;&quot;&quot;
    n = len(weights)

    # dp[i][w] = max value using first i items with capacity w
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(capacity + 1):
            # Don't take item i
            dp[i][w] = dp[i - 1][w]

            # Take item i (if it fits)
            if weights[i - 1] &lt;= w:
                dp[i][w] = max(
                    dp[i][w],
                    dp[i - 1][w - weights[i - 1]] + values[i - 1]
                )

    return dp[n][capacity]
</code></pre>
<h3>4.5 Maximum Subarray (Kadane's Algorithm)</h3>
<pre><code class="language-python">def max_subarray(nums: list[int]) -&gt; int:
    &quot;&quot;&quot;Find contiguous subarray with maximum sum.

    Kadane's Algorithm - clever DP.

    Recurrence:
        max_ending_here = max(num, max_ending_here + num)

    Example:
        &gt;&gt;&gt; max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])
        6  # [4, -1, 2, 1]

    Time: O(n)
    Space: O(1)
    &quot;&quot;&quot;
    max_sum = nums[0]
    current_sum = nums[0]

    for num in nums[1:]:
        # Either extend current subarray or start new
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)

    return max_sum
</code></pre>
<hr />
<h2>5. Framework para Resolver DP {#5-framework}</h2>
<h3>5.1 Pasos para Resolver</h3>
<pre><code>1. IDENTIFICAR: Â¿Es un problema de DP?
   - Â¿Tiene optimal substructure?
   - Â¿Hay overlapping subproblems?
   - Â¿Pide optimizar algo o contar combinaciones?

2. DEFINIR ESTADO:
   - Â¿QuÃ© representa dp[i] o dp[i][j]?
   - Â¿QuÃ© informaciÃ³n necesito para resolver el problema?

3. ENCONTRAR RECURRENCIA:
   - Â¿CÃ³mo se relaciona dp[i] con estados anteriores?
   - Escribir la fÃ³rmula matemÃ¡tica

4. IDENTIFICAR CASOS BASE:
   - Â¿CuÃ¡les son los subproblemas triviales?
   - Â¿QuÃ© valores conozco directamente?

5. DETERMINAR ORDEN DE CÃLCULO:
   - Â¿En quÃ© orden llenar la tabla?
   - Asegurar que dependencias ya estÃ©n calculadas

6. IMPLEMENTAR:
   - Top-down (mÃ¡s intuitivo) o
   - Bottom-up (mÃ¡s eficiente)
</code></pre>
<h3>5.2 SeÃ±ales de que es DP</h3>
<pre><code>KEYWORDS que indican DP:
- &quot;minimum/maximum&quot;
- &quot;count the number of ways&quot;
- &quot;is it possible&quot;
- &quot;longest/shortest&quot;
- &quot;optimal&quot;

PATRONES comunes:
- Secuencias/arrays: dp[i] = f(dp[i-1], dp[i-2], ...)
- Dos secuencias: dp[i][j] = f(dp[i-1][j], dp[i][j-1], ...)
- Intervalos: dp[i][j] = f(dp[i+1][j], dp[i][j-1])
- Capacidad: dp[i][w] = f(dp[i-1][w], dp[i-1][w-item])
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes</h2>
<h3>Error 1: Recurrencia incorrecta</h3>
<pre><code class="language-python"># âŒ Mal: no considera todos los casos
dp[i] = dp[i-1] + something

# âœ… Asegurar que considera TODAS las opciones
dp[i] = max/min over ALL valid transitions
</code></pre>
<h3>Error 2: Orden de cÃ¡lculo incorrecto</h3>
<pre><code class="language-python"># âŒ Usar valores no calculados aÃºn
for i in range(n):
    dp[i] = dp[i+1] + ...  # dp[i+1] no existe!

# âœ… Calcular dependencias primero
for i in range(n-1, -1, -1):  # Reverse
    dp[i] = dp[i+1] + ...
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 16.1: Fibonacci con memo y tabulation</h3>
<h3>Ejercicio 16.2: Coin Change</h3>
<h3>Ejercicio 16.3: Longest Common Subsequence</h3>
<h3>Ejercicio 16.4: 0/1 Knapsack</h3>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.youtube.com/watch?v=OQ5jsbhAv_M">MIT DP Lecture</a></td>
<td>Video</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns">Dynamic Programming Patterns</a></td>
<td>GuÃ­a</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_15_GRAPHS">15_GRAPHS</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_17_GREEDY">17_GREEDY</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_17_GREEDY" class="cover-page">
            <a name="mod_17_GREEDY"></a>
            <div class="cover-title">17 - Greedy Algorithms</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>17 - Algoritmos Greedy</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Entender cuÃ¡ndo y cÃ³mo aplicar la estrategia greedy correctamente.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: El Cambio de Monedas</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   GREEDY = Tomar la MEJOR opciÃ³n local en cada paso                         â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                         â”‚
â”‚                                                                             â”‚
â”‚   DAR CAMBIO DE $36:                                                        â”‚
â”‚   Monedas disponibles: $25, $10, $5, $1                                     â”‚
â”‚                                                                             â”‚
â”‚   ESTRATEGIA GREEDY:                                                        â”‚
â”‚   1. Â¿Cabe $25? SÃ­ â†’ Tomar (quedan $11)                                     â”‚
â”‚   2. Â¿Cabe $25? No. Â¿$10? SÃ­ â†’ Tomar (quedan $1)                            â”‚
â”‚   3. Â¿Cabe $10? No. Â¿$5? No. Â¿$1? SÃ­ â†’ Tomar (quedan $0)                    â”‚
â”‚   Total: 3 monedas ($25 + $10 + $1)                                         â”‚
â”‚                                                                             â”‚
â”‚   âœ… FUNCIONA porque estas monedas tienen &quot;greedy choice property&quot;          â”‚
â”‚                                                                             â”‚
â”‚   CONTRAEJEMPLO (monedas $1, $3, $4):                                       â”‚
â”‚   Dar cambio de $6:                                                         â”‚
â”‚   - Greedy: $4 + $1 + $1 = 3 monedas                                        â”‚
â”‚   - Ã“ptimo: $3 + $3 = 2 monedas                                             â”‚
â”‚   âŒ Greedy NO siempre da Ã³ptimo                                            â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-que-es">Â¿QuÃ© es Greedy?</a></li>
<li><a href="#2-vs-dp">Greedy vs Dynamic Programming</a></li>
<li><a href="#3-clasicos">Problemas ClÃ¡sicos Greedy</a></li>
<li><a href="#4-probar">CÃ³mo Probar Correctitud</a></li>
</ol>
<hr />
<h2>1. Â¿QuÃ© es Greedy? {#1-que-es}</h2>
<h3>1.1 DefiniciÃ³n</h3>
<pre><code>GREEDY ALGORITHM:
1. En cada paso, toma la decisiÃ³n que parece MEJOR en ese momento
2. Una vez tomada, NUNCA reconsiderar
3. Esperar que las decisiones locales lleven al Ã³ptimo global

REQUISITOS para que funcione:
1. GREEDY CHOICE PROPERTY: Una soluciÃ³n Ã³ptima puede construirse
   tomando decisiones greedy
2. OPTIMAL SUBSTRUCTURE: SoluciÃ³n Ã³ptima contiene soluciones
   Ã³ptimas de subproblemas
</code></pre>
<h3>1.2 CuÃ¡ndo Usar Greedy</h3>
<pre><code>SEÃ‘ALES de que greedy puede funcionar:
- Problema pide mÃ¡ximo/mÃ­nimo
- Elementos pueden ordenarse por algÃºn criterio
- Tomar una decisiÃ³n no afecta decisiones futuras
- Hay &quot;greedy choice&quot; obvio

SEÃ‘ALES de que greedy NO funcionarÃ¡:
- Decisiones actuales afectan opciones futuras
- Necesitas &quot;deshacer&quot; decisiones
- No hay criterio claro para ordenar
â†’ Probablemente necesitas DP
</code></pre>
<hr />
<h2>2. Greedy vs Dynamic Programming {#2-vs-dp}</h2>
<h3>2.1 ComparaciÃ³n</h3>
<table>
<thead>
<tr>
<th>Aspecto</th>
<th>Greedy</th>
<th>Dynamic Programming</th>
</tr>
</thead>
<tbody>
<tr>
<td>Decisiones</td>
<td>Una vez, definitiva</td>
<td>Considera todas</td>
</tr>
<tr>
<td>Subproblemas</td>
<td>No recalcula</td>
<td>Guarda y reusa</td>
</tr>
<tr>
<td>Complejidad</td>
<td>Generalmente menor</td>
<td>Mayor pero garantizado</td>
</tr>
<tr>
<td>Correctitud</td>
<td>Requiere demostraciÃ³n</td>
<td>Siempre correcto</td>
</tr>
<tr>
<td>ImplementaciÃ³n</td>
<td>MÃ¡s simple</td>
<td>MÃ¡s compleja</td>
</tr>
</tbody>
</table>
<h3>2.2 Coin Change: Greedy vs DP</h3>
<pre><code class="language-python"># GREEDY - Simple pero no siempre correcto
def coin_change_greedy(coins: list[int], amount: int) -&gt; int:
    &quot;&quot;&quot;May NOT give optimal solution for all coin systems.&quot;&quot;&quot;
    coins_sorted = sorted(coins, reverse=True)
    count = 0

    for coin in coins_sorted:
        while amount &gt;= coin:
            amount -= coin
            count += 1

    return count if amount == 0 else -1


# DP - Siempre correcto
def coin_change_dp(coins: list[int], amount: int) -&gt; int:
    &quot;&quot;&quot;Always gives optimal solution.&quot;&quot;&quot;
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for a in range(1, amount + 1):
        for coin in coins:
            if coin &lt;= a and dp[a - coin] != float('inf'):
                dp[a] = min(dp[a], dp[a - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1


# Test
coins = [1, 3, 4]
amount = 6
print(coin_change_greedy(coins, amount))  # 3 (4+1+1) âŒ
print(coin_change_dp(coins, amount))      # 2 (3+3) âœ…
</code></pre>
<hr />
<h2>3. Problemas ClÃ¡sicos Greedy {#3-clasicos}</h2>
<h3>3.1 Activity Selection</h3>
<pre><code class="language-python">def activity_selection(
    start: list[int],
    end: list[int]
) -&gt; list[int]:
    &quot;&quot;&quot;Select maximum non-overlapping activities.

    GREEDY: Always pick activity that ends earliest.

    Example:
        &gt;&gt;&gt; activity_selection([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9])
        [0, 1, 3, 4]  # Activities 0, 1, 3, 4 (indices)

    Time: O(n log n) for sorting
    &quot;&quot;&quot;
    n = len(start)

    # Create activities with indices
    activities = [(start[i], end[i], i) for i in range(n)]

    # Sort by end time (greedy criterion)
    activities.sort(key=lambda x: x[1])

    selected = [activities[0][2]]  # Select first (earliest ending)
    last_end = activities[0][1]

    for s, e, idx in activities[1:]:
        if s &gt;= last_end:  # Doesn't overlap
            selected.append(idx)
            last_end = e

    return selected
</code></pre>
<h3>3.2 Fractional Knapsack</h3>
<pre><code class="language-python">def fractional_knapsack(
    weights: list[float],
    values: list[float],
    capacity: float
) -&gt; float:
    &quot;&quot;&quot;Fractional Knapsack - can take fractions of items.

    GREEDY: Take items with best value/weight ratio first.

    Note: Unlike 0/1 knapsack, greedy works here because
    we can take fractions.

    Time: O(n log n)
    &quot;&quot;&quot;
    n = len(weights)

    # Calculate value per unit weight
    ratios = [(values[i] / weights[i], weights[i], values[i]) 
              for i in range(n)]

    # Sort by ratio (descending)
    ratios.sort(reverse=True)

    total_value = 0.0
    remaining = capacity

    for ratio, weight, value in ratios:
        if remaining &gt;= weight:
            # Take whole item
            total_value += value
            remaining -= weight
        else:
            # Take fraction
            total_value += ratio * remaining
            break

    return total_value
</code></pre>
<h3>3.3 Huffman Coding (Preview)</h3>
<pre><code class="language-python">import heapq
from typing import Optional


class HuffmanNode:
    def __init__(self, char: Optional[str], freq: int):
        self.char = char
        self.freq = freq
        self.left: Optional[HuffmanNode] = None
        self.right: Optional[HuffmanNode] = None

    def __lt__(self, other):
        return self.freq &lt; other.freq


def huffman_tree(freq: dict[str, int]) -&gt; HuffmanNode:
    &quot;&quot;&quot;Build Huffman tree using greedy algorithm.

    GREEDY: Always merge two nodes with lowest frequency.

    Used for optimal prefix-free encoding.
    &quot;&quot;&quot;
    # Create leaf nodes and add to min-heap
    heap = [HuffmanNode(char, f) for char, f in freq.items()]
    heapq.heapify(heap)

    while len(heap) &gt; 1:
        # Take two smallest
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)

        # Merge
        merged = HuffmanNode(None, left.freq + right.freq)
        merged.left = left
        merged.right = right

        heapq.heappush(heap, merged)

    return heap[0]
</code></pre>
<h3>3.4 Jump Game</h3>
<pre><code class="language-python">def can_jump(nums: list[int]) -&gt; bool:
    &quot;&quot;&quot;Can reach the last index from first?

    nums[i] = max jump length from position i.

    GREEDY: Track the farthest reachable position.

    Example:
        &gt;&gt;&gt; can_jump([2, 3, 1, 1, 4])
        True
        &gt;&gt;&gt; can_jump([3, 2, 1, 0, 4])
        False
    &quot;&quot;&quot;
    farthest = 0

    for i, jump in enumerate(nums):
        if i &gt; farthest:
            # Can't reach this position
            return False
        farthest = max(farthest, i + jump)
        if farthest &gt;= len(nums) - 1:
            return True

    return True
</code></pre>
<h3>3.5 Interval Scheduling</h3>
<pre><code class="language-python">def min_meeting_rooms(intervals: list[tuple[int, int]]) -&gt; int:
    &quot;&quot;&quot;Minimum meeting rooms needed.

    GREEDY: Process events in order, track active meetings.
    &quot;&quot;&quot;
    if not intervals:
        return 0

    # Create events: (time, is_start)
    events = []
    for start, end in intervals:
        events.append((start, 1))   # Meeting starts
        events.append((end, -1))    # Meeting ends

    # Sort by time, ends before starts if same time
    events.sort(key=lambda x: (x[0], x[1]))

    rooms_needed = 0
    current_rooms = 0

    for time, delta in events:
        current_rooms += delta
        rooms_needed = max(rooms_needed, current_rooms)

    return rooms_needed
</code></pre>
<hr />
<h2>4. CÃ³mo Probar Correctitud {#4-probar}</h2>
<h3>4.1 TÃ©cnicas de DemostraciÃ³n</h3>
<pre><code>EXCHANGE ARGUMENT:
1. Suponer que existe soluciÃ³n Ã³ptima diferente de la greedy
2. Mostrar que podemos &quot;intercambiar&quot; para llegar a soluciÃ³n greedy
3. Sin empeorar la calidad
4. Por tanto, greedy tambiÃ©n es Ã³ptimo

STAYING AHEAD:
1. Mostrar que despuÃ©s de cada paso, greedy estÃ¡ &quot;adelante&quot;
2. Greedy es al menos tan bueno como cualquier otra opciÃ³n
3. Por inducciÃ³n, greedy termina Ã³ptimo
</code></pre>
<h3>4.2 Ejemplo: Activity Selection</h3>
<pre><code>CLAIM: Greedy (elegir por end time) es Ã³ptimo.

PROOF (Exchange):
1. Sea OPT soluciÃ³n Ã³ptima, G soluciÃ³n greedy
2. Si OPT â‰  G, existe primera actividad diferente
3. Sea aâ‚ la primera actividad de G (menor end time)
4. Sea bâ‚ la primera de OPT (end time â‰¥ aâ‚)
5. Podemos reemplazar bâ‚ por aâ‚ en OPT:
   - No crea conflictos (aâ‚ termina antes)
   - Misma cantidad de actividades
6. Repetir hasta OPT = G
7. Por tanto, G es Ã³ptimo âœ“
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes</h2>
<h3>Error 1: Asumir que greedy siempre funciona</h3>
<pre><code class="language-python"># âŒ Greedy no siempre da Ã³ptimo
# Siempre verificar si el problema tiene greedy choice property
</code></pre>
<h3>Error 2: Criterio de ordenamiento incorrecto</h3>
<pre><code class="language-python"># Activity Selection
# âŒ Ordenar por duraciÃ³n
activities.sort(key=lambda x: x[1] - x[0])  # Incorrecto

# âœ… Ordenar por tiempo de fin
activities.sort(key=lambda x: x[1])  # Correcto
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 17.1: Activity Selection</h3>
<h3>Ejercicio 17.2: Fractional Knapsack</h3>
<h3>Ejercicio 17.3: Jump Game</h3>
<h3>Ejercicio 17.4: Minimum Meeting Rooms</h3>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.youtube.com/watch?v=2P-yW7LQr08">Greedy Algorithms - MIT</a></td>
<td>Video</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://www.geeksforgeeks.org/greedy-algorithms/">When Greedy Works</a></td>
<td>GuÃ­a</td>
<td>ğŸŸ¡ Recomendado</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_16_DYNAMIC_PROGRAMMING">16_DYNAMIC_PROGRAMMING</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_18_HEAPS">18_HEAPS</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_18_HEAPS" class="cover-page">
            <a name="mod_18_HEAPS"></a>
            <div class="cover-title">18 - Heaps y Priority Queues</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>18 - Heaps y Priority Queues</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Dominar heaps para problemas de "top K" y scheduling.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: La Sala de Emergencias</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   PRIORITY QUEUE = Sala de emergencias del hospital                         â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                         â”‚
â”‚                                                                             â”‚
â”‚   No es &quot;primero en llegar, primero en atender&quot; (FIFO)                      â”‚
â”‚   Es &quot;mÃ¡s urgente primero&quot;                                                  â”‚
â”‚                                                                             â”‚
â”‚   Pacientes: [dolor cabeza, infarto, gripe, accidente]                      â”‚
â”‚   Orden de atenciÃ³n: infarto â†’ accidente â†’ gripe â†’ dolor cabeza             â”‚
â”‚                                                                             â”‚
â”‚   HEAP = Estructura eficiente para implementar Priority Queue               â”‚
â”‚                                                                             â”‚
â”‚   MIN-HEAP: El elemento mÃ¡s pequeÃ±o siempre arriba                          â”‚
â”‚   MAX-HEAP: El elemento mÃ¡s grande siempre arriba                           â”‚
â”‚                                                                             â”‚
â”‚                 1 (min)                    9 (max)                          â”‚
â”‚                / \                        / \                               â”‚
â”‚               3   2                      7   8                              â”‚
â”‚              / \                        / \                                 â”‚
â”‚             5   4                      3   5                                â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-estructura">Estructura del Heap</a></li>
<li><a href="#2-operaciones">Operaciones BÃ¡sicas</a></li>
<li><a href="#3-heapq">heapq en Python</a></li>
<li><a href="#4-problemas">Problemas ClÃ¡sicos</a></li>
</ol>
<hr />
<h2>1. Estructura del Heap {#1-estructura}</h2>
<h3>1.1 Propiedades del Heap</h3>
<pre><code>HEAP PROPERTY (Min-Heap):
- Cada nodo es MENOR o igual que sus hijos
- El mÃ­nimo siempre estÃ¡ en la raÃ­z

COMPLETE BINARY TREE:
- Todos los niveles llenos excepto el Ãºltimo
- Ãšltimo nivel lleno de izquierda a derecha

REPRESENTACIÃ“N EN ARRAY:
Para nodo en Ã­ndice i:
- Parent: (i - 1) // 2
- Left child: 2*i + 1
- Right child: 2*i + 2

Array: [1, 3, 2, 5, 4]

        1 (idx 0)
       / \
      3   2 (idx 1, 2)
     / \
    5   4 (idx 3, 4)
</code></pre>
<h3>1.2 ImplementaciÃ³n desde Cero</h3>
<pre><code class="language-python">class MinHeap:
    &quot;&quot;&quot;Min-heap implementation from scratch.

    Smallest element always at root (index 0).
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self._heap: list[int] = []

    def _parent(self, i: int) -&gt; int:
        return (i - 1) // 2

    def _left_child(self, i: int) -&gt; int:
        return 2 * i + 1

    def _right_child(self, i: int) -&gt; int:
        return 2 * i + 2

    def _swap(self, i: int, j: int) -&gt; None:
        self._heap[i], self._heap[j] = self._heap[j], self._heap[i]

    def _sift_up(self, i: int) -&gt; None:
        &quot;&quot;&quot;Move element up until heap property restored.&quot;&quot;&quot;
        while i &gt; 0:
            parent = self._parent(i)
            if self._heap[i] &lt; self._heap[parent]:
                self._swap(i, parent)
                i = parent
            else:
                break

    def _sift_down(self, i: int) -&gt; None:
        &quot;&quot;&quot;Move element down until heap property restored.&quot;&quot;&quot;
        size = len(self._heap)
        while True:
            smallest = i
            left = self._left_child(i)
            right = self._right_child(i)

            if left &lt; size and self._heap[left] &lt; self._heap[smallest]:
                smallest = left
            if right &lt; size and self._heap[right] &lt; self._heap[smallest]:
                smallest = right

            if smallest != i:
                self._swap(i, smallest)
                i = smallest
            else:
                break

    def push(self, value: int) -&gt; None:
        &quot;&quot;&quot;Add element to heap. O(log n)&quot;&quot;&quot;
        self._heap.append(value)
        self._sift_up(len(self._heap) - 1)

    def pop(self) -&gt; int:
        &quot;&quot;&quot;Remove and return minimum. O(log n)&quot;&quot;&quot;
        if not self._heap:
            raise IndexError(&quot;Pop from empty heap&quot;)

        min_val = self._heap[0]

        # Move last element to root
        self._heap[0] = self._heap[-1]
        self._heap.pop()

        # Restore heap property
        if self._heap:
            self._sift_down(0)

        return min_val

    def peek(self) -&gt; int:
        &quot;&quot;&quot;Return minimum without removing. O(1)&quot;&quot;&quot;
        if not self._heap:
            raise IndexError(&quot;Peek at empty heap&quot;)
        return self._heap[0]

    def __len__(self) -&gt; int:
        return len(self._heap)

    def __bool__(self) -&gt; bool:
        return len(self._heap) &gt; 0
</code></pre>
<hr />
<h2>2. Operaciones BÃ¡sicas {#2-operaciones}</h2>
<h3>2.1 Complejidades</h3>
<table>
<thead>
<tr>
<th>OperaciÃ³n</th>
<th>Complejidad</th>
<th>DescripciÃ³n</th>
</tr>
</thead>
<tbody>
<tr>
<td>push</td>
<td>O(log n)</td>
<td>Agregar elemento</td>
</tr>
<tr>
<td>pop</td>
<td>O(log n)</td>
<td>Extraer mÃ­nimo/mÃ¡ximo</td>
</tr>
<tr>
<td>peek</td>
<td>O(1)</td>
<td>Ver mÃ­nimo/mÃ¡ximo</td>
</tr>
<tr>
<td>heapify</td>
<td>O(n)</td>
<td>Convertir array a heap</td>
</tr>
</tbody>
</table>
<h3>2.2 Heapify (Convertir Array a Heap)</h3>
<pre><code class="language-python">def heapify(arr: list[int]) -&gt; None:
    &quot;&quot;&quot;Convert array to min-heap in-place. O(n)

    Start from last non-leaf node and sift down.
    &quot;&quot;&quot;
    n = len(arr)

    # Start from last non-leaf node
    for i in range(n // 2 - 1, -1, -1):
        _sift_down_arr(arr, n, i)


def _sift_down_arr(arr: list[int], n: int, i: int) -&gt; None:
    &quot;&quot;&quot;Sift down for array.&quot;&quot;&quot;
    while True:
        smallest = i
        left = 2 * i + 1
        right = 2 * i + 2

        if left &lt; n and arr[left] &lt; arr[smallest]:
            smallest = left
        if right &lt; n and arr[right] &lt; arr[smallest]:
            smallest = right

        if smallest != i:
            arr[i], arr[smallest] = arr[smallest], arr[i]
            i = smallest
        else:
            break
</code></pre>
<hr />
<h2>3. heapq en Python {#3-heapq}</h2>
<h3>3.1 Uso BÃ¡sico</h3>
<pre><code class="language-python">import heapq

# MIN-HEAP (default en Python)
heap: list[int] = []

heapq.heappush(heap, 3)
heapq.heappush(heap, 1)
heapq.heappush(heap, 4)
heapq.heappush(heap, 1)

print(heap)  # [1, 1, 4, 3] - estructura interna

print(heapq.heappop(heap))  # 1 (mÃ­nimo)
print(heapq.heappop(heap))  # 1
print(heapq.heappop(heap))  # 3

# Peek without removing
print(heap[0])  # 4 (mÃ­nimo actual)

# Convert existing list to heap
nums = [5, 3, 8, 1, 2]
heapq.heapify(nums)  # O(n) - modifica in-place
print(nums)  # [1, 2, 8, 5, 3]
</code></pre>
<h3>3.2 Max-Heap Trick</h3>
<pre><code class="language-python"># Python solo tiene min-heap
# Para max-heap: negar los valores

import heapq

nums = [3, 1, 4, 1, 5]
max_heap = [-x for x in nums]
heapq.heapify(max_heap)

# Extraer mÃ¡ximo
max_val = -heapq.heappop(max_heap)  # 5

# Insertar
heapq.heappush(max_heap, -10)  # Insertar 10
</code></pre>
<h3>3.3 Heap con Tuplas (Prioridad Custom)</h3>
<pre><code class="language-python">import heapq

# (priority, data) - ordena por primer elemento
tasks = []
heapq.heappush(tasks, (3, &quot;low priority&quot;))
heapq.heappush(tasks, (1, &quot;high priority&quot;))
heapq.heappush(tasks, (2, &quot;medium priority&quot;))

while tasks:
    priority, task = heapq.heappop(tasks)
    print(f&quot;Processing: {task}&quot;)
# high priority â†’ medium priority â†’ low priority
</code></pre>
<hr />
<h2>4. Problemas ClÃ¡sicos {#4-problemas}</h2>
<h3>4.1 K Largest Elements</h3>
<pre><code class="language-python">import heapq


def k_largest(nums: list[int], k: int) -&gt; list[int]:
    &quot;&quot;&quot;Find k largest elements.

    Use min-heap of size k.

    Time: O(n log k)
    Space: O(k)
    &quot;&quot;&quot;
    # Min-heap keeps k largest seen so far
    heap: list[int] = []

    for num in nums:
        if len(heap) &lt; k:
            heapq.heappush(heap, num)
        elif num &gt; heap[0]:
            heapq.heapreplace(heap, num)  # pop + push

    return sorted(heap, reverse=True)


# Alternative using nlargest
def k_largest_simple(nums: list[int], k: int) -&gt; list[int]:
    return heapq.nlargest(k, nums)
</code></pre>
<h3>4.2 Merge K Sorted Lists</h3>
<pre><code class="language-python">import heapq
from typing import Optional


class ListNode:
    def __init__(self, val: int = 0, next: 'ListNode' = None):
        self.val = val
        self.next = next


def merge_k_lists(lists: list[Optional[ListNode]]) -&gt; Optional[ListNode]:
    &quot;&quot;&quot;Merge k sorted linked lists.

    Use heap to always get smallest current element.

    Time: O(N log k) where N = total elements
    &quot;&quot;&quot;
    heap: list[tuple[int, int, ListNode]] = []

    # Add first node of each list
    for i, lst in enumerate(lists):
        if lst:
            heapq.heappush(heap, (lst.val, i, lst))

    dummy = ListNode()
    current = dummy

    while heap:
        val, idx, node = heapq.heappop(heap)
        current.next = node
        current = current.next

        if node.next:
            heapq.heappush(heap, (node.next.val, idx, node.next))

    return dummy.next
</code></pre>
<h3>4.3 Kth Smallest in Matrix</h3>
<pre><code class="language-python">import heapq


def kth_smallest(matrix: list[list[int]], k: int) -&gt; int:
    &quot;&quot;&quot;Find kth smallest in row/col sorted matrix.

    Use heap to explore in sorted order.
    &quot;&quot;&quot;
    n = len(matrix)
    # (value, row, col)
    heap = [(matrix[0][0], 0, 0)]
    visited = {(0, 0)}

    for _ in range(k):
        val, r, c = heapq.heappop(heap)

        # Add right neighbor
        if c + 1 &lt; n and (r, c + 1) not in visited:
            visited.add((r, c + 1))
            heapq.heappush(heap, (matrix[r][c + 1], r, c + 1))

        # Add bottom neighbor
        if r + 1 &lt; n and (r + 1, c) not in visited:
            visited.add((r + 1, c))
            heapq.heappush(heap, (matrix[r + 1][c], r + 1, c))

    return val
</code></pre>
<h3>4.4 Top K Frequent Elements</h3>
<pre><code class="language-python">import heapq
from collections import Counter


def top_k_frequent(nums: list[int], k: int) -&gt; list[int]:
    &quot;&quot;&quot;Find k most frequent elements.

    Time: O(n log k)
    &quot;&quot;&quot;
    count = Counter(nums)

    # Min-heap of (frequency, element)
    heap: list[tuple[int, int]] = []

    for num, freq in count.items():
        if len(heap) &lt; k:
            heapq.heappush(heap, (freq, num))
        elif freq &gt; heap[0][0]:
            heapq.heapreplace(heap, (freq, num))

    return [num for freq, num in heap]
</code></pre>
<h3>4.5 Median from Data Stream</h3>
<pre><code class="language-python">import heapq


class MedianFinder:
    &quot;&quot;&quot;Find median from continuous data stream.

    Use two heaps:
    - max_heap: smaller half
    - min_heap: larger half
    &quot;&quot;&quot;

    def __init__(self):
        self.small: list[int] = []  # max-heap (negated)
        self.large: list[int] = []  # min-heap

    def add_num(self, num: int) -&gt; None:
        &quot;&quot;&quot;Add number to stream. O(log n)&quot;&quot;&quot;
        # Add to max-heap (small)
        heapq.heappush(self.small, -num)

        # Balance: move largest from small to large
        heapq.heappush(self.large, -heapq.heappop(self.small))

        # Ensure small has &gt;= elements than large
        if len(self.large) &gt; len(self.small):
            heapq.heappush(self.small, -heapq.heappop(self.large))

    def find_median(self) -&gt; float:
        &quot;&quot;&quot;Get current median. O(1)&quot;&quot;&quot;
        if len(self.small) &gt; len(self.large):
            return -self.small[0]
        return (-self.small[0] + self.large[0]) / 2
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes</h2>
<h3>Error 1: Olvidar que heapq es min-heap</h3>
<pre><code class="language-python"># âŒ Esperar max-heap
import heapq
heap = [3, 1, 4]
heapq.heapify(heap)
print(heapq.heappop(heap))  # 1, no 4!

# âœ… Para max: negar valores
max_heap = [-x for x in [3, 1, 4]]
heapq.heapify(max_heap)
print(-heapq.heappop(max_heap))  # 4
</code></pre>
<h3>Error 2: Modificar heap directamente</h3>
<pre><code class="language-python"># âŒ Rompe la propiedad del heap
heap[0] = 100  # Â¡No hacer!

# âœ… Usar operaciones del heap
heapq.heapreplace(heap, new_value)  # pop + push
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 18.1: Implementar MinHeap desde cero</h3>
<h3>Ejercicio 18.2: K Largest Elements</h3>
<h3>Ejercicio 18.3: Top K Frequent</h3>
<h3>Ejercicio 18.4: Merge K Sorted Lists</h3>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://visualgo.net/en/heap">Visualgo Heap</a></td>
<td>Visual</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/heapq.html">heapq Documentation</a></td>
<td>Docs</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_17_GREEDY">17_GREEDY</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_12_PROYECTO_INTEGRADOR">12_PROYECTO_INTEGRADOR</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_10_ALGEBRA_LINEAL" class="cover-page">
            <a name="mod_10_ALGEBRA_LINEAL"></a>
            <div class="cover-title">10 - Ãlgebra Lineal</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>10 - Ãlgebra Lineal sin NumPy</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Implementar operaciones vectoriales y matriciales desde cero para entender la matemÃ¡tica detrÃ¡s del TF-IDF.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: Vectores como Flechas, Matrices como Transformaciones</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   VECTOR = Una flecha en el espacio                                         â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                         â”‚
â”‚                                                                             â”‚
â”‚   v = [3, 4]                                                                â”‚
â”‚                    â†— (3, 4)                                                 â”‚
â”‚                  â•±                                                          â”‚
â”‚                â•±                                                            â”‚
â”‚              â•±  â”‚                                                           â”‚
â”‚            â•±    â”‚ 4                                                         â”‚
â”‚          â•±      â”‚                                                           â”‚
â”‚        â—â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                           â”‚
â”‚     origen  3                                                               â”‚
â”‚                                                                             â”‚
â”‚   En Archimedes:                                                            â”‚
â”‚   â€¢ Cada documento es un vector en el &quot;espacio de palabras&quot;                 â”‚
â”‚   â€¢ DimensiÃ³n = nÃºmero de palabras Ãºnicas                                   â”‚
â”‚   â€¢ Valor = frecuencia/importancia de cada palabra                          â”‚
â”‚   â€¢ Similitud = quÃ© tan &quot;paralelos&quot; son dos vectores                        â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-vectores">Vectores como Listas</a></li>
<li><a href="#2-operaciones-vectoriales">Operaciones Vectoriales</a></li>
<li><a href="#3-producto-punto">Producto Punto y Norma</a></li>
<li><a href="#4-matrices">Matrices como Listas de Listas</a></li>
<li><a href="#5-operaciones-matriciales">Operaciones Matriciales</a></li>
</ol>
<hr />
<h2>1. Vectores como Listas {#1-vectores}</h2>
<h3>1.1 RepresentaciÃ³n</h3>
<pre><code class="language-python"># Un vector es simplemente una lista de nÃºmeros
Vector = list[float]

# Ejemplos
v1: Vector = [1.0, 2.0, 3.0]      # Vector 3D
v2: Vector = [0.5, 0.3, 0.8, 0.2] # Vector 4D

# En el contexto de TF-IDF:
# Cada posiciÃ³n corresponde a una palabra del vocabulario
# El valor es la importancia de esa palabra en el documento

vocabulary = [&quot;python&quot;, &quot;java&quot;, &quot;code&quot;, &quot;tutorial&quot;]
doc_vector: Vector = [0.8, 0.0, 0.5, 0.3]
# Significa: mucho &quot;python&quot;, nada de &quot;java&quot;, algo de &quot;code&quot; y &quot;tutorial&quot;
</code></pre>
<h3>1.2 Acceso y Longitud</h3>
<pre><code class="language-python">def get_dimension(v: Vector) -&gt; int:
    &quot;&quot;&quot;Return the dimension (number of components) of a vector.&quot;&quot;&quot;
    return len(v)


def get_component(v: Vector, index: int) -&gt; float:
    &quot;&quot;&quot;Get specific component of vector.&quot;&quot;&quot;
    if index &lt; 0 or index &gt;= len(v):
        raise IndexError(f&quot;Index {index} out of range for vector of dimension {len(v)}&quot;)
    return v[index]
</code></pre>
<hr />
<h2>2. Operaciones Vectoriales {#2-operaciones-vectoriales}</h2>
<h3>2.1 Suma de Vectores</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SUMA: Componente a componente                                  â”‚
â”‚                                                                 â”‚
â”‚  [1, 2, 3] + [4, 5, 6] = [1+4, 2+5, 3+6] = [5, 7, 9]            â”‚
â”‚                                                                 â”‚
â”‚  GeomÃ©tricamente: &quot;poner una flecha al final de otra&quot;           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<pre><code class="language-python">def add_vectors(v1: Vector, v2: Vector) -&gt; Vector:
    &quot;&quot;&quot;Add two vectors component-wise.

    Args:
        v1: First vector.
        v2: Second vector (must have same dimension as v1).

    Returns:
        New vector with sum of corresponding components.

    Raises:
        ValueError: If vectors have different dimensions.

    Example:
        &gt;&gt;&gt; add_vectors([1, 2, 3], [4, 5, 6])
        [5, 7, 9]
    &quot;&quot;&quot;
    if len(v1) != len(v2):
        raise ValueError(f&quot;Dimension mismatch: {len(v1)} vs {len(v2)}&quot;)

    return [a + b for a, b in zip(v1, v2)]
</code></pre>
<h3>2.2 Resta de Vectores</h3>
<pre><code class="language-python">def subtract_vectors(v1: Vector, v2: Vector) -&gt; Vector:
    &quot;&quot;&quot;Subtract v2 from v1 component-wise.

    Example:
        &gt;&gt;&gt; subtract_vectors([5, 7, 9], [4, 5, 6])
        [1, 2, 3]
    &quot;&quot;&quot;
    if len(v1) != len(v2):
        raise ValueError(f&quot;Dimension mismatch: {len(v1)} vs {len(v2)}&quot;)

    return [a - b for a, b in zip(v1, v2)]
</code></pre>
<h3>2.3 MultiplicaciÃ³n por Escalar</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ESCALAR Ã— VECTOR: Multiplica cada componente                   â”‚
â”‚                                                                 â”‚
â”‚  3 Ã— [1, 2, 3] = [3Ã—1, 3Ã—2, 3Ã—3] = [3, 6, 9]                    â”‚
â”‚                                                                 â”‚
â”‚  GeomÃ©tricamente: &quot;estirar&quot; o &quot;encoger&quot; la flecha               â”‚
â”‚  - Escalar &gt; 1: estira                                          â”‚
â”‚  - 0 &lt; Escalar &lt; 1: encoge                                      â”‚
â”‚  - Escalar &lt; 0: invierte direcciÃ³n                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<pre><code class="language-python">def scalar_multiply(scalar: float, v: Vector) -&gt; Vector:
    &quot;&quot;&quot;Multiply a vector by a scalar.

    Example:
        &gt;&gt;&gt; scalar_multiply(3, [1, 2, 3])
        [3, 6, 9]
        &gt;&gt;&gt; scalar_multiply(0.5, [4, 6])
        [2.0, 3.0]
    &quot;&quot;&quot;
    return [scalar * component for component in v]
</code></pre>
<hr />
<h2>3. Producto Punto y Norma {#3-producto-punto}</h2>
<h3>3.1 Producto Punto (Dot Product)</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PRODUCTO PUNTO: Suma de productos componente a componente      â”‚
â”‚                                                                 â”‚
â”‚  [1, 2, 3] Â· [4, 5, 6] = 1Ã—4 + 2Ã—5 + 3Ã—6 = 4 + 10 + 18 = 32     â”‚
â”‚                                                                 â”‚
â”‚  SIGNIFICADO GEOMÃ‰TRICO:                                        â”‚
â”‚  v1 Â· v2 = |v1| Ã— |v2| Ã— cos(Î¸)                                 â”‚
â”‚                                                                 â”‚
â”‚  Donde Î¸ es el Ã¡ngulo entre los vectores.                       â”‚
â”‚                                                                 â”‚
â”‚  Si cos(Î¸) = 1 (Î¸ = 0Â°): vectores paralelos, misma direcciÃ³n    â”‚
â”‚  Si cos(Î¸) = 0 (Î¸ = 90Â°): vectores perpendiculares              â”‚
â”‚  Si cos(Î¸) = -1 (Î¸ = 180Â°): direcciones opuestas                â”‚
â”‚                                                                 â”‚
â”‚  EN ARCHIMEDES: Mide quÃ© tan &quot;similares&quot; son dos documentos     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<pre><code class="language-python">def dot_product(v1: Vector, v2: Vector) -&gt; float:
    &quot;&quot;&quot;Compute dot product of two vectors.

    Also known as inner product or scalar product.

    Args:
        v1: First vector.
        v2: Second vector (same dimension as v1).

    Returns:
        Scalar result of dot product.

    Example:
        &gt;&gt;&gt; dot_product([1, 2, 3], [4, 5, 6])
        32
        &gt;&gt;&gt; dot_product([1, 0], [0, 1])  # Perpendicular
        0
    &quot;&quot;&quot;
    if len(v1) != len(v2):
        raise ValueError(f&quot;Dimension mismatch: {len(v1)} vs {len(v2)}&quot;)

    return sum(a * b for a, b in zip(v1, v2))
</code></pre>
<h3>3.2 Norma (Magnitud)</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  NORMA = Longitud del vector                                    â”‚
â”‚                                                                 â”‚
â”‚  ||v|| = âˆš(vâ‚Â² + vâ‚‚Â² + ... + vâ‚™Â²)                               â”‚
â”‚                                                                 â”‚
â”‚  Ejemplo: ||[3, 4]|| = âˆš(9 + 16) = âˆš25 = 5                      â”‚
â”‚                                                                 â”‚
â”‚  Nota: ||v||Â² = v Â· v  (producto punto consigo mismo)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<pre><code class="language-python">import math


def magnitude(v: Vector) -&gt; float:
    &quot;&quot;&quot;Compute the magnitude (length/norm) of a vector.

    Also known as Euclidean norm or L2 norm.

    Formula: ||v|| = sqrt(v1Â² + v2Â² + ... + vnÂ²)

    Example:
        &gt;&gt;&gt; magnitude([3, 4])
        5.0
        &gt;&gt;&gt; magnitude([1, 0, 0])
        1.0
    &quot;&quot;&quot;
    return math.sqrt(sum(component ** 2 for component in v))


def magnitude_squared(v: Vector) -&gt; float:
    &quot;&quot;&quot;Compute squared magnitude (avoids sqrt for comparisons).

    Useful when you only need to compare magnitudes.
    &quot;&quot;&quot;
    return sum(component ** 2 for component in v)
</code></pre>
<h3>3.3 NormalizaciÃ³n (Vector Unitario)</h3>
<pre><code class="language-python">def normalize(v: Vector) -&gt; Vector:
    &quot;&quot;&quot;Return unit vector (magnitude = 1) in same direction.

    Formula: vÌ‚ = v / ||v||

    Example:
        &gt;&gt;&gt; normalize([3, 4])
        [0.6, 0.8]  # magnitude = 1.0

    Raises:
        ValueError: If vector has zero magnitude.
    &quot;&quot;&quot;
    mag = magnitude(v)

    if mag == 0:
        raise ValueError(&quot;Cannot normalize zero vector&quot;)

    return [component / mag for component in v]
</code></pre>
<h3>3.4 Similitud de Coseno (Â¡Crucial para Archimedes!)</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SIMILITUD DE COSENO                                            â”‚
â”‚                                                                 â”‚
â”‚                    v1 Â· v2                                      â”‚
â”‚  cos(Î¸) = â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                 â”‚
â”‚            ||v1|| Ã— ||v2||                                      â”‚
â”‚                                                                 â”‚
â”‚  Resultado:                                                     â”‚
â”‚  â€¢ 1: Vectores idÃ©nticos en direcciÃ³n (muy similares)           â”‚
â”‚  â€¢ 0: Vectores perpendiculares (nada en comÃºn)                  â”‚
â”‚  â€¢ -1: Direcciones opuestas (para TF-IDF, raro)                 â”‚
â”‚                                                                 â”‚
â”‚  EN ARCHIMEDES: Documentos con palabras similares tendrÃ¡n       â”‚
â”‚  coseno cercano a 1                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<pre><code class="language-python">def cosine_similarity(v1: Vector, v2: Vector) -&gt; float:
    &quot;&quot;&quot;Compute cosine similarity between two vectors.

    Measures the cosine of the angle between vectors.

    Returns:
        Value between -1 and 1 (usually 0 to 1 for TF-IDF).
        1 = identical direction, 0 = perpendicular.

    Example:
        &gt;&gt;&gt; cosine_similarity([1, 0], [1, 0])
        1.0
        &gt;&gt;&gt; cosine_similarity([1, 0], [0, 1])
        0.0
        &gt;&gt;&gt; cosine_similarity([1, 1], [1, 1])
        1.0
    &quot;&quot;&quot;
    if len(v1) != len(v2):
        raise ValueError(f&quot;Dimension mismatch: {len(v1)} vs {len(v2)}&quot;)

    dot = dot_product(v1, v2)
    mag1 = magnitude(v1)
    mag2 = magnitude(v2)

    # Handle zero vectors
    if mag1 == 0 or mag2 == 0:
        return 0.0

    return dot / (mag1 * mag2)
</code></pre>
<hr />
<h2>4. Matrices como Listas de Listas {#4-matrices}</h2>
<h3>4.1 RepresentaciÃ³n</h3>
<pre><code class="language-python"># Matriz = lista de filas, cada fila es un vector
Matrix = list[list[float]]

# Ejemplo: matriz 2x3 (2 filas, 3 columnas)
m: Matrix = [
    [1, 2, 3],  # Fila 0
    [4, 5, 6]   # Fila 1
]

# Acceso: m[fila][columna]
# m[0][0] = 1, m[0][2] = 3, m[1][1] = 5
</code></pre>
<h3>4.2 Funciones de InformaciÃ³n</h3>
<pre><code class="language-python">def get_shape(m: Matrix) -&gt; tuple[int, int]:
    &quot;&quot;&quot;Return (rows, columns) of matrix.

    Example:
        &gt;&gt;&gt; get_shape([[1, 2, 3], [4, 5, 6]])
        (2, 3)
    &quot;&quot;&quot;
    if not m:
        return (0, 0)
    return (len(m), len(m[0]))


def get_element(m: Matrix, row: int, col: int) -&gt; float:
    &quot;&quot;&quot;Get element at (row, col).&quot;&quot;&quot;
    return m[row][col]


def get_row(m: Matrix, row: int) -&gt; Vector:
    &quot;&quot;&quot;Get a row as vector.&quot;&quot;&quot;
    return m[row].copy()


def get_column(m: Matrix, col: int) -&gt; Vector:
    &quot;&quot;&quot;Get a column as vector.&quot;&quot;&quot;
    return [row[col] for row in m]
</code></pre>
<hr />
<h2>5. Operaciones Matriciales {#5-operaciones-matriciales}</h2>
<h3>5.1 Suma de Matrices</h3>
<pre><code class="language-python">def add_matrices(m1: Matrix, m2: Matrix) -&gt; Matrix:
    &quot;&quot;&quot;Add two matrices element-wise.

    Matrices must have same dimensions.

    Example:
        &gt;&gt;&gt; add_matrices([[1, 2], [3, 4]], [[5, 6], [7, 8]])
        [[6, 8], [10, 12]]
    &quot;&quot;&quot;
    rows1, cols1 = get_shape(m1)
    rows2, cols2 = get_shape(m2)

    if (rows1, cols1) != (rows2, cols2):
        raise ValueError(f&quot;Shape mismatch: {(rows1, cols1)} vs {(rows2, cols2)}&quot;)

    return [
        [m1[i][j] + m2[i][j] for j in range(cols1)]
        for i in range(rows1)
    ]
</code></pre>
<h3>5.2 MultiplicaciÃ³n por Escalar</h3>
<pre><code class="language-python">def scalar_multiply_matrix(scalar: float, m: Matrix) -&gt; Matrix:
    &quot;&quot;&quot;Multiply matrix by scalar.

    Example:
        &gt;&gt;&gt; scalar_multiply_matrix(2, [[1, 2], [3, 4]])
        [[2, 4], [6, 8]]
    &quot;&quot;&quot;
    return [
        [scalar * element for element in row]
        for row in m
    ]
</code></pre>
<h3>5.3 Transpuesta</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TRANSPUESTA: Intercambiar filas y columnas                     â”‚
â”‚                                                                 â”‚
â”‚  Original (2x3):        Transpuesta (3x2):                      â”‚
â”‚  [1, 2, 3]              [1, 4]                                  â”‚
â”‚  [4, 5, 6]              [2, 5]                                  â”‚
â”‚                         [3, 6]                                  â”‚
â”‚                                                                 â”‚
â”‚  FÃ³rmula: T[i][j] = M[j][i]                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<pre><code class="language-python">def transpose(m: Matrix) -&gt; Matrix:
    &quot;&quot;&quot;Transpose a matrix (swap rows and columns).

    Example:
        &gt;&gt;&gt; transpose([[1, 2, 3], [4, 5, 6]])
        [[1, 4], [2, 5], [3, 6]]
    &quot;&quot;&quot;
    if not m:
        return []

    rows, cols = get_shape(m)

    return [
        [m[i][j] for i in range(rows)]
        for j in range(cols)
    ]
</code></pre>
<h3>5.4 Producto Matriz-Vector</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MATRIZ Ã— VECTOR                                                â”‚
â”‚                                                                 â”‚
â”‚  [1, 2, 3]     [1]     [1Ã—1 + 2Ã—2 + 3Ã—3]     [14]               â”‚
â”‚  [4, 5, 6]  Ã—  [2]  =  [4Ã—1 + 5Ã—2 + 6Ã—3]  =  [32]               â”‚
â”‚               [3]                                               â”‚
â”‚                                                                 â”‚
â”‚  Cada elemento del resultado = producto punto de una fila       â”‚
â”‚  con el vector                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<pre><code class="language-python">def matrix_vector_multiply(m: Matrix, v: Vector) -&gt; Vector:
    &quot;&quot;&quot;Multiply matrix by vector.

    Matrix must have columns = len(v).
    Result has length = rows of matrix.

    Example:
        &gt;&gt;&gt; matrix_vector_multiply([[1, 2, 3], [4, 5, 6]], [1, 2, 3])
        [14, 32]
    &quot;&quot;&quot;
    rows, cols = get_shape(m)

    if cols != len(v):
        raise ValueError(f&quot;Dimension mismatch: matrix has {cols} cols, vector has {len(v)} elements&quot;)

    return [dot_product(row, v) for row in m]
</code></pre>
<h3>5.5 Producto Matriz-Matriz (Opcional pero Ãºtil)</h3>
<pre><code class="language-python">def matrix_multiply(m1: Matrix, m2: Matrix) -&gt; Matrix:
    &quot;&quot;&quot;Multiply two matrices.

    m1 must have cols = m2 rows.
    Result shape: (m1 rows, m2 cols).

    Example:
        &gt;&gt;&gt; matrix_multiply([[1, 2], [3, 4]], [[5, 6], [7, 8]])
        [[19, 22], [43, 50]]
    &quot;&quot;&quot;
    rows1, cols1 = get_shape(m1)
    rows2, cols2 = get_shape(m2)

    if cols1 != rows2:
        raise ValueError(f&quot;Cannot multiply: m1 has {cols1} cols, m2 has {rows2} rows&quot;)

    # Result[i][j] = dot product of m1 row i with m2 column j
    result = []
    for i in range(rows1):
        row = []
        for j in range(cols2):
            val = sum(m1[i][k] * m2[k][j] for k in range(cols1))
            row.append(val)
        result.append(row)

    return result
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes</h2>
<h3>Error 1: Modificar vectores originales</h3>
<pre><code class="language-python"># âŒ Modifica el vector original
def normalize_bad(v: Vector) -&gt; Vector:
    mag = magnitude(v)
    for i in range(len(v)):
        v[i] /= mag  # Modifica v!
    return v

# âœ… Crear nuevo vector
def normalize_good(v: Vector) -&gt; Vector:
    mag = magnitude(v)
    return [x / mag for x in v]
</code></pre>
<h3>Error 2: DivisiÃ³n por cero en normalizaciÃ³n</h3>
<pre><code class="language-python"># âŒ Falla con vector cero
def normalize_bad(v):
    mag = magnitude(v)
    return [x / mag for x in v]  # ZeroDivisionError!

# âœ… Manejar caso especial
def normalize_good(v):
    mag = magnitude(v)
    if mag == 0:
        raise ValueError(&quot;Cannot normalize zero vector&quot;)
    return [x / mag for x in v]
</code></pre>
<h3>Error 3: Comparar floats con ==</h3>
<pre><code class="language-python"># âŒ Puede fallar por precisiÃ³n de punto flotante
if magnitude(v) == 1.0:
    print(&quot;Unit vector&quot;)

# âœ… Usar tolerancia
if abs(magnitude(v) - 1.0) &lt; 1e-9:
    print(&quot;Unit vector&quot;)
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 10.1: Operaciones Vectoriales</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 10.2: Producto Punto y Norma</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 10.3: Similitud de Coseno</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">3Blue1Brown: Linear Algebra</a></td>
<td>Video</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://www.coursera.org/learn/linear-algebra-machine-learning">Mathematics for ML: Linear Algebra</a></td>
<td>Curso</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://www.khanacademy.org/math/linear-algebra">Khan Academy Linear Algebra</a></td>
<td>Curso</td>
<td>ğŸŸ¡ Recomendado</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ”— Referencias del Glosario</h2>
<ul>
<li><a href="#mod_GLOSARIO">Vector</a></li>
<li><a href="#mod_GLOSARIO">Matriz</a></li>
<li><a href="#mod_GLOSARIO">Producto Punto</a></li>
<li><a href="#mod_GLOSARIO">Norma</a></li>
<li><a href="#mod_GLOSARIO">Similitud de Coseno</a></li>
</ul>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_09_BINARY_SEARCH">09_BINARY_SEARCH</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_11_TFIDF_COSENO">11_TFIDF_COSENO</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_11_TFIDF_COSENO" class="cover-page">
            <a name="mod_11_TFIDF_COSENO"></a>
            <div class="cover-title">11 - TF-IDF y Similitud de Coseno</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>11 - TF-IDF y Similitud de Coseno</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Implementar el sistema de ranking por relevancia del motor de bÃºsqueda usando TF-IDF y similitud de coseno.</p>
</blockquote>
<hr />
<h2>ğŸ§  AnalogÃ­a: Encontrar el Libro Correcto en una Biblioteca</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   PROBLEMA: Buscar &quot;python machine learning&quot; en 1000 documentos             â”‚
â”‚                                                                             â”‚
â”‚   OPCIÃ“N 1: Solo contar palabras                                            â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                         â”‚
â”‚   Doc A: &quot;python python python&quot; â†’ 3 menciones de &quot;python&quot;                   â”‚
â”‚   Doc B: &quot;python machine learning tutorial&quot; â†’ 1 menciÃ³n                     â”‚
â”‚   Â¿Doc A es mejor? Â¡No! Solo repite la palabra.                             â”‚
â”‚                                                                             â”‚
â”‚   OPCIÃ“N 2: TF-IDF                                                          â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                          â”‚
â”‚   â€¢ TF (Term Frequency): Â¿CuÃ¡nto aparece la palabra en ESTE documento?      â”‚
â”‚   â€¢ IDF (Inverse Document Frequency): Â¿QuÃ© tan RARA es en TODOS los docs?   â”‚
â”‚                                                                             â”‚
â”‚   Palabras como &quot;the&quot;, &quot;is&quot; â†’ aparecen en todos â†’ IDF bajo â†’ poco Ãºtiles    â”‚
â”‚   Palabras como &quot;tensorflow&quot; â†’ aparece en pocos â†’ IDF alto â†’ muy Ãºtiles     â”‚
â”‚                                                                             â”‚
â”‚   TF-IDF = TF Ã— IDF â†’ Balance entre frecuencia y rareza                     â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“‹ Contenido</h2>
<ol>
<li><a href="#1-tf">Term Frequency (TF)</a></li>
<li><a href="#2-idf">Inverse Document Frequency (IDF)</a></li>
<li><a href="#3-tfidf">TF-IDF Combinado</a></li>
<li><a href="#4-vectorizacion">VectorizaciÃ³n de Documentos</a></li>
<li><a href="#5-ranking">Ranking con Similitud de Coseno</a></li>
<li><a href="#6-integracion">IntegraciÃ³n en Archimedes</a></li>
</ol>
<hr />
<h2>1. Term Frequency (TF) {#1-tf}</h2>
<h3>1.1 Concepto</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TF = Â¿CuÃ¡ntas veces aparece el tÃ©rmino en este documento?      â”‚
â”‚                                                                 â”‚
â”‚  Documento: &quot;the cat sat on the mat&quot;                            â”‚
â”‚  Tokens: [&quot;the&quot;, &quot;cat&quot;, &quot;sat&quot;, &quot;on&quot;, &quot;the&quot;, &quot;mat&quot;]              â”‚
â”‚                                                                 â”‚
â”‚  TF(&quot;the&quot;) = 2/6 = 0.333                                        â”‚
â”‚  TF(&quot;cat&quot;) = 1/6 = 0.167                                        â”‚
â”‚  TF(&quot;dog&quot;) = 0/6 = 0.000                                        â”‚
â”‚                                                                 â”‚
â”‚  FÃ“RMULA:                                                       â”‚
â”‚                count(term, document)                            â”‚
â”‚  TF(t, d) = â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                           â”‚
â”‚              total_terms(document)                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>1.2 ImplementaciÃ³n</h3>
<pre><code class="language-python">def compute_tf(term: str, document: list[str]) -&gt; float:
    &quot;&quot;&quot;Compute Term Frequency for a term in a document.

    TF measures how often a term appears in a document,
    normalized by document length.

    Args:
        term: The word to compute TF for.
        document: List of tokens in the document.

    Returns:
        TF value between 0 and 1.

    Example:
        &gt;&gt;&gt; compute_tf(&quot;the&quot;, [&quot;the&quot;, &quot;cat&quot;, &quot;sat&quot;, &quot;on&quot;, &quot;the&quot;, &quot;mat&quot;])
        0.3333333333333333
    &quot;&quot;&quot;
    if not document:
        return 0.0

    count = document.count(term)
    return count / len(document)


def compute_tf_vector(document: list[str], vocabulary: list[str]) -&gt; list[float]:
    &quot;&quot;&quot;Compute TF for all terms in vocabulary.

    Args:
        document: List of tokens in document.
        vocabulary: List of all unique terms across corpus.

    Returns:
        Vector where each position is TF of corresponding vocabulary term.

    Example:
        &gt;&gt;&gt; vocab = [&quot;cat&quot;, &quot;dog&quot;, &quot;mat&quot;, &quot;sat&quot;, &quot;the&quot;]
        &gt;&gt;&gt; doc = [&quot;the&quot;, &quot;cat&quot;, &quot;sat&quot;, &quot;on&quot;, &quot;the&quot;, &quot;mat&quot;]
        &gt;&gt;&gt; compute_tf_vector(doc, vocab)
        [0.167, 0.0, 0.167, 0.167, 0.333]  # approximately
    &quot;&quot;&quot;
    return [compute_tf(term, document) for term in vocabulary]
</code></pre>
<h3>1.3 Variantes de TF</h3>
<pre><code class="language-python">def compute_tf_raw(term: str, document: list[str]) -&gt; int:
    &quot;&quot;&quot;Raw count (no normalization).&quot;&quot;&quot;
    return document.count(term)


def compute_tf_log(term: str, document: list[str]) -&gt; float:
    &quot;&quot;&quot;Logarithmic TF: reduces impact of high frequency.

    Formula: 1 + log(count) if count &gt; 0, else 0
    &quot;&quot;&quot;
    import math
    count = document.count(term)
    if count == 0:
        return 0.0
    return 1 + math.log(count)


def compute_tf_binary(term: str, document: list[str]) -&gt; int:
    &quot;&quot;&quot;Binary TF: 1 if present, 0 otherwise.&quot;&quot;&quot;
    return 1 if term in document else 0
</code></pre>
<hr />
<h2>2. Inverse Document Frequency (IDF) {#2-idf}</h2>
<h3>2.1 Concepto</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  IDF = Â¿QuÃ© tan rara es esta palabra en todo el corpus?         â”‚
â”‚                                                                 â”‚
â”‚  Corpus de 1000 documentos:                                     â”‚
â”‚  â€¢ &quot;the&quot; aparece en 950 docs â†’ muy comÃºn â†’ IDF bajo             â”‚
â”‚  â€¢ &quot;python&quot; aparece en 50 docs â†’ algo rara â†’ IDF medio          â”‚
â”‚  â€¢ &quot;tensorflow&quot; aparece en 5 docs â†’ muy rara â†’ IDF alto         â”‚
â”‚                                                                 â”‚
â”‚  FÃ“RMULA:                                                       â”‚
â”‚                    total_documents                              â”‚
â”‚  IDF(t) = log( â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ )                      â”‚
â”‚                 documents_containing(t)                         â”‚
â”‚                                                                 â”‚
â”‚  El logaritmo suaviza los valores extremos                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>2.2 ImplementaciÃ³n</h3>
<pre><code class="language-python">import math


def compute_idf(term: str, corpus: list[list[str]]) -&gt; float:
    &quot;&quot;&quot;Compute Inverse Document Frequency for a term.

    IDF measures how rare a term is across the corpus.
    Rare terms get higher IDF.

    Args:
        term: The word to compute IDF for.
        corpus: List of documents (each document is list of tokens).

    Returns:
        IDF value (higher = more rare/important).

    Example:
        &gt;&gt;&gt; corpus = [[&quot;cat&quot;, &quot;dog&quot;], [&quot;cat&quot;, &quot;mouse&quot;], [&quot;dog&quot;, &quot;bird&quot;]]
        &gt;&gt;&gt; compute_idf(&quot;cat&quot;, corpus)
        0.405...  # appears in 2 of 3 docs
        &gt;&gt;&gt; compute_idf(&quot;bird&quot;, corpus)
        1.098...  # appears in 1 of 3 docs (more rare)
    &quot;&quot;&quot;
    if not corpus:
        return 0.0

    total_docs = len(corpus)
    docs_with_term = sum(1 for doc in corpus if term in doc)

    if docs_with_term == 0:
        return 0.0

    return math.log(total_docs / docs_with_term)


def compute_idf_smooth(term: str, corpus: list[list[str]]) -&gt; float:
    &quot;&quot;&quot;IDF with smoothing to avoid division by zero and extremes.

    Formula: log(1 + (N / (1 + df)))

    This variant:
    - Adds 1 to denominator to handle terms not in corpus
    - Adds 1 inside log to avoid negative values
    &quot;&quot;&quot;
    if not corpus:
        return 0.0

    total_docs = len(corpus)
    docs_with_term = sum(1 for doc in corpus if term in doc)

    return math.log(1 + (total_docs / (1 + docs_with_term)))
</code></pre>
<h3>2.3 Pre-computar IDF para Vocabulario</h3>
<pre><code class="language-python">def compute_idf_dict(
    vocabulary: list[str],
    corpus: list[list[str]]
) -&gt; dict[str, float]:
    &quot;&quot;&quot;Pre-compute IDF for all terms in vocabulary.

    More efficient than computing IDF repeatedly.

    Returns:
        Dictionary mapping term to its IDF value.
    &quot;&quot;&quot;
    return {term: compute_idf(term, corpus) for term in vocabulary}
</code></pre>
<hr />
<h2>3. TF-IDF Combinado {#3-tfidf}</h2>
<h3>3.1 La FÃ³rmula</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TF-IDF = TF Ã— IDF                                              â”‚
â”‚                                                                 â”‚
â”‚  Combina:                                                       â”‚
â”‚  â€¢ TF: Importancia local (en este documento)                    â”‚
â”‚  â€¢ IDF: Importancia global (en todo el corpus)                  â”‚
â”‚                                                                 â”‚
â”‚  RESULTADO:                                                     â”‚
â”‚  â€¢ Palabra comÃºn en este doc pero rara globalmente â†’ ALTO       â”‚
â”‚  â€¢ Palabra rara en este doc y comÃºn globalmente â†’ BAJO          â”‚
â”‚  â€¢ Palabra muy comÃºn en todos lados (&quot;the&quot;) â†’ MUY BAJO          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>3.2 ImplementaciÃ³n</h3>
<pre><code class="language-python">def compute_tfidf(
    term: str,
    document: list[str],
    corpus: list[list[str]]
) -&gt; float:
    &quot;&quot;&quot;Compute TF-IDF score for a term in a document.

    Args:
        term: Word to score.
        document: The specific document (list of tokens).
        corpus: All documents in the collection.

    Returns:
        TF-IDF score (higher = more important).

    Example:
        &gt;&gt;&gt; corpus = [[&quot;python&quot;, &quot;code&quot;], [&quot;java&quot;, &quot;code&quot;], [&quot;python&quot;, &quot;ml&quot;]]
        &gt;&gt;&gt; compute_tfidf(&quot;python&quot;, [&quot;python&quot;, &quot;code&quot;], corpus)
        0.203...  # &quot;python&quot; is somewhat distinctive
        &gt;&gt;&gt; compute_tfidf(&quot;code&quot;, [&quot;python&quot;, &quot;code&quot;], corpus)
        0.0  # &quot;code&quot; appears in too many docs (if 2/3)
    &quot;&quot;&quot;
    tf = compute_tf(term, document)
    idf = compute_idf(term, corpus)
    return tf * idf
</code></pre>
<h3>3.3 Vector TF-IDF Completo</h3>
<pre><code class="language-python">def compute_tfidf_vector(
    document: list[str],
    vocabulary: list[str],
    idf_dict: dict[str, float]
) -&gt; list[float]:
    &quot;&quot;&quot;Compute TF-IDF vector for a document.

    Args:
        document: Document as list of tokens.
        vocabulary: Ordered list of all terms.
        idf_dict: Pre-computed IDF values.

    Returns:
        Vector of TF-IDF values, one per vocabulary term.
    &quot;&quot;&quot;
    tfidf_vector = []

    for term in vocabulary:
        tf = compute_tf(term, document)
        idf = idf_dict.get(term, 0.0)
        tfidf_vector.append(tf * idf)

    return tfidf_vector
</code></pre>
<hr />
<h2>4. VectorizaciÃ³n de Documentos {#4-vectorizacion}</h2>
<h3>4.1 Clase TFIDFVectorizer</h3>
<pre><code class="language-python">import math
from collections import Counter


class TFIDFVectorizer:
    &quot;&quot;&quot;Transform documents into TF-IDF vectors.

    Similar to sklearn's TfidfVectorizer but from scratch.

    Attributes:
        vocabulary_: List of terms (ordered).
        idf_: Dictionary of IDF values.
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        &quot;&quot;&quot;Initialize empty vectorizer.&quot;&quot;&quot;
        self.vocabulary_: list[str] = []
        self.idf_: dict[str, float] = {}
        self._fitted: bool = False

    def fit(self, corpus: list[list[str]]) -&gt; &quot;TFIDFVectorizer&quot;:
        &quot;&quot;&quot;Learn vocabulary and IDF from corpus.

        Args:
            corpus: List of documents (each is list of tokens).

        Returns:
            self (for method chaining).
        &quot;&quot;&quot;
        # Build vocabulary (all unique terms)
        all_terms: set[str] = set()
        for doc in corpus:
            all_terms.update(doc)
        self.vocabulary_ = sorted(all_terms)  # Sorted for consistency

        # Compute IDF for each term
        total_docs = len(corpus)
        for term in self.vocabulary_:
            docs_with_term = sum(1 for doc in corpus if term in doc)
            if docs_with_term &gt; 0:
                self.idf_[term] = math.log(total_docs / docs_with_term)
            else:
                self.idf_[term] = 0.0

        self._fitted = True
        return self

    def transform(self, documents: list[list[str]]) -&gt; list[list[float]]:
        &quot;&quot;&quot;Transform documents to TF-IDF vectors.

        Args:
            documents: Documents to transform.

        Returns:
            List of TF-IDF vectors.

        Raises:
            RuntimeError: If vectorizer hasn't been fitted.
        &quot;&quot;&quot;
        if not self._fitted:
            raise RuntimeError(&quot;Vectorizer must be fitted before transform&quot;)

        vectors = []
        for doc in documents:
            vector = self._transform_single(doc)
            vectors.append(vector)
        return vectors

    def _transform_single(self, document: list[str]) -&gt; list[float]:
        &quot;&quot;&quot;Transform single document to TF-IDF vector.&quot;&quot;&quot;
        vector = []
        doc_length = len(document) if document else 1
        term_counts = Counter(document)

        for term in self.vocabulary_:
            tf = term_counts.get(term, 0) / doc_length
            idf = self.idf_.get(term, 0.0)
            vector.append(tf * idf)

        return vector

    def fit_transform(self, corpus: list[list[str]]) -&gt; list[list[float]]:
        &quot;&quot;&quot;Fit and transform in one step.&quot;&quot;&quot;
        self.fit(corpus)
        return self.transform(corpus)

    def transform_query(self, query_tokens: list[str]) -&gt; list[float]:
        &quot;&quot;&quot;Transform a search query to TF-IDF vector.

        Uses same vocabulary and IDF as corpus.
        &quot;&quot;&quot;
        if not self._fitted:
            raise RuntimeError(&quot;Vectorizer must be fitted first&quot;)
        return self._transform_single(query_tokens)

    def get_feature_names(self) -&gt; list[str]:
        &quot;&quot;&quot;Return vocabulary terms in order.&quot;&quot;&quot;
        return self.vocabulary_.copy()

    def __repr__(self) -&gt; str:
        status = &quot;fitted&quot; if self._fitted else &quot;not fitted&quot;
        return f&quot;TFIDFVectorizer({len(self.vocabulary_)} terms, {status})&quot;
</code></pre>
<h3>4.2 Uso del Vectorizer</h3>
<pre><code class="language-python"># Corpus de ejemplo
corpus = [
    [&quot;python&quot;, &quot;machine&quot;, &quot;learning&quot;, &quot;tutorial&quot;],
    [&quot;java&quot;, &quot;programming&quot;, &quot;tutorial&quot;],
    [&quot;python&quot;, &quot;data&quot;, &quot;science&quot;],
    [&quot;machine&quot;, &quot;learning&quot;, &quot;deep&quot;, &quot;learning&quot;],
]

# Crear y ajustar vectorizer
vectorizer = TFIDFVectorizer()
tfidf_matrix = vectorizer.fit_transform(corpus)

# Ver vocabulario
print(vectorizer.get_feature_names())
# ['data', 'deep', 'java', 'learning', 'machine', 'programming', 
#  'python', 'science', 'tutorial']

# Ver vector del primer documento
print(tfidf_matrix[0])
# [0.0, 0.0, 0.0, 0.173, 0.346, 0.0, 0.173, 0.0, 0.173]
# &quot;machine&quot; y &quot;learning&quot; tienen valores, &quot;python&quot; tambiÃ©n

# Transformar query
query = [&quot;python&quot;, &quot;learning&quot;]
query_vector = vectorizer.transform_query(query)
</code></pre>
<hr />
<h2>5. Ranking con Similitud de Coseno {#5-ranking}</h2>
<h3>5.1 FunciÃ³n de Similitud</h3>
<pre><code class="language-python">import math


def cosine_similarity(v1: list[float], v2: list[float]) -&gt; float:
    &quot;&quot;&quot;Compute cosine similarity between two vectors.

    Returns value between 0 and 1 for TF-IDF vectors.
    Higher = more similar.
    &quot;&quot;&quot;
    if len(v1) != len(v2):
        raise ValueError(&quot;Vectors must have same dimension&quot;)

    dot_product = sum(a * b for a, b in zip(v1, v2))
    magnitude1 = math.sqrt(sum(a ** 2 for a in v1))
    magnitude2 = math.sqrt(sum(b ** 2 for b in v2))

    if magnitude1 == 0 or magnitude2 == 0:
        return 0.0

    return dot_product / (magnitude1 * magnitude2)
</code></pre>
<h3>5.2 Ranking de Documentos</h3>
<pre><code class="language-python">from typing import NamedTuple


class SearchResult(NamedTuple):
    &quot;&quot;&quot;A search result with document ID and relevance score.&quot;&quot;&quot;
    doc_id: int
    score: float


def rank_documents(
    query_vector: list[float],
    document_vectors: list[list[float]],
    top_k: int = 10
) -&gt; list[SearchResult]:
    &quot;&quot;&quot;Rank documents by similarity to query.

    Args:
        query_vector: TF-IDF vector of search query.
        document_vectors: TF-IDF vectors of all documents.
        top_k: Number of top results to return.

    Returns:
        List of SearchResult sorted by score (descending).
    &quot;&quot;&quot;
    results = []

    for doc_id, doc_vector in enumerate(document_vectors):
        score = cosine_similarity(query_vector, doc_vector)
        if score &gt; 0:  # Only include non-zero matches
            results.append(SearchResult(doc_id=doc_id, score=score))

    # Sort by score descending
    results.sort(key=lambda r: r.score, reverse=True)

    return results[:top_k]
</code></pre>
<h3>5.3 IntegraciÃ³n: BÃºsqueda Completa</h3>
<pre><code class="language-python">class TFIDFSearchEngine:
    &quot;&quot;&quot;Simple search engine using TF-IDF and cosine similarity.

    Example:
        &gt;&gt;&gt; engine = TFIDFSearchEngine()
        &gt;&gt;&gt; engine.index([
        ...     (0, [&quot;python&quot;, &quot;tutorial&quot;]),
        ...     (1, [&quot;java&quot;, &quot;tutorial&quot;]),
        ...     (2, [&quot;python&quot;, &quot;machine&quot;, &quot;learning&quot;]),
        ... ])
        &gt;&gt;&gt; engine.search(&quot;python learning&quot;)
        [SearchResult(doc_id=2, score=0.8), SearchResult(doc_id=0, score=0.3)]
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self.vectorizer = TFIDFVectorizer()
        self.document_vectors: list[list[float]] = []
        self.doc_ids: list[int] = []

    def index(self, documents: list[tuple[int, list[str]]]) -&gt; None:
        &quot;&quot;&quot;Index documents for searching.

        Args:
            documents: List of (doc_id, tokens) tuples.
        &quot;&quot;&quot;
        self.doc_ids = [doc_id for doc_id, _ in documents]
        corpus = [tokens for _, tokens in documents]
        self.document_vectors = self.vectorizer.fit_transform(corpus)

    def search(self, query: str, top_k: int = 10) -&gt; list[SearchResult]:
        &quot;&quot;&quot;Search for documents matching query.

        Args:
            query: Search query string.
            top_k: Number of results to return.

        Returns:
            List of SearchResult with doc_id and score.
        &quot;&quot;&quot;
        # Tokenize query (simple split for now)
        query_tokens = query.lower().split()

        # Transform to TF-IDF vector
        query_vector = self.vectorizer.transform_query(query_tokens)

        # Rank documents
        results = []
        for i, doc_vector in enumerate(self.document_vectors):
            score = cosine_similarity(query_vector, doc_vector)
            if score &gt; 0:
                results.append(SearchResult(
                    doc_id=self.doc_ids[i],
                    score=score
                ))

        # Sort and return top k
        results.sort(key=lambda r: r.score, reverse=True)
        return results[:top_k]
</code></pre>
<hr />
<h2>6. IntegraciÃ³n en Archimedes {#6-integracion}</h2>
<h3>6.1 MÃ³dulo Completo</h3>
<pre><code class="language-python"># src/vectorizer.py

import math
from collections import Counter
from typing import NamedTuple


class TFIDFVectorizer:
    &quot;&quot;&quot;TF-IDF Vectorizer for Archimedes Indexer.&quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self.vocabulary_: list[str] = []
        self.idf_: dict[str, float] = {}
        self._fitted: bool = False

    def fit(self, corpus: list[list[str]]) -&gt; &quot;TFIDFVectorizer&quot;:
        all_terms: set[str] = set()
        for doc in corpus:
            all_terms.update(doc)
        self.vocabulary_ = sorted(all_terms)

        total_docs = len(corpus)
        for term in self.vocabulary_:
            docs_with_term = sum(1 for doc in corpus if term in doc)
            self.idf_[term] = math.log(total_docs / docs_with_term) if docs_with_term else 0

        self._fitted = True
        return self

    def transform(self, documents: list[list[str]]) -&gt; list[list[float]]:
        if not self._fitted:
            raise RuntimeError(&quot;Must fit before transform&quot;)
        return [self._transform_single(doc) for doc in documents]

    def _transform_single(self, document: list[str]) -&gt; list[float]:
        doc_len = len(document) if document else 1
        counts = Counter(document)
        return [
            (counts.get(term, 0) / doc_len) * self.idf_.get(term, 0)
            for term in self.vocabulary_
        ]

    def fit_transform(self, corpus: list[list[str]]) -&gt; list[list[float]]:
        return self.fit(corpus).transform(corpus)


# src/similarity.py

def cosine_similarity(v1: list[float], v2: list[float]) -&gt; float:
    &quot;&quot;&quot;Compute cosine similarity between two TF-IDF vectors.&quot;&quot;&quot;
    dot = sum(a * b for a, b in zip(v1, v2))
    mag1 = math.sqrt(sum(a ** 2 for a in v1))
    mag2 = math.sqrt(sum(b ** 2 for b in v2))

    if mag1 == 0 or mag2 == 0:
        return 0.0
    return dot / (mag1 * mag2)


class ScoredResult(NamedTuple):
    doc_id: int
    score: float


def rank_by_similarity(
    query_vector: list[float],
    doc_vectors: list[list[float]],
    doc_ids: list[int],
    top_k: int = 10
) -&gt; list[ScoredResult]:
    &quot;&quot;&quot;Rank documents by cosine similarity to query.&quot;&quot;&quot;
    results = [
        ScoredResult(doc_id, cosine_similarity(query_vector, doc_vec))
        for doc_id, doc_vec in zip(doc_ids, doc_vectors)
    ]
    # Filter zero scores and sort
    results = [r for r in results if r.score &gt; 0]
    results.sort(key=lambda x: x.score, reverse=True)
    return results[:top_k]
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes</h2>
<h3>Error 1: No normalizar por longitud de documento</h3>
<pre><code class="language-python"># âŒ Documentos largos siempre ganan
def bad_tf(term, doc):
    return doc.count(term)  # Raw count

# âœ… Normalizar
def good_tf(term, doc):
    return doc.count(term) / len(doc)
</code></pre>
<h3>Error 2: Log de cero en IDF</h3>
<pre><code class="language-python"># âŒ Error si tÃ©rmino no estÃ¡ en ningÃºn documento
def bad_idf(term, corpus):
    df = sum(1 for d in corpus if term in d)
    return math.log(len(corpus) / df)  # ZeroDivisionError!

# âœ… Manejar caso especial
def good_idf(term, corpus):
    df = sum(1 for d in corpus if term in d)
    if df == 0:
        return 0.0
    return math.log(len(corpus) / df)
</code></pre>
<h3>Error 3: Vocabulario inconsistente</h3>
<pre><code class="language-python"># âŒ Query tiene tÃ©rminos no vistos
query_terms = [&quot;quantum&quot;, &quot;computing&quot;]  # No estaban en corpus
# Vector query tendrÃ¡ dimension incorrecta

# âœ… Usar solo tÃ©rminos del vocabulario
def transform_query(self, query_tokens):
    # Solo considera tÃ©rminos en self.vocabulary_
    ...
</code></pre>
<hr />
<h2>ğŸ”§ Ejercicios PrÃ¡cticos</h2>
<h3>Ejercicio 11.1: Implementar TF</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 11.2: Implementar IDF</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<h3>Ejercicio 11.3: Sistema de Ranking</h3>
<p>Ver <a href="#mod_EJERCICIOS">EJERCICIOS.md</a></p>
<hr />
<h2>ğŸ“š Recursos Externos</h2>
<table>
<thead>
<tr>
<th>Recurso</th>
<th>Tipo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf">TF-IDF Wikipedia</a></td>
<td>Lectura</td>
<td>ğŸ”´ Obligatorio</td>
</tr>
<tr>
<td><a href="https://nlp.stanford.edu/IR-book/html/htmledition/scoring-term-weighting-and-the-vector-space-model-1.html">Stanford IR Book Ch.6</a></td>
<td>Libro</td>
<td>ğŸŸ¡ Recomendado</td>
</tr>
<tr>
<td><a href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html">Sklearn TfidfVectorizer</a></td>
<td>Docs</td>
<td>ğŸŸ¢ Complementario (para comparar)</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ”— Referencias del Glosario</h2>
<ul>
<li><a href="#mod_GLOSARIO">TF-IDF</a></li>
<li><a href="#mod_GLOSARIO">Term Frequency</a></li>
<li><a href="#mod_GLOSARIO">Inverse Document Frequency</a></li>
<li><a href="#mod_GLOSARIO">Similitud de Coseno</a></li>
<li><a href="#mod_GLOSARIO">VectorizaciÃ³n</a></li>
</ul>
<hr />
<h2>ğŸ§­ NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
<th>Siguiente â†’</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_10_ALGEBRA_LINEAL">10_ALGEBRA_LINEAL</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
<td><a href="#mod_12_PROYECTO_INTEGRADOR">12_PROYECTO_INTEGRADOR</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_12_PROYECTO_INTEGRADOR" class="cover-page">
            <a name="mod_12_PROYECTO_INTEGRADOR"></a>
            <div class="cover-title">12 - Proyecto Integrador</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>12 - Proyecto Integrador: Archimedes Indexer</h1>
<blockquote>
<p><strong>ğŸ¯ Objetivo:</strong> Ensamblar todos los componentes en un motor de bÃºsqueda funcional con anÃ¡lisis Big O.</p>
</blockquote>
<hr />
<h2>ğŸ§  MetodologÃ­a Feynman: Â¿QuÃ© Estamos Construyendo?</h2>
<h3>ExplicaciÃ³n para un NiÃ±o de 10 AÃ±os</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   IMAGINA UNA BIBLIOTECA MÃGICA                                             â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                             â”‚
â”‚                                                                             â”‚
â”‚   Tienes 1000 libros y quieres encontrar todos los que hablan de &quot;dragones&quot; â”‚ 
â”‚                                                                             â”‚
â”‚   SIN MAGIA (bÃºsqueda lineal):                                              â”‚
â”‚   ğŸ“š Abrir libro 1, leer todo, Â¿tiene &quot;dragones&quot;? No.                       â”‚
â”‚   ğŸ“š Abrir libro 2, leer todo, Â¿tiene &quot;dragones&quot;? No.                       â”‚
â”‚   ğŸ“š ... repetir 1000 veces ... Â¡MUY LENTO!                                 â”‚
â”‚                                                                             â”‚
â”‚   CON MAGIA (Ã­ndice invertido):                                             â”‚
â”‚   ğŸ“‹ El bibliotecario tiene una lista secreta:                              â”‚
â”‚      &quot;dragones&quot; â†’ libros 23, 156, 789                                       â”‚
â”‚   ğŸ“š Â¡Vas directo a esos 3 libros! Â¡INSTANTÃNEO!                            â”‚
â”‚                                                                             â”‚
â”‚   ESO ES ARCHIMEDES INDEXER:                                                â”‚
â”‚   Un bibliotecario mÃ¡gico para documentos de texto.                         â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3>ExplicaciÃ³n TÃ©cnica Progresiva</h3>
<p><strong>Nivel 1 - Concepto:</strong><br />
Un motor de bÃºsqueda que encuentra documentos relevantes para una consulta.</p>
<p><strong>Nivel 2 - Componentes:</strong><br />
- <strong>Tokenizer:</strong> Divide texto en palabras<br />
- <strong>Ãndice Invertido:</strong> Mapea palabra â†’ documentos<br />
- <strong>TF-IDF:</strong> Calcula importancia de palabras<br />
- <strong>Cosine Similarity:</strong> Mide quÃ© tan similar es query a cada documento</p>
<p><strong>Nivel 3 - Flujo Completo:</strong></p>
<pre><code>INDEXACIÃ“N (una vez):
documento â†’ tokenizar â†’ actualizar Ã­ndice â†’ calcular TF-IDF

BÃšSQUEDA (cada query):
query â†’ tokenizar â†’ buscar en Ã­ndice â†’ calcular similitud â†’ ordenar â†’ resultados
</code></pre>
<p><strong>Nivel 4 - Complejidad:</strong><br />
- IndexaciÃ³n: O(N Ã— T) donde N=docs, T=tokens promedio<br />
- BÃºsqueda: O(V + R Ã— V) donde V=vocabulario, R=resultados</p>
<hr />
<h2>ğŸ—ï¸ Arquitectura Detallada</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           ARCHIMEDES INDEXER                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                           â”‚
â”‚  â”‚   ENTRADA    â”‚                                                           â”‚
â”‚  â”‚  Documentos  â”‚                                                           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                                           â”‚
â”‚         â”‚                                                                   â”‚
â”‚         â–¼                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚  Tokenizer   â”‚â”€â”€â”€â”€â”€â–¶â”‚   Corpus     â”‚â”€â”€â”€â”€â”€â–¶â”‚  Inverted    â”‚              â”‚
â”‚  â”‚              â”‚       â”‚  (Document)  â”‚      â”‚   Index      â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                      â”‚                      â”‚
â”‚                                                      â–¼                      â”‚
â”‚                                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚                                               â”‚    TF-IDF    â”‚              â”‚
â”‚                                               â”‚  Vectorizer  â”‚              â”‚
â”‚                                               â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                      â”‚                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚                     â”‚
â”‚  â”‚    Query     â”‚â”€â”€â”€â”€â”€â–¶â”‚  Similarity  â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚  â”‚              â”‚       â”‚   (Cosine)   â”‚                                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                    â”‚
â”‚                               â”‚                                             â”‚
â”‚                               â–¼                                             â”‚
â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚                        â”‚   QuickSort  â”‚â”€â”€â”€â”€â”€â–¶â”‚  Resultados  â”‚              â”‚
â”‚                        â”‚   (ranking)  â”‚       â”‚   Ordenados  â”‚              â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<hr />
<h2>ğŸ“ Estructura de Archivos del Proyecto</h2>
<pre><code>archimedes-indexer/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py              # Package marker
â”‚   â”œâ”€â”€ document.py              # MÃ³dulos 01-02: Document, Corpus
â”‚   â”œâ”€â”€ tokenizer.py             # MÃ³dulos 03-04: Tokenizer
â”‚   â”œâ”€â”€ inverted_index.py        # MÃ³dulos 05-06: InvertedIndex
â”‚   â”œâ”€â”€ sorting.py               # MÃ³dulos 07-08: quicksort, mergesort
â”‚   â”œâ”€â”€ searching.py             # MÃ³dulo 09: binary_search
â”‚   â”œâ”€â”€ linear_algebra.py        # MÃ³dulo 10: Vector operations
â”‚   â”œâ”€â”€ vectorizer.py            # MÃ³dulo 11: TFIDFVectorizer
â”‚   â”œâ”€â”€ similarity.py            # MÃ³dulo 11: cosine_similarity
â”‚   â””â”€â”€ search_engine.py         # MÃ³dulo 12: SearchEngine (integraciÃ³n)
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_document.py
â”‚   â”œâ”€â”€ test_tokenizer.py
â”‚   â”œâ”€â”€ test_inverted_index.py
â”‚   â”œâ”€â”€ test_sorting.py
â”‚   â”œâ”€â”€ test_searching.py
â”‚   â”œâ”€â”€ test_linear_algebra.py
â”‚   â”œâ”€â”€ test_vectorizer.py
â”‚   â”œâ”€â”€ test_similarity.py
â”‚   â””â”€â”€ test_search_engine.py    # Tests de integraciÃ³n
â”œâ”€â”€ data/
â”‚   â””â”€â”€ sample_corpus/
â”‚       â”œâ”€â”€ doc_001.txt
â”‚       â”œâ”€â”€ doc_002.txt
â”‚       â””â”€â”€ ...
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ COMPLEXITY_ANALYSIS.md   # AnÃ¡lisis Big O de todo el sistema
â”‚   â””â”€â”€ API_REFERENCE.md         # DocumentaciÃ³n de la API
â”œâ”€â”€ README.md                    # DocumentaciÃ³n principal (inglÃ©s)
â”œâ”€â”€ pyproject.toml               # ConfiguraciÃ³n del proyecto
â””â”€â”€ requirements-dev.txt         # pytest, mypy, ruff
</code></pre>
<hr />
<h2>ğŸ’» ImplementaciÃ³n Guiada: SearchEngine</h2>
<h3>Paso 1: La Clase Principal</h3>
<pre><code class="language-python"># src/search_engine.py
&quot;&quot;&quot;Main search engine orchestrating all components.&quot;&quot;&quot;

from typing import NamedTuple
from .document import Document, Corpus
from .tokenizer import Tokenizer
from .inverted_index import InvertedIndex
from .vectorizer import TFIDFVectorizer
from .similarity import cosine_similarity
from .sorting import quicksort


class SearchResult(NamedTuple):
    &quot;&quot;&quot;A search result with document info and relevance score.

    Attributes:
        doc_id: Unique document identifier.
        title: Document title.
        score: Relevance score (0.0 to 1.0).
        snippet: Preview of document content.
    &quot;&quot;&quot;
    doc_id: int
    title: str
    score: float
    snippet: str


class SearchEngine:
    &quot;&quot;&quot;Full-text search engine using TF-IDF and cosine similarity.

    This class integrates all components:
    - Tokenizer for text processing
    - InvertedIndex for fast term lookup
    - TFIDFVectorizer for document representation
    - Cosine similarity for ranking

    Example:
        &gt;&gt;&gt; engine = SearchEngine()
        &gt;&gt;&gt; engine.add_document(1, &quot;Python Guide&quot;, &quot;Learn Python programming...&quot;)
        &gt;&gt;&gt; engine.add_document(2, &quot;Java Tutorial&quot;, &quot;Java programming basics...&quot;)
        &gt;&gt;&gt; engine.build_index()
        &gt;&gt;&gt; results = engine.search(&quot;python programming&quot;)
        &gt;&gt;&gt; for r in results:
        ...     print(f&quot;{r.title}: {r.score:.3f}&quot;)
        Python Guide: 0.847
        Java Tutorial: 0.213

    Complexity:
        - add_document: O(1)
        - build_index: O(N Ã— T) where N=docs, T=avg tokens
        - search: O(V + R Ã— V + R log R) where V=vocab, R=results
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        &quot;&quot;&quot;Initialize search engine with empty corpus.&quot;&quot;&quot;
        self.corpus = Corpus()
        self.tokenizer = Tokenizer()
        self.index = InvertedIndex()
        self.vectorizer = TFIDFVectorizer()

        self._document_vectors: list[list[float]] = []
        self._indexed: bool = False

    def add_document(self, doc_id: int, title: str, content: str) -&gt; None:
        &quot;&quot;&quot;Add a document to the corpus.

        Args:
            doc_id: Unique identifier for the document.
            title: Document title for display.
            content: Full text content to index.

        Raises:
            ValueError: If doc_id already exists.

        Note:
            Documents are not searchable until build_index() is called.
        &quot;&quot;&quot;
        if self.corpus.contains(doc_id):
            raise ValueError(f&quot;Document {doc_id} already exists&quot;)

        doc = Document(doc_id=doc_id, title=title, content=content)
        self.corpus.add(doc)
        self._indexed = False  # Mark index as stale

    def build_index(self) -&gt; None:
        &quot;&quot;&quot;Build inverted index and TF-IDF vectors.

        Must be called after adding documents and before searching.
        Can be called again to rebuild after adding more documents.

        Complexity: O(N Ã— T) where N=documents, T=avg tokens per doc
        &quot;&quot;&quot;
        # Reset index
        self.index = InvertedIndex()
        tokenized_docs: list[list[str]] = []

        # Process each document
        for doc in self.corpus:
            tokens = self.tokenizer.tokenize(doc.content)
            doc.tokens = tokens
            tokenized_docs.append(tokens)
            self.index.add_document(doc.doc_id, tokens)

        # Build TF-IDF vectors
        self._document_vectors = self.vectorizer.fit_transform(tokenized_docs)
        self._indexed = True

    def search(self, query: str, top_k: int = 10) -&gt; list[SearchResult]:
        &quot;&quot;&quot;Search for documents matching the query.

        Args:
            query: Search query string.
            top_k: Maximum number of results to return.

        Returns:
            List of SearchResult sorted by relevance (descending).

        Raises:
            RuntimeError: If build_index() hasn't been called.

        Complexity: O(V + R Ã— V + R log R)
            - O(V): Transform query to vector
            - O(R Ã— V): Calculate similarity for R candidate docs
            - O(R log R): Sort results
        &quot;&quot;&quot;
        if not self._indexed:
            raise RuntimeError(&quot;Must call build_index() before searching&quot;)

        # Tokenize query
        query_tokens = self.tokenizer.tokenize(query)
        if not query_tokens:
            return []

        # Get candidate documents (those containing at least one query term)
        candidates = self.index.search_or(query_tokens)
        if not candidates:
            return []

        # Transform query to TF-IDF vector
        query_vector = self.vectorizer.transform_query(query_tokens)

        # Calculate similarity for each candidate
        results: list[tuple[int, float]] = []
        for doc_idx, doc in enumerate(self.corpus):
            if doc.doc_id in candidates:
                score = cosine_similarity(query_vector, self._document_vectors[doc_idx])
                if score &gt; 0:
                    results.append((doc_idx, score))

        # Sort by score (descending) using our quicksort
        results = quicksort(results, key=lambda x: -x[1])

        # Convert to SearchResult objects
        search_results: list[SearchResult] = []
        for doc_idx, score in results[:top_k]:
            doc = self.corpus.get_by_index(doc_idx)
            snippet = doc.content[:200] + &quot;...&quot; if len(doc.content) &gt; 200 else doc.content
            search_results.append(SearchResult(
                doc_id=doc.doc_id,
                title=doc.title,
                score=round(score, 4),
                snippet=snippet
            ))

        return search_results

    def get_stats(self) -&gt; dict:
        &quot;&quot;&quot;Get statistics about the search engine.

        Returns:
            Dictionary with corpus and index statistics.
        &quot;&quot;&quot;
        return {
            &quot;documents&quot;: len(self.corpus),
            &quot;vocabulary_size&quot;: self.vectorizer.vocabulary_size if self._indexed else 0,
            &quot;indexed&quot;: self._indexed,
        }
</code></pre>
<h3>Paso 2: Clases de Soporte</h3>
<pre><code class="language-python"># src/document.py
&quot;&quot;&quot;Document and Corpus classes.&quot;&quot;&quot;

from dataclasses import dataclass, field
from typing import Iterator


@dataclass
class Document:
    &quot;&quot;&quot;A searchable document.

    Attributes:
        doc_id: Unique identifier.
        title: Document title.
        content: Full text content.
        tokens: Tokenized content (populated by SearchEngine).
    &quot;&quot;&quot;
    doc_id: int
    title: str
    content: str
    tokens: list[str] = field(default_factory=list)

    def __post_init__(self) -&gt; None:
        if self.doc_id &lt; 0:
            raise ValueError(&quot;doc_id must be non-negative&quot;)
        if not self.content.strip():
            raise ValueError(&quot;content cannot be empty&quot;)


class Corpus:
    &quot;&quot;&quot;Collection of documents.&quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self._documents: list[Document] = []
        self._id_to_index: dict[int, int] = {}

    def add(self, doc: Document) -&gt; None:
        &quot;&quot;&quot;Add document to corpus.&quot;&quot;&quot;
        if doc.doc_id in self._id_to_index:
            raise ValueError(f&quot;Document {doc.doc_id} already exists&quot;)
        self._id_to_index[doc.doc_id] = len(self._documents)
        self._documents.append(doc)

    def get(self, doc_id: int) -&gt; Document:
        &quot;&quot;&quot;Get document by ID.&quot;&quot;&quot;
        idx = self._id_to_index.get(doc_id)
        if idx is None:
            raise KeyError(f&quot;Document {doc_id} not found&quot;)
        return self._documents[idx]

    def get_by_index(self, index: int) -&gt; Document:
        &quot;&quot;&quot;Get document by internal index.&quot;&quot;&quot;
        return self._documents[index]

    def contains(self, doc_id: int) -&gt; bool:
        &quot;&quot;&quot;Check if document exists.&quot;&quot;&quot;
        return doc_id in self._id_to_index

    def __len__(self) -&gt; int:
        return len(self._documents)

    def __iter__(self) -&gt; Iterator[Document]:
        return iter(self._documents)
</code></pre>
<hr />
<h2>ğŸ“Š AnÃ¡lisis de Complejidad Completo</h2>
<h3>Template COMPLEXITY_ANALYSIS.md</h3>
<pre><code class="language-markdown"># Complexity Analysis - Archimedes Indexer

## Overview

This document analyzes the time and space complexity of all operations
in the Archimedes Indexer search engine.

## Notation

- N = number of documents
- T = average tokens per document
- V = vocabulary size (unique terms)
- Q = query length (tokens)
- R = number of results

## Component Analysis

### 1. Tokenizer.tokenize(text)

**Time:** O(T)
- Split text: O(T)
- Lowercase: O(T)
- Filter stop words: O(T) with set lookup

**Space:** O(T) for output list

### 2. InvertedIndex.add_document(doc_id, tokens)

**Time:** O(T)
- For each token: O(1) dict access + O(1) set add
- Total: O(T)

**Space:** O(V) for index + O(N) doc_ids per term

### 3. InvertedIndex.search_or(terms)

**Time:** O(Q Ã— avg_docs_per_term)
- For each query term: O(1) lookup
- Union of sets: O(total matching docs)

### 4. TFIDFVectorizer.fit_transform(corpus)

**Time:** O(N Ã— T + V)
- Build vocabulary: O(N Ã— T)
- Compute IDF: O(V)
- Transform each doc: O(N Ã— V)

**Space:** O(N Ã— V) for document vectors

### 5. cosine_similarity(v1, v2)

**Time:** O(V)
- Dot product: O(V)
- Magnitudes: O(V) each
- Division: O(1)

### 6. quicksort(results)

**Time:** O(R log R) average, O(RÂ²) worst case
**Space:** O(log R) for recursion stack

### 7. SearchEngine.build_index()

**Time:** O(N Ã— T + N Ã— V)
- Tokenize all docs: O(N Ã— T)
- Build inverted index: O(N Ã— T)
- Build TF-IDF vectors: O(N Ã— T + N Ã— V)

**Space:** O(V + N Ã— V)
- Inverted index: O(V)
- Document vectors: O(N Ã— V)

### 8. SearchEngine.search(query)

**Time:** O(Q + R Ã— V + R log R)
- Tokenize query: O(Q)
- Find candidates: O(Q)
- Transform query: O(V)
- Calculate similarities: O(R Ã— V)
- Sort results: O(R log R)

**Space:** O(V + R)
- Query vector: O(V)
- Results list: O(R)

## Summary Table

| Operation | Time | Space |
|-----------|------|-------|
| add_document | O(1) | O(T) |
| build_index | O(NÃ—T + NÃ—V) | O(V + NÃ—V) |
| search | O(Q + RÃ—V + R log R) | O(V + R) |

## Bottlenecks and Optimizations

1. **TF-IDF vectors are dense** â†’ Could use sparse representation
2. **Similarity calculated for all candidates** â†’ Could use inverted index scores
3. **QuickSort worst case** â†’ Using random pivot mitigates this
</code></pre>
<hr />
<h2>âš ï¸ Errores Comunes y Soluciones</h2>
<h3>Error 1: Olvidar llamar build_index()</h3>
<pre><code class="language-python"># âŒ Error: RuntimeError
engine = SearchEngine()
engine.add_document(1, &quot;Title&quot;, &quot;Content&quot;)
results = engine.search(&quot;query&quot;)  # Â¡No se indexÃ³!

# âœ… Correcto
engine = SearchEngine()
engine.add_document(1, &quot;Title&quot;, &quot;Content&quot;)
engine.build_index()  # Â¡Importante!
results = engine.search(&quot;query&quot;)
</code></pre>
<h3>Error 2: No manejar queries vacÃ­as</h3>
<pre><code class="language-python"># âŒ Puede causar errores
def search(self, query):
    tokens = self.tokenizer.tokenize(query)
    # Si query=&quot;&quot;, tokens=[] y query_vector tiene problemas

# âœ… Manejar caso vacÃ­o
def search(self, query):
    tokens = self.tokenizer.tokenize(query)
    if not tokens:
        return []  # Retornar lista vacÃ­a
</code></pre>
<h3>Error 3: Modificar documento despuÃ©s de indexar</h3>
<pre><code class="language-python"># âŒ El Ã­ndice queda desactualizado
engine.add_document(1, &quot;Title&quot;, &quot;Python tutorial&quot;)
engine.build_index()
engine.corpus.get(1).content = &quot;Java tutorial&quot;  # Â¡Ãndice no actualizado!

# âœ… Reconstruir Ã­ndice despuÃ©s de modificaciones
engine.add_document(2, &quot;Title2&quot;, &quot;New content&quot;)
engine.build_index()  # Reconstruir
</code></pre>
<h3>Error 4: No normalizar texto consistentemente</h3>
<pre><code class="language-python"># âŒ &quot;Python&quot; vs &quot;python&quot; son diferentes
index.search(&quot;Python&quot;)  # Encuentra
index.search(&quot;python&quot;)  # No encuentra

# âœ… Normalizar siempre en tokenizer
def tokenize(self, text):
    return text.lower().split()  # Siempre minÃºsculas
</code></pre>
<hr />
<h2>ğŸ’¡ Recomendaciones Profesionales</h2>
<h3>1. Testing</h3>
<pre><code class="language-python"># MÃ­nimo: tests unitarios para cada componente
pytest tests/ -v --cov=src --cov-report=term-missing
# Objetivo: &gt;80% coverage
</code></pre>
<h3>2. Type Hints</h3>
<pre><code class="language-python"># Todas las funciones deben tener type hints
def search(self, query: str, top_k: int = 10) -&gt; list[SearchResult]:
</code></pre>
<h3>3. Docstrings</h3>
<pre><code class="language-python"># Google style docstrings para todas las funciones pÃºblicas
def function(param: Type) -&gt; ReturnType:
    &quot;&quot;&quot;One-line description.

    Longer description if needed.

    Args:
        param: Description of parameter.

    Returns:
        Description of return value.

    Raises:
        ErrorType: When this error occurs.

    Example:
        &gt;&gt;&gt; function(value)
        expected_result
    &quot;&quot;&quot;
</code></pre>
<h3>4. ConfiguraciÃ³n de Herramientas</h3>
<pre><code class="language-toml"># pyproject.toml
[tool.mypy]
strict = true
python_version = &quot;3.11&quot;

[tool.ruff]
line-length = 88
select = [&quot;E&quot;, &quot;F&quot;, &quot;W&quot;, &quot;I&quot;, &quot;N&quot;, &quot;UP&quot;, &quot;B&quot;]

[tool.pytest.ini_options]
testpaths = [&quot;tests&quot;]
addopts = &quot;-v --cov=src&quot;
</code></pre>
<hr />
<h2>ğŸ“‹ Checklist de Entrega (100 puntos)</h2>
<h3>Estructura y CÃ³digo (40 pts)</h3>
<ul>
<li>[ ] Clase <code>Document</code> y <code>Corpus</code> (5 pts)</li>
<li>[ ] <code>Tokenizer</code> con stop words (5 pts)</li>
<li>[ ] <code>InvertedIndex</code> con AND/OR (10 pts)</li>
<li>[ ] <code>quicksort()</code> implementado (5 pts)</li>
<li>[ ] <code>binary_search()</code> implementado (5 pts)</li>
<li>[ ] <code>TFIDFVectorizer</code> desde cero (5 pts)</li>
<li>[ ] <code>cosine_similarity()</code> implementado (5 pts)</li>
</ul>
<h3>Testing (20 pts)</h3>
<ul>
<li>[ ] Tests unitarios para cada mÃ³dulo (10 pts)</li>
<li>[ ] Tests de integraciÃ³n (5 pts)</li>
<li>[ ] Coverage &gt; 80% (5 pts)</li>
</ul>
<h3>DocumentaciÃ³n (20 pts)</h3>
<ul>
<li>[ ] README.md profesional en inglÃ©s (10 pts)</li>
<li>[ ] <code>COMPLEXITY_ANALYSIS.md</code> con Big O (10 pts)</li>
</ul>
<h3>Funcionalidad (20 pts)</h3>
<ul>
<li>[ ] Motor busca y retorna resultados (10 pts)</li>
<li>[ ] Resultados ordenados por relevancia (5 pts)</li>
<li>[ ] Demo funcional (5 pts)</li>
</ul>
<hr />
<h2>ğŸ—ï¸ Arquitectura</h2>
<pre><code>SearchEngine
    â”œâ”€â”€ Corpus (Document collection)
    â”œâ”€â”€ Tokenizer (text â†’ tokens)
    â”œâ”€â”€ InvertedIndex (term â†’ doc_ids)
    â”œâ”€â”€ TFIDFVectorizer (docs â†’ vectors)
    â””â”€â”€ Ranker (cosine similarity + quicksort)
</code></pre>
<hr />
<h2>ğŸ“Š AnÃ¡lisis de Complejidad Requerido</h2>
<p>Documenta en <code>COMPLEXITY_ANALYSIS.md</code>:</p>
<table>
<thead>
<tr>
<th>OperaciÃ³n</th>
<th>Tu AnÃ¡lisis</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add_document()</code></td>
<td>O(?)</td>
</tr>
<tr>
<td><code>build_index()</code></td>
<td>O(?)</td>
</tr>
<tr>
<td><code>search(query)</code></td>
<td>O(?)</td>
</tr>
<tr>
<td><code>quicksort()</code></td>
<td>O(?) promedio, O(?) peor</td>
</tr>
<tr>
<td><code>cosine_similarity()</code></td>
<td>O(?)</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ“ Template README.md</h2>
<pre><code class="language-markdown"># Archimedes Indexer

A search engine built from scratch in pure Python.

## Features
- Inverted index for fast term lookup
- TF-IDF vectorization
- Cosine similarity ranking
- No external dependencies (no numpy, pandas, sklearn)

## Installation
\`\`\`bash
git clone &lt;repo&gt;
cd archimedes-indexer
python -m venv venv
source venv/bin/activate
\`\`\`

## Usage
\`\`\`python
from src.search_engine import SearchEngine

engine = SearchEngine()
engine.add_document(1, &quot;Python Tutorial&quot;, &quot;Learn Python...&quot;)
engine.build_index()
results = engine.search(&quot;python programming&quot;)
\`\`\`

## Complexity Analysis
See [COMPLEXITY_ANALYSIS.md](#mod_COMPLEXITY_ANALYSIS)

## Testing
\`\`\`bash
python -m pytest tests/ -v --cov=src
\`\`\`
</code></pre>
<hr />
<h2>âœ… Criterios de AprobaciÃ³n</h2>
<table>
<thead>
<tr>
<th>PuntuaciÃ³n</th>
<th>Nivel</th>
</tr>
</thead>
<tbody>
<tr>
<td>90-100</td>
<td>Listo para Pathway</td>
</tr>
<tr>
<td>75-89</td>
<td>Reforzar Ã¡reas dÃ©biles</td>
</tr>
<tr>
<td>60-74</td>
<td>MÃ¡s prÃ¡ctica necesaria</td>
</tr>
<tr>
<td>&lt;60</td>
<td>Revisar mÃ³dulos</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ”— NavegaciÃ³n</h2>
<table>
<thead>
<tr>
<th>â† Anterior</th>
<th>Ãndice</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_11_TFIDF_COSENO">11_TFIDF_COSENO</a></td>
<td><a href="#mod_00_INDICE">00_INDICE</a></td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_EJERCICIOS" class="cover-page">
            <a name="mod_EJERCICIOS"></a>
            <div class="cover-title">Ejercicios</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>ğŸ“ Ejercicios PrÃ¡cticos</h1>
<blockquote>
<p>Ejercicios organizados por mÃ³dulo con dificultad progresiva.</p>
</blockquote>
<hr />
<h2>Ãndice de Ejercicios</h2>
<table>
<thead>
<tr>
<th>MÃ³dulo</th>
<th>Tema</th>
<th>Dificultad</th>
<th># Ejercicios</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>Python Profesional</td>
<td>ğŸŸ¢ BÃ¡sico</td>
<td>4</td>
</tr>
<tr>
<td>02</td>
<td>OOP</td>
<td>ğŸŸ¢ BÃ¡sico</td>
<td>5</td>
</tr>
<tr>
<td>03</td>
<td>LÃ³gica y Big O</td>
<td>ğŸŸ¡ Intermedio</td>
<td>3</td>
</tr>
<tr>
<td>04</td>
<td>Arrays y Strings</td>
<td>ğŸŸ¢ BÃ¡sico</td>
<td>3</td>
</tr>
<tr>
<td>05</td>
<td>Hash Maps</td>
<td>ğŸŸ¡ Intermedio</td>
<td>3</td>
</tr>
<tr>
<td>06</td>
<td>Ãndice Invertido</td>
<td>ğŸŸ¡ Intermedio</td>
<td>3</td>
</tr>
<tr>
<td>07</td>
<td>RecursiÃ³n</td>
<td>ğŸŸ¡ Intermedio</td>
<td>3</td>
</tr>
<tr>
<td>08</td>
<td>Sorting</td>
<td>ğŸ”´ Avanzado</td>
<td>3</td>
</tr>
<tr>
<td>09</td>
<td>Binary Search</td>
<td>ğŸŸ¡ Intermedio</td>
<td>3</td>
</tr>
<tr>
<td>10</td>
<td>Ãlgebra Lineal</td>
<td>ğŸŸ¡ Intermedio</td>
<td>3</td>
</tr>
<tr>
<td>11</td>
<td>TF-IDF</td>
<td>ğŸ”´ Avanzado</td>
<td>3</td>
</tr>
<tr>
<td>13</td>
<td>Linked Lists, Stacks, Queues</td>
<td>ğŸŸ¡ Intermedio</td>
<td>4</td>
</tr>
<tr>
<td>14</td>
<td>Trees y BST</td>
<td>ğŸ”´ Avanzado</td>
<td>5</td>
</tr>
<tr>
<td>15</td>
<td>Graphs, BFS, DFS</td>
<td>ğŸ”´ Avanzado</td>
<td>5</td>
</tr>
<tr>
<td>16</td>
<td>Dynamic Programming</td>
<td>ğŸ”´ Avanzado</td>
<td>5</td>
</tr>
<tr>
<td>17</td>
<td>Greedy Algorithms</td>
<td>ğŸŸ¡ Intermedio</td>
<td>4</td>
</tr>
<tr>
<td>18</td>
<td>Heaps</td>
<td>ğŸ”´ Avanzado</td>
<td>4</td>
</tr>
</tbody>
</table>
<hr />
<h2>MÃ³dulo 01: Python Profesional</h2>
<h3>Ejercicio 1.1: Type Hints BÃ¡sicos</h3>
<p><strong>Objetivo:</strong> Agregar type hints a funciones existentes.</p>
<pre><code class="language-python"># Agregar type hints a estas funciones:

def clean_text(text):
    return text.lower().strip()

def count_words(text):
    return len(text.split())

def get_unique_words(words):
    return list(set(words))
</code></pre>
<h3>Ejercicio 1.2: FunciÃ³n Pura</h3>
<p><strong>Objetivo:</strong> Convertir funciÃ³n impura a pura.</p>
<pre><code class="language-python"># Convertir a funciÃ³n pura (sin modificar estado externo):
results = []

def add_to_results(item):
    results.append(item)
    return len(results)
</code></pre>
<h3>Ejercicio 1.3: Docstrings</h3>
<p><strong>Objetivo:</strong> Escribir docstrings estilo Google.</p>
<pre><code class="language-python"># Agregar docstring completo con Args, Returns, Example:
def tokenize(text, min_length=2):
    words = text.lower().split()
    return [w for w in words if len(w) &gt;= min_length]
</code></pre>
<h3>Ejercicio 1.4: Configurar Linters</h3>
<p><strong>Objetivo:</strong> Crear <code>pyproject.toml</code> con mypy y ruff configurados.</p>
<hr />
<h2>MÃ³dulo 02: OOP</h2>
<h3>Ejercicio 2.1: Clase Document BÃ¡sica</h3>
<p><strong>Objetivo:</strong> Crear clase Document con <code>__init__</code>, atributos tipados.</p>
<pre><code class="language-python"># Crear clase Document con:
# - doc_id: int
# - content: str
# - tokens: list[str] (vacÃ­a inicialmente)
# - MÃ©todo tokenize() que llena tokens
</code></pre>
<h3>Ejercicio 2.2: MÃ©todos MÃ¡gicos</h3>
<p><strong>Objetivo:</strong> Implementar <code>__repr__</code>, <code>__str__</code>, <code>__eq__</code>, <code>__len__</code>.</p>
<h3>Ejercicio 2.3: Properties</h3>
<p><strong>Objetivo:</strong> Agregar validaciÃ³n con properties para <code>doc_id</code> (&gt;= 0) y <code>content</code> (no vacÃ­o).</p>
<h3>Ejercicio 2.4: Clase Corpus</h3>
<p><strong>Objetivo:</strong> Crear Corpus que contenga Documents con mÃ©todos add, get, remove.</p>
<h3>Ejercicio 2.5: SOLID</h3>
<p><strong>Objetivo:</strong> Refactorizar una clase "Dios" que hace todo en clases separadas.</p>
<hr />
<h2>MÃ³dulo 03: LÃ³gica y Big O</h2>
<h3>Ejercicio 3.1: Stop Words como Set</h3>
<p><strong>Objetivo:</strong> Implementar filtrado de stop words usando set para O(1) lookup.</p>
<pre><code class="language-python"># Dado:
stop_words_list = [&quot;the&quot;, &quot;a&quot;, &quot;an&quot;, &quot;is&quot;, &quot;are&quot;]
tokens = [&quot;the&quot;, &quot;quick&quot;, &quot;brown&quot;, &quot;fox&quot;, &quot;is&quot;, &quot;fast&quot;]

# Implementar filter_stopwords() que sea O(n) no O(nÃ—m)
</code></pre>
<h3>Ejercicio 3.2: Operaciones de Conjuntos</h3>
<p><strong>Objetivo:</strong> Implementar bÃºsqueda AND y OR usando set operations.</p>
<h3>Ejercicio 3.3: Analizar Complejidad</h3>
<p><strong>Objetivo:</strong> Determinar Big O de 5 fragmentos de cÃ³digo dados.</p>
<pre><code class="language-python"># Â¿CuÃ¡l es la complejidad de cada uno?

# A
for i in range(n):
    print(i)

# B
for i in range(n):
    for j in range(n):
        print(i, j)

# C
for i in range(n):
    for j in range(i):
        print(i, j)

# D
i = n
while i &gt; 0:
    print(i)
    i = i // 2

# E
def recursive(n):
    if n &lt;= 1:
        return
    recursive(n - 1)
    recursive(n - 1)
</code></pre>
<hr />
<h2>MÃ³dulo 04: Arrays y Strings</h2>
<h3>Ejercicio 4.1: ManipulaciÃ³n de Listas</h3>
<p><strong>Objetivo:</strong> Implementar rotate_left(list, k) sin usar slicing.</p>
<h3>Ejercicio 4.2: Tokenizador</h3>
<p><strong>Objetivo:</strong> Implementar tokenizador completo con:<br />
- Eliminar puntuaciÃ³n<br />
- Convertir a minÃºsculas<br />
- Filtrar por longitud mÃ­nima</p>
<h3>Ejercicio 4.3: AnÃ¡lisis de Complejidad</h3>
<p><strong>Objetivo:</strong> Comparar dos implementaciones de reverse y explicar cuÃ¡l es mejor.</p>
<hr />
<h2>MÃ³dulo 05: Hash Maps</h2>
<h3>Ejercicio 5.1: Contador de Frecuencias</h3>
<p><strong>Objetivo:</strong> Implementar word_frequencies(tokens) â†’ dict[str, int].</p>
<h3>Ejercicio 5.2: Benchmark List vs Set</h3>
<p><strong>Objetivo:</strong> Escribir script que mide tiempo de bÃºsqueda en list vs set.</p>
<h3>Ejercicio 5.3: Term-Document Map</h3>
<p><strong>Objetivo:</strong> Construir diccionario term â†’ set[doc_id].</p>
<hr />
<h2>MÃ³dulo 06: Ãndice Invertido</h2>
<h3>Ejercicio 6.1: Ãndice BÃ¡sico</h3>
<p><strong>Objetivo:</strong> Implementar InvertedIndex con add_document() y search().</p>
<h3>Ejercicio 6.2: BÃºsqueda AND/OR</h3>
<p><strong>Objetivo:</strong> Agregar search_and() y search_or() al Ã­ndice.</p>
<h3>Ejercicio 6.3: Ãndice con Frecuencias</h3>
<p><strong>Objetivo:</strong> Modificar Ã­ndice para guardar frecuencia de cada tÃ©rmino por documento.</p>
<hr />
<h2>MÃ³dulo 07: RecursiÃ³n</h2>
<h3>Ejercicio 7.1: Factorial y Fibonacci</h3>
<p><strong>Objetivo:</strong> Implementar ambos recursivamente con casos base correctos.</p>
<h3>Ejercicio 7.2: Suma y MÃ¡ximo</h3>
<p><strong>Objetivo:</strong> Implementar sum_list() y find_max() recursivamente.</p>
<h3>Ejercicio 7.3: Merge de Listas</h3>
<p><strong>Objetivo:</strong> Implementar merge(list1, list2) que fusiona dos listas ordenadas.</p>
<hr />
<h2>MÃ³dulo 08: Sorting</h2>
<h3>Ejercicio 8.1: QuickSort</h3>
<p><strong>Objetivo:</strong> Implementar quicksort() con particiÃ³n Lomuto.</p>
<h3>Ejercicio 8.2: MergeSort</h3>
<p><strong>Objetivo:</strong> Implementar mergesort() con funciÃ³n merge() auxiliar.</p>
<h3>Ejercicio 8.3: Ordenar por Score</h3>
<p><strong>Objetivo:</strong> Ordenar lista de (doc_id, score) por score descendente usando tu quicksort.</p>
<hr />
<h2>MÃ³dulo 09: Binary Search</h2>
<h3>Ejercicio 9.1: Binary Search BÃ¡sica</h3>
<p><strong>Objetivo:</strong> Implementar binary_search() iterativo sin errores off-by-one.</p>
<h3>Ejercicio 9.2: Primera y Ãšltima Ocurrencia</h3>
<p><strong>Objetivo:</strong> Implementar find_first() y find_last() para elementos repetidos.</p>
<h3>Ejercicio 9.3: BÃºsqueda de Umbral</h3>
<p><strong>Objetivo:</strong> Encontrar todos los documentos con score &gt;= threshold en lista ordenada.</p>
<hr />
<h2>MÃ³dulo 10: Ãlgebra Lineal</h2>
<h3>Ejercicio 10.1: Operaciones Vectoriales</h3>
<p><strong>Objetivo:</strong> Implementar add_vectors(), subtract_vectors(), scalar_multiply().</p>
<h3>Ejercicio 10.2: Producto Punto y Norma</h3>
<p><strong>Objetivo:</strong> Implementar dot_product() y magnitude().</p>
<h3>Ejercicio 10.3: Similitud de Coseno</h3>
<p><strong>Objetivo:</strong> Implementar cosine_similarity() usando las funciones anteriores.</p>
<hr />
<h2>MÃ³dulo 11: TF-IDF</h2>
<h3>Ejercicio 11.1: Term Frequency</h3>
<p><strong>Objetivo:</strong> Implementar compute_tf(term, document).</p>
<h3>Ejercicio 11.2: Inverse Document Frequency</h3>
<p><strong>Objetivo:</strong> Implementar compute_idf(term, corpus).</p>
<h3>Ejercicio 11.3: Sistema de Ranking</h3>
<p><strong>Objetivo:</strong> Implementar rank_documents() que ordena por similitud de coseno.</p>
<hr />
<h2>MÃ³dulo 13: Linked Lists, Stacks, Queues</h2>
<h3>Ejercicio 13.1: Implementar Stack</h3>
<p><strong>Objetivo:</strong> Crear clase Stack con push, pop, peek, is_empty.</p>
<h3>Ejercicio 13.2: ParÃ©ntesis Balanceados</h3>
<p><strong>Objetivo:</strong> Verificar si string tiene parÃ©ntesis <code>()[]{}</code> balanceados usando Stack.</p>
<h3>Ejercicio 13.3: Implementar Queue</h3>
<p><strong>Objetivo:</strong> Crear clase Queue con enqueue, dequeue usando deque.</p>
<h3>Ejercicio 13.4: Reverse Linked List</h3>
<p><strong>Objetivo:</strong> Invertir una linked list iterativamente.</p>
<hr />
<h2>MÃ³dulo 14: Trees y BST</h2>
<h3>Ejercicio 14.1: Implementar BST</h3>
<p><strong>Objetivo:</strong> Crear clase BST con insert y search.</p>
<h3>Ejercicio 14.2: Tree Traversals</h3>
<p><strong>Objetivo:</strong> Implementar inorder, preorder, postorder (recursivo e iterativo).</p>
<h3>Ejercicio 14.3: Validar BST</h3>
<p><strong>Objetivo:</strong> Verificar si un Ã¡rbol cumple la propiedad BST.</p>
<h3>Ejercicio 14.4: Altura del Ãrbol</h3>
<p><strong>Objetivo:</strong> Calcular altura de un Ã¡rbol binario.</p>
<h3>Ejercicio 14.5: Level Order Traversal</h3>
<p><strong>Objetivo:</strong> Recorrer Ã¡rbol por niveles usando Queue.</p>
<hr />
<h2>MÃ³dulo 15: Graphs, BFS, DFS</h2>
<h3>Ejercicio 15.1: Implementar Graph</h3>
<p><strong>Objetivo:</strong> Crear clase Graph con adjacency list.</p>
<h3>Ejercicio 15.2: BFS</h3>
<p><strong>Objetivo:</strong> Implementar Breadth-First Search.</p>
<h3>Ejercicio 15.3: DFS</h3>
<p><strong>Objetivo:</strong> Implementar Depth-First Search (recursivo e iterativo).</p>
<h3>Ejercicio 15.4: Shortest Path (Unweighted)</h3>
<p><strong>Objetivo:</strong> Encontrar camino mÃ¡s corto usando BFS.</p>
<h3>Ejercicio 15.5: Detectar Ciclo</h3>
<p><strong>Objetivo:</strong> Detectar si un grafo tiene ciclo usando DFS.</p>
<hr />
<h2>MÃ³dulo 16: Dynamic Programming</h2>
<h3>Ejercicio 16.1: Fibonacci con DP</h3>
<p><strong>Objetivo:</strong> Implementar con memoization y tabulation.</p>
<h3>Ejercicio 16.2: Climbing Stairs</h3>
<p><strong>Objetivo:</strong> Contar formas de subir n escaleras (1 o 2 pasos).</p>
<h3>Ejercicio 16.3: Coin Change</h3>
<p><strong>Objetivo:</strong> MÃ­nimas monedas para un amount.</p>
<h3>Ejercicio 16.4: Longest Common Subsequence</h3>
<p><strong>Objetivo:</strong> Encontrar LCS de dos strings.</p>
<h3>Ejercicio 16.5: 0/1 Knapsack</h3>
<p><strong>Objetivo:</strong> Maximizar valor con capacidad limitada.</p>
<hr />
<h2>MÃ³dulo 17: Greedy Algorithms</h2>
<h3>Ejercicio 17.1: Activity Selection</h3>
<p><strong>Objetivo:</strong> Seleccionar mÃ¡ximas actividades no superpuestas.</p>
<h3>Ejercicio 17.2: Fractional Knapsack</h3>
<p><strong>Objetivo:</strong> Maximizar valor tomando fracciones de items.</p>
<h3>Ejercicio 17.3: Jump Game</h3>
<p><strong>Objetivo:</strong> Determinar si puedes llegar al final del array.</p>
<h3>Ejercicio 17.4: Minimum Meeting Rooms</h3>
<p><strong>Objetivo:</strong> MÃ­nimas salas para todas las reuniones.</p>
<hr />
<h2>MÃ³dulo 18: Heaps</h2>
<h3>Ejercicio 18.1: Implementar MinHeap</h3>
<p><strong>Objetivo:</strong> Crear clase MinHeap con push, pop, peek.</p>
<h3>Ejercicio 18.2: K Largest Elements</h3>
<p><strong>Objetivo:</strong> Encontrar los k elementos mÃ¡s grandes.</p>
<h3>Ejercicio 18.3: Top K Frequent</h3>
<p><strong>Objetivo:</strong> Encontrar los k elementos mÃ¡s frecuentes.</p>
<h3>Ejercicio 18.4: Merge K Sorted Lists</h3>
<p><strong>Objetivo:</strong> Fusionar k listas ordenadas.</p>
<hr />
<h2>ğŸ“š Soluciones</h2>
<p>Ver <a href="#mod_EJERCICIOS_SOLUCIONES">EJERCICIOS_SOLUCIONES.md</a> para soluciones detalladas.</p>
<hr />
<h2>ğŸ’¡ Consejos</h2>
<ol>
<li><strong>Intenta primero:</strong> No mires las soluciones hasta intentar al menos 30 minutos.</li>
<li><strong>Escribe tests:</strong> Antes de implementar, escribe casos de prueba.</li>
<li><strong>Analiza complejidad:</strong> Para cada soluciÃ³n, determina su Big O.</li>
<li><strong>Compara:</strong> DespuÃ©s de resolver, compara con la soluciÃ³n oficial.</li>
</ol>
        </section>
        
        <div id="mod_EJERCICIOS_SOLUCIONES" class="cover-page">
            <a name="mod_EJERCICIOS_SOLUCIONES"></a>
            <div class="cover-title">Soluciones de Ejercicios</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>âœ… Soluciones de Ejercicios</h1>
<blockquote>
<p>Soluciones detalladas con explicaciones.</p>
</blockquote>
<hr />
<h2>MÃ³dulo 01: Python Profesional</h2>
<h3>SoluciÃ³n 1.1: Type Hints</h3>
<pre><code class="language-python">def clean_text(text: str) -&gt; str:
    return text.lower().strip()

def count_words(text: str) -&gt; int:
    return len(text.split())

def get_unique_words(words: list[str]) -&gt; list[str]:
    return list(set(words))
</code></pre>
<h3>SoluciÃ³n 1.2: FunciÃ³n Pura</h3>
<pre><code class="language-python"># âŒ Impura (modifica estado externo)
results = []
def add_to_results_impure(item):
    results.append(item)
    return len(results)

# âœ… Pura (no modifica estado externo)
def add_to_results_pure(results: list, item) -&gt; tuple[list, int]:
    new_results = results + [item]
    return new_results, len(new_results)

# Uso:
my_results = []
my_results, count = add_to_results_pure(my_results, &quot;item1&quot;)
</code></pre>
<h3>SoluciÃ³n 1.3: Docstrings</h3>
<pre><code class="language-python">def tokenize(text: str, min_length: int = 2) -&gt; list[str]:
    &quot;&quot;&quot;Tokenize text into words above minimum length.

    Args:
        text: Input text to tokenize.
        min_length: Minimum word length to include.

    Returns:
        List of lowercase tokens meeting length requirement.

    Example:
        &gt;&gt;&gt; tokenize(&quot;Hello World&quot;, min_length=4)
        ['hello', 'world']
    &quot;&quot;&quot;
    words = text.lower().split()
    return [w for w in words if len(w) &gt;= min_length]
</code></pre>
<hr />
<h2>MÃ³dulo 02: OOP</h2>
<h3>SoluciÃ³n 2.1: Clase Document</h3>
<pre><code class="language-python">class Document:
    def __init__(self, doc_id: int, content: str) -&gt; None:
        self.doc_id: int = doc_id
        self.content: str = content
        self.tokens: list[str] = []

    def tokenize(self) -&gt; list[str]:
        self.tokens = self.content.lower().split()
        return self.tokens
</code></pre>
<h3>SoluciÃ³n 2.2: MÃ©todos MÃ¡gicos</h3>
<pre><code class="language-python">class Document:
    def __init__(self, doc_id: int, content: str) -&gt; None:
        self.doc_id = doc_id
        self.content = content
        self.tokens: list[str] = []

    def __repr__(self) -&gt; str:
        return f&quot;Document(doc_id={self.doc_id})&quot;

    def __str__(self) -&gt; str:
        return f&quot;Doc #{self.doc_id}: {self.content[:30]}...&quot;

    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, Document):
            return NotImplemented
        return self.doc_id == other.doc_id

    def __len__(self) -&gt; int:
        return len(self.tokens)
</code></pre>
<hr />
<h2>MÃ³dulo 03: LÃ³gica y Big O</h2>
<h3>SoluciÃ³n 3.1: Stop Words con Set</h3>
<pre><code class="language-python">def filter_stopwords(tokens: list[str], stop_words: list[str]) -&gt; list[str]:
    # Convertir a set para O(1) lookup
    stop_set = set(stop_words)  # O(m)
    # Filtrar en O(n) total
    return [t for t in tokens if t not in stop_set]

# Complejidad: O(n + m) en lugar de O(n Ã— m)
</code></pre>
<h3>SoluciÃ³n 3.3: Analizar Complejidad</h3>
<pre><code class="language-python"># A: O(n) - un loop simple
# B: O(nÂ²) - dos loops anidados, ambos van hasta n
# C: O(nÂ²) - suma de 0+1+2+...+(n-1) = n(n-1)/2 = O(nÂ²)
# D: O(log n) - divide por 2 cada iteraciÃ³n
# E: O(2^n) - Ã¡rbol de llamadas crece exponencialmente
</code></pre>
<hr />
<h2>MÃ³dulo 05: Hash Maps</h2>
<h3>SoluciÃ³n 5.1: Contador de Frecuencias</h3>
<pre><code class="language-python">def word_frequencies(tokens: list[str]) -&gt; dict[str, int]:
    &quot;&quot;&quot;Count word frequencies. O(n) time.&quot;&quot;&quot;
    frequencies: dict[str, int] = {}
    for token in tokens:
        frequencies[token] = frequencies.get(token, 0) + 1
    return frequencies

# Alternativa con Counter:
from collections import Counter
def word_frequencies_v2(tokens: list[str]) -&gt; dict[str, int]:
    return dict(Counter(tokens))
</code></pre>
<hr />
<h2>MÃ³dulo 06: Ãndice Invertido</h2>
<h3>SoluciÃ³n 6.1: Ãndice BÃ¡sico</h3>
<pre><code class="language-python">from collections import defaultdict

class InvertedIndex:
    def __init__(self) -&gt; None:
        self._index: defaultdict[str, set[int]] = defaultdict(set)

    def add_document(self, doc_id: int, tokens: list[str]) -&gt; None:
        for token in tokens:
            self._index[token].add(doc_id)

    def search(self, term: str) -&gt; set[int]:
        return self._index.get(term, set()).copy()
</code></pre>
<hr />
<h2>MÃ³dulo 07: RecursiÃ³n</h2>
<h3>SoluciÃ³n 7.1: Factorial y Fibonacci</h3>
<pre><code class="language-python">def factorial(n: int) -&gt; int:
    if n &lt;= 1:
        return 1
    return n * factorial(n - 1)

def fibonacci(n: int) -&gt; int:
    if n &lt;= 0:
        return 0
    if n == 1:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)
</code></pre>
<h3>SoluciÃ³n 7.3: Merge</h3>
<pre><code class="language-python">def merge(left: list[int], right: list[int]) -&gt; list[int]:
    result = []
    i = j = 0
    while i &lt; len(left) and j &lt; len(right):
        if left[i] &lt;= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
</code></pre>
<hr />
<h2>MÃ³dulo 08: Sorting</h2>
<h3>SoluciÃ³n 8.1: QuickSort</h3>
<pre><code class="language-python">def quicksort(items: list[int]) -&gt; list[int]:
    if len(items) &lt;= 1:
        return items

    pivot = items[-1]
    less = [x for x in items[:-1] if x &lt; pivot]
    equal = [x for x in items if x == pivot]
    greater = [x for x in items[:-1] if x &gt; pivot]

    return quicksort(less) + equal + quicksort(greater)
</code></pre>
<h3>SoluciÃ³n 8.2: MergeSort</h3>
<pre><code class="language-python">def mergesort(items: list[int]) -&gt; list[int]:
    if len(items) &lt;= 1:
        return items.copy()

    mid = len(items) // 2
    left = mergesort(items[:mid])
    right = mergesort(items[mid:])

    return merge(left, right)
</code></pre>
<hr />
<h2>MÃ³dulo 09: Binary Search</h2>
<h3>SoluciÃ³n 9.1: Binary Search</h3>
<pre><code class="language-python">def binary_search(items: list[int], target: int) -&gt; int:
    left, right = 0, len(items) - 1

    while left &lt;= right:
        mid = left + (right - left) // 2
        if items[mid] == target:
            return mid
        elif items[mid] &lt; target:
            left = mid + 1
        else:
            right = mid - 1

    return -1
</code></pre>
<hr />
<h2>MÃ³dulo 10: Ãlgebra Lineal</h2>
<h3>SoluciÃ³n 10.3: Similitud de Coseno</h3>
<pre><code class="language-python">import math

def dot_product(v1: list[float], v2: list[float]) -&gt; float:
    return sum(a * b for a, b in zip(v1, v2))

def magnitude(v: list[float]) -&gt; float:
    return math.sqrt(sum(x ** 2 for x in v))

def cosine_similarity(v1: list[float], v2: list[float]) -&gt; float:
    dot = dot_product(v1, v2)
    mag1, mag2 = magnitude(v1), magnitude(v2)
    if mag1 == 0 or mag2 == 0:
        return 0.0
    return dot / (mag1 * mag2)
</code></pre>
<hr />
<h2>MÃ³dulo 11: TF-IDF</h2>
<h3>SoluciÃ³n 11.1-11.2: TF e IDF</h3>
<pre><code class="language-python">import math

def compute_tf(term: str, document: list[str]) -&gt; float:
    if not document:
        return 0.0
    return document.count(term) / len(document)

def compute_idf(term: str, corpus: list[list[str]]) -&gt; float:
    if not corpus:
        return 0.0
    docs_with_term = sum(1 for doc in corpus if term in doc)
    if docs_with_term == 0:
        return 0.0
    return math.log(len(corpus) / docs_with_term)
</code></pre>
<hr />
<h2>MÃ³dulo 13: Linked Lists, Stacks, Queues</h2>
<h3>SoluciÃ³n 13.1: Implementar Stack</h3>
<pre><code class="language-python">from typing import Generic, TypeVar

T = TypeVar('T')

class Stack(Generic[T]):
    &quot;&quot;&quot;Stack LIFO implementation. All operations O(1).&quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self._items: list[T] = []

    def push(self, item: T) -&gt; None:
        self._items.append(item)

    def pop(self) -&gt; T:
        if self.is_empty():
            raise IndexError(&quot;Pop from empty stack&quot;)
        return self._items.pop()

    def peek(self) -&gt; T:
        if self.is_empty():
            raise IndexError(&quot;Peek at empty stack&quot;)
        return self._items[-1]

    def is_empty(self) -&gt; bool:
        return len(self._items) == 0

    def __len__(self) -&gt; int:
        return len(self._items)
</code></pre>
<h3>SoluciÃ³n 13.2: ParÃ©ntesis Balanceados</h3>
<pre><code class="language-python">def is_balanced(expression: str) -&gt; bool:
    &quot;&quot;&quot;Check if parentheses are balanced. O(n)&quot;&quot;&quot;
    stack: list[str] = []
    matching = {')': '(', ']': '[', '}': '{'}

    for char in expression:
        if char in '([{':
            stack.append(char)
        elif char in ')]}':
            if not stack or stack.pop() != matching[char]:
                return False

    return len(stack) == 0

# Tests
assert is_balanced(&quot;()[]{}&quot;) == True
assert is_balanced(&quot;([{}])&quot;) == True
assert is_balanced(&quot;([)]&quot;) == False
assert is_balanced(&quot;((&quot;) == False
</code></pre>
<h3>SoluciÃ³n 13.4: Reverse Linked List</h3>
<pre><code class="language-python">class ListNode:
    def __init__(self, val: int = 0):
        self.val = val
        self.next: ListNode | None = None

def reverse_list(head: ListNode | None) -&gt; ListNode | None:
    &quot;&quot;&quot;Reverse linked list iteratively. O(n) time, O(1) space.&quot;&quot;&quot;
    prev = None
    current = head

    while current:
        next_node = current.next  # Save next
        current.next = prev       # Reverse pointer
        prev = current            # Move prev forward
        current = next_node       # Move current forward

    return prev
</code></pre>
<hr />
<h2>MÃ³dulo 14: Trees y BST</h2>
<h3>SoluciÃ³n 14.1: BST con insert y search</h3>
<pre><code class="language-python">class TreeNode:
    def __init__(self, val: int):
        self.val = val
        self.left: TreeNode | None = None
        self.right: TreeNode | None = None

class BST:
    def __init__(self) -&gt; None:
        self.root: TreeNode | None = None

    def insert(self, val: int) -&gt; None:
        &quot;&quot;&quot;Insert value. O(log n) average, O(n) worst.&quot;&quot;&quot;
        if not self.root:
            self.root = TreeNode(val)
            return

        current = self.root
        while True:
            if val &lt; current.val:
                if current.left is None:
                    current.left = TreeNode(val)
                    return
                current = current.left
            else:
                if current.right is None:
                    current.right = TreeNode(val)
                    return
                current = current.right

    def search(self, val: int) -&gt; bool:
        &quot;&quot;&quot;Search for value. O(log n) average.&quot;&quot;&quot;
        current = self.root
        while current:
            if val == current.val:
                return True
            elif val &lt; current.val:
                current = current.left
            else:
                current = current.right
        return False
</code></pre>
<h3>SoluciÃ³n 14.2: Tree Traversals</h3>
<pre><code class="language-python">def inorder(root: TreeNode | None) -&gt; list[int]:
    &quot;&quot;&quot;Left, Root, Right. Returns sorted for BST.&quot;&quot;&quot;
    if not root:
        return []
    return inorder(root.left) + [root.val] + inorder(root.right)

def preorder(root: TreeNode | None) -&gt; list[int]:
    &quot;&quot;&quot;Root, Left, Right.&quot;&quot;&quot;
    if not root:
        return []
    return [root.val] + preorder(root.left) + preorder(root.right)

def postorder(root: TreeNode | None) -&gt; list[int]:
    &quot;&quot;&quot;Left, Right, Root.&quot;&quot;&quot;
    if not root:
        return []
    return postorder(root.left) + postorder(root.right) + [root.val]
</code></pre>
<h3>SoluciÃ³n 14.4: Altura del Ãrbol</h3>
<pre><code class="language-python">def tree_height(root: TreeNode | None) -&gt; int:
    &quot;&quot;&quot;Calculate tree height. O(n)&quot;&quot;&quot;
    if not root:
        return -1  # Empty tree has height -1
    return 1 + max(tree_height(root.left), tree_height(root.right))
</code></pre>
<hr />
<h2>MÃ³dulo 15: Graphs</h2>
<h3>SoluciÃ³n 15.2: BFS</h3>
<pre><code class="language-python">from collections import deque

def bfs(graph: dict[str, list[str]], start: str) -&gt; list[str]:
    &quot;&quot;&quot;BFS traversal. O(V + E)&quot;&quot;&quot;
    visited = set()
    result = []
    queue = deque([start])
    visited.add(start)

    while queue:
        vertex = queue.popleft()
        result.append(vertex)

        for neighbor in graph.get(vertex, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    return result
</code></pre>
<h3>SoluciÃ³n 15.3: DFS</h3>
<pre><code class="language-python">def dfs_recursive(graph: dict[str, list[str]], start: str) -&gt; list[str]:
    &quot;&quot;&quot;DFS recursive. O(V + E)&quot;&quot;&quot;
    visited = set()
    result = []

    def dfs(vertex: str) -&gt; None:
        visited.add(vertex)
        result.append(vertex)
        for neighbor in graph.get(vertex, []):
            if neighbor not in visited:
                dfs(neighbor)

    dfs(start)
    return result

def dfs_iterative(graph: dict[str, list[str]], start: str) -&gt; list[str]:
    &quot;&quot;&quot;DFS iterative with stack. O(V + E)&quot;&quot;&quot;
    visited = set()
    result = []
    stack = [start]

    while stack:
        vertex = stack.pop()
        if vertex not in visited:
            visited.add(vertex)
            result.append(vertex)
            for neighbor in reversed(graph.get(vertex, [])):
                if neighbor not in visited:
                    stack.append(neighbor)

    return result
</code></pre>
<h3>SoluciÃ³n 15.4: Shortest Path BFS</h3>
<pre><code class="language-python">def shortest_path(graph: dict[str, list[str]], start: str, end: str) -&gt; list[str] | None:
    &quot;&quot;&quot;Find shortest path in unweighted graph. O(V + E)&quot;&quot;&quot;
    if start == end:
        return [start]

    visited = {start}
    queue = deque([(start, [start])])

    while queue:
        vertex, path = queue.popleft()

        for neighbor in graph.get(vertex, []):
            if neighbor == end:
                return path + [neighbor]
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))

    return None
</code></pre>
<hr />
<h2>MÃ³dulo 16: Dynamic Programming</h2>
<h3>SoluciÃ³n 16.2: Climbing Stairs</h3>
<pre><code class="language-python">def climb_stairs(n: int) -&gt; int:
    &quot;&quot;&quot;Count ways to climb n stairs (1 or 2 steps). O(n) time, O(1) space.&quot;&quot;&quot;
    if n &lt;= 2:
        return n

    prev2, prev1 = 1, 2
    for _ in range(3, n + 1):
        current = prev1 + prev2
        prev2, prev1 = prev1, current

    return prev1
</code></pre>
<h3>SoluciÃ³n 16.3: Coin Change</h3>
<pre><code class="language-python">def coin_change(coins: list[int], amount: int) -&gt; int:
    &quot;&quot;&quot;Minimum coins for amount. O(amount * len(coins))&quot;&quot;&quot;
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for a in range(1, amount + 1):
        for coin in coins:
            if coin &lt;= a and dp[a - coin] != float('inf'):
                dp[a] = min(dp[a], dp[a - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1
</code></pre>
<h3>SoluciÃ³n 16.4: Longest Common Subsequence</h3>
<pre><code class="language-python">def lcs(text1: str, text2: str) -&gt; int:
    &quot;&quot;&quot;Find LCS length. O(m * n)&quot;&quot;&quot;
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]
</code></pre>
<hr />
<h2>MÃ³dulo 17: Greedy</h2>
<h3>SoluciÃ³n 17.1: Activity Selection</h3>
<pre><code class="language-python">def activity_selection(start: list[int], end: list[int]) -&gt; list[int]:
    &quot;&quot;&quot;Select max non-overlapping activities. O(n log n)&quot;&quot;&quot;
    activities = sorted(zip(start, end, range(len(start))), key=lambda x: x[1])

    selected = [activities[0][2]]
    last_end = activities[0][1]

    for s, e, idx in activities[1:]:
        if s &gt;= last_end:
            selected.append(idx)
            last_end = e

    return selected
</code></pre>
<h3>SoluciÃ³n 17.3: Jump Game</h3>
<pre><code class="language-python">def can_jump(nums: list[int]) -&gt; bool:
    &quot;&quot;&quot;Can reach last index? O(n)&quot;&quot;&quot;
    farthest = 0
    for i, jump in enumerate(nums):
        if i &gt; farthest:
            return False
        farthest = max(farthest, i + jump)
        if farthest &gt;= len(nums) - 1:
            return True
    return True
</code></pre>
<hr />
<h2>MÃ³dulo 18: Heaps</h2>
<h3>SoluciÃ³n 18.2: K Largest Elements</h3>
<pre><code class="language-python">import heapq

def k_largest(nums: list[int], k: int) -&gt; list[int]:
    &quot;&quot;&quot;Find k largest elements. O(n log k)&quot;&quot;&quot;
    heap: list[int] = []

    for num in nums:
        if len(heap) &lt; k:
            heapq.heappush(heap, num)
        elif num &gt; heap[0]:
            heapq.heapreplace(heap, num)

    return sorted(heap, reverse=True)
</code></pre>
<h3>SoluciÃ³n 18.3: Top K Frequent</h3>
<pre><code class="language-python">import heapq
from collections import Counter

def top_k_frequent(nums: list[int], k: int) -&gt; list[int]:
    &quot;&quot;&quot;Find k most frequent elements. O(n log k)&quot;&quot;&quot;
    count = Counter(nums)
    heap: list[tuple[int, int]] = []

    for num, freq in count.items():
        if len(heap) &lt; k:
            heapq.heappush(heap, (freq, num))
        elif freq &gt; heap[0][0]:
            heapq.heapreplace(heap, (freq, num))

    return [num for freq, num in heap]
</code></pre>
<hr />
<h2>ğŸ’¡ Notas</h2>
<ul>
<li>Cada soluciÃ³n incluye la complejidad Ã³ptima</li>
<li>Verifica tus soluciones comparando con estas</li>
<li>Si tu soluciÃ³n es diferente pero correcta, Â¡estÃ¡ bien!</li>
</ul>
        </section>
        
        <div id="mod_GLOSARIO" class="cover-page">
            <a name="mod_GLOSARIO"></a>
            <div class="cover-title">Glosario</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>ğŸ“– Glosario TÃ©cnico</h1>
<blockquote>
<p>Definiciones A-Z de tÃ©rminos usados en la guÃ­a.</p>
</blockquote>
<hr />
<h2>A</h2>
<h3>Adjacency List</h3>
<p><strong>DefiniciÃ³n:</strong> RepresentaciÃ³n de grafo donde cada vÃ©rtice tiene lista de vecinos.<br />
<strong>Espacio:</strong> O(V + E)<br />
<strong>Uso:</strong> Grafos sparse (pocos edges).</p>
<h3>Adjacency Matrix</h3>
<p><strong>DefiniciÃ³n:</strong> Matriz donde M[i][j] = 1 si hay edge de i a j.<br />
<strong>Espacio:</strong> O(VÂ²)<br />
<strong>Uso:</strong> Grafos dense, verificar edge en O(1).</p>
<h3>Algoritmo</h3>
<p><strong>DefiniciÃ³n:</strong> Secuencia finita de pasos para resolver un problema.<br />
<strong>AnalogÃ­a:</strong> Una receta de cocina: ingredientes (input) â†’ pasos â†’ plato (output).</p>
<h3>Amortizado</h3>
<p><strong>DefiniciÃ³n:</strong> Complejidad promedio sobre muchas operaciones.<br />
<strong>Ejemplo:</strong> <code>list.append()</code> es O(1) amortizado aunque ocasionalmente sea O(n).</p>
<h3>Array</h3>
<p><strong>DefiniciÃ³n:</strong> Estructura de datos con elementos en posiciones contiguas de memoria.<br />
<strong>En Python:</strong> Las <code>list</code> son arrays dinÃ¡micos.</p>
<hr />
<h2>B</h2>
<h3>Big O Notation</h3>
<p><strong>DefiniciÃ³n:</strong> NotaciÃ³n para describir el crecimiento del tiempo/espacio con el tamaÃ±o de entrada.<br />
<strong>ComÃºn:</strong> O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(nÂ²) &lt; O(2^n)</p>
<h3>BFS (Breadth-First Search)</h3>
<p><strong>DefiniciÃ³n:</strong> Algoritmo de recorrido de grafos que explora por niveles.<br />
<strong>Estructura:</strong> Usa Queue (FIFO).<br />
<strong>Uso:</strong> Shortest path en grafos no ponderados.<br />
<strong>Complejidad:</strong> O(V + E)</p>
<h3>Binary Search</h3>
<p><strong>DefiniciÃ³n:</strong> Algoritmo que encuentra un elemento en lista ordenada dividiendo el espacio a la mitad.<br />
<strong>Complejidad:</strong> O(log n)<br />
<strong>Requisito:</strong> Lista debe estar ordenada.</p>
<h3>Binary Search Tree (BST)</h3>
<p><strong>DefiniciÃ³n:</strong> Ãrbol binario donde left &lt; root &lt; right para cada nodo.<br />
<strong>Operaciones:</strong> O(log n) promedio, O(n) peor caso.<br />
<strong>Uso:</strong> BÃºsqueda, inserciÃ³n y eliminaciÃ³n eficientes.</p>
<h3>Bottom-Up (DP)</h3>
<p><strong>DefiniciÃ³n:</strong> Enfoque de DP que resuelve subproblemas desde los mÃ¡s pequeÃ±os.<br />
<strong>SinÃ³nimo:</strong> Tabulation.<br />
<strong>Ventaja:</strong> No usa call stack, mÃ¡s eficiente en memoria.</p>
<hr />
<h2>C</h2>
<h3>Caso Base</h3>
<p><strong>DefiniciÃ³n:</strong> CondiciÃ³n que termina la recursiÃ³n sin mÃ¡s llamadas recursivas.<br />
<strong>Ejemplo:</strong> En factorial, <code>if n &lt;= 1: return 1</code>.</p>
<h3>Clase</h3>
<p><strong>DefiniciÃ³n:</strong> Plantilla para crear objetos con atributos y mÃ©todos.<br />
<strong>AnalogÃ­a:</strong> El plano de una casa; los objetos son las casas construidas.</p>
<h3>ColisiÃ³n (Hash)</h3>
<p><strong>DefiniciÃ³n:</strong> Cuando dos claves diferentes producen el mismo hash.<br />
<strong>ResoluciÃ³n:</strong> Python usa "open addressing" para encontrar otro slot.</p>
<h3>Complejidad Temporal</h3>
<p><strong>DefiniciÃ³n:</strong> CuÃ¡nto tiempo toma un algoritmo en funciÃ³n del tamaÃ±o de entrada.</p>
<h3>Cycle (Grafo)</h3>
<p><strong>DefiniciÃ³n:</strong> Camino que comienza y termina en el mismo vÃ©rtice.<br />
<strong>DetecciÃ³n:</strong> DFS puede detectar ciclos en O(V + E).</p>
<h3>Cosine Similarity</h3>
<p><strong>DefiniciÃ³n:</strong> Medida de similitud entre vectores basada en el Ã¡ngulo entre ellos.<br />
<strong>FÃ³rmula:</strong> cos(Î¸) = (AÂ·B) / (||A|| Ã— ||B||)<br />
<strong>Rango:</strong> 0 (perpendiculares) a 1 (paralelos) para vectores TF-IDF.</p>
<hr />
<h2>D</h2>
<h3>DFS (Depth-First Search)</h3>
<p><strong>DefiniciÃ³n:</strong> Algoritmo de recorrido que explora lo mÃ¡s profundo posible antes de retroceder.<br />
<strong>Estructura:</strong> Usa Stack o recursiÃ³n.<br />
<strong>Uso:</strong> Detectar ciclos, encontrar caminos, topological sort.<br />
<strong>Complejidad:</strong> O(V + E)</p>
<h3>Divide &amp; Conquer</h3>
<p><strong>DefiniciÃ³n:</strong> Estrategia de dividir problema en subproblemas, resolverlos y combinar.<br />
<strong>Ejemplos:</strong> MergeSort, QuickSort, Binary Search.</p>
<h3>Document Frequency (DF)</h3>
<p><strong>DefiniciÃ³n:</strong> NÃºmero de documentos que contienen un tÃ©rmino.<br />
<strong>Uso:</strong> Para calcular IDF.</p>
<h3>Docstring</h3>
<p><strong>DefiniciÃ³n:</strong> String de documentaciÃ³n al inicio de funciÃ³n/clase/mÃ³dulo.<br />
<strong>Formato:</strong> Google style, NumPy style, o reStructuredText.</p>
<h3>Dynamic Programming (DP)</h3>
<p><strong>DefiniciÃ³n:</strong> TÃ©cnica de optimizaciÃ³n que guarda resultados de subproblemas.<br />
<strong>Requisitos:</strong> Optimal substructure + overlapping subproblems.<br />
<strong>Enfoques:</strong> Top-down (memoization) y Bottom-up (tabulation).</p>
<hr />
<h2>F</h2>
<h3>FIFO (First In, First Out)</h3>
<p><strong>DefiniciÃ³n:</strong> Orden donde el primero en entrar es el primero en salir.<br />
<strong>Estructura:</strong> Queue.<br />
<strong>AnalogÃ­a:</strong> Fila del supermercado.</p>
<hr />
<h2>G</h2>
<h3>Graph (Grafo)</h3>
<p><strong>DefiniciÃ³n:</strong> Estructura de nodos (vÃ©rtices) conectados por aristas (edges).<br />
<strong>Tipos:</strong> Dirigido/no dirigido, ponderado/no ponderado.<br />
<strong>RepresentaciÃ³n:</strong> Adjacency list o matrix.</p>
<h3>Greedy Algorithm</h3>
<p><strong>DefiniciÃ³n:</strong> Estrategia que toma la mejor opciÃ³n local en cada paso.<br />
<strong>Requisito:</strong> Greedy choice property para garantizar Ã³ptimo.<br />
<strong>Ejemplos:</strong> Activity selection, Huffman coding.</p>
<hr />
<h2>H</h2>
<h3>Heap</h3>
<p><strong>DefiniciÃ³n:</strong> Ãrbol binario completo con propiedad de heap (parent &lt;= children para min-heap).<br />
<strong>Operaciones:</strong> Insert O(log n), extract-min O(log n), peek O(1).<br />
<strong>Uso:</strong> Priority queues, heapsort, top-K problems.</p>
<h3>Hash Function</h3>
<p><strong>DefiniciÃ³n:</strong> FunciÃ³n que convierte cualquier dato en un nÃºmero (hash).<br />
<strong>Propiedades:</strong> Determinista, rÃ¡pida, distribuciÃ³n uniforme.</p>
<h3>Hash Map / Hash Table</h3>
<p><strong>DefiniciÃ³n:</strong> Estructura que mapea claves a valores usando hashing.<br />
<strong>En Python:</strong> <code>dict</code>.<br />
<strong>Complejidad:</strong> O(1) promedio para get/set/delete.</p>
<hr />
<h2>I</h2>
<h3>IDF (Inverse Document Frequency)</h3>
<p><strong>DefiniciÃ³n:</strong> Medida de quÃ© tan raro es un tÃ©rmino en el corpus.<br />
<strong>FÃ³rmula:</strong> IDF(t) = log(N / df(t)) donde N = total docs, df = doc frequency.<br />
<strong>IntuiciÃ³n:</strong> Palabras raras tienen IDF alto.</p>
<h3>Ãndice Invertido</h3>
<p><strong>DefiniciÃ³n:</strong> Estructura que mapea tÃ©rminos a documentos que los contienen.<br />
<strong>Estructura:</strong> <code>{tÃ©rmino: [lista de doc_ids]}</code><br />
<strong>Uso:</strong> CorazÃ³n de los motores de bÃºsqueda.</p>
<h3>Inmutabilidad</h3>
<p><strong>DefiniciÃ³n:</strong> Propiedad de objetos que no pueden modificarse despuÃ©s de crearse.<br />
<strong>En Python:</strong> str, tuple, frozenset son inmutables.</p>
<h3>In-Place</h3>
<p><strong>DefiniciÃ³n:</strong> Algoritmo que modifica la estructura original sin crear copia.<br />
<strong>Ejemplo:</strong> QuickSort in-place usa O(log n) espacio extra.</p>
<hr />
<h2>I</h2>
<h3>Inorder Traversal</h3>
<p><strong>DefiniciÃ³n:</strong> Recorrido de Ã¡rbol: Left, Root, Right.<br />
<strong>Propiedad:</strong> En BST, da elementos en orden ascendente.</p>
<hr />
<h2>L</h2>
<h3>Leaf Node</h3>
<p><strong>DefiniciÃ³n:</strong> Nodo de Ã¡rbol sin hijos.<br />
<strong>IdentificaciÃ³n:</strong> node.left == None and node.right == None</p>
<h3>LIFO (Last In, First Out)</h3>
<p><strong>DefiniciÃ³n:</strong> Orden donde el Ãºltimo en entrar es el primero en salir.<br />
<strong>Estructura:</strong> Stack.<br />
<strong>AnalogÃ­a:</strong> Pila de platos.</p>
<h3>Linked List</h3>
<p><strong>DefiniciÃ³n:</strong> Estructura de nodos donde cada nodo apunta al siguiente.<br />
<strong>Tipos:</strong> Singly (un puntero), Doubly (dos punteros).<br />
<strong>Ventaja:</strong> O(1) insert/delete al inicio.</p>
<h3>Linter</h3>
<p><strong>DefiniciÃ³n:</strong> Herramienta que analiza cÃ³digo para detectar errores y problemas de estilo.<br />
<strong>Ejemplos:</strong> ruff, flake8, pylint.</p>
<h3>LogarÃ­tmico</h3>
<p><strong>DefiniciÃ³n:</strong> Complejidad O(log n) - crece muy lentamente.<br />
<strong>Ejemplo:</strong> Binary search en 1 billÃ³n de elementos = ~30 pasos.</p>
<hr />
<h2>M</h2>
<h3>Matriz</h3>
<p><strong>DefiniciÃ³n:</strong> Array bidimensional de nÃºmeros.<br />
<strong>En Python puro:</strong> Lista de listas: <code>[[1,2], [3,4]]</code>.</p>
<h3>Memoization</h3>
<p><strong>DefiniciÃ³n:</strong> TÃ©cnica de cachear resultados de funciones para evitar recÃ¡lculo.<br />
<strong>Uso:</strong> Optimizar recursiÃ³n (ej: Fibonacci).</p>
<h3>MergeSort</h3>
<p><strong>DefiniciÃ³n:</strong> Algoritmo de ordenamiento divide &amp; conquer.<br />
<strong>Complejidad:</strong> O(n log n) siempre.<br />
<strong>Propiedad:</strong> Estable.</p>
<hr />
<h2>N</h2>
<h3>Norma (Vector)</h3>
<p><strong>DefiniciÃ³n:</strong> Longitud/magnitud de un vector.<br />
<strong>FÃ³rmula:</strong> ||v|| = âˆš(vâ‚Â² + vâ‚‚Â² + ... + vâ‚™Â²)</p>
<hr />
<h2>O</h2>
<h3>Optimal Substructure</h3>
<p><strong>DefiniciÃ³n:</strong> Propiedad donde soluciÃ³n Ã³ptima contiene soluciones Ã³ptimas de subproblemas.<br />
<strong>Requisito:</strong> Necesario para aplicar DP o Greedy.</p>
<h3>Overlapping Subproblems</h3>
<p><strong>DefiniciÃ³n:</strong> Cuando los mismos subproblemas se resuelven mÃºltiples veces.<br />
<strong>Requisito:</strong> Necesario para que DP sea beneficioso.</p>
<h3>Off-by-One Error</h3>
<p><strong>DefiniciÃ³n:</strong> Error donde un Ã­ndice estÃ¡ desplazado por 1.<br />
<strong>ComÃºn en:</strong> Loops, binary search, slicing.</p>
<h3>OOP (Object-Oriented Programming)</h3>
<p><strong>DefiniciÃ³n:</strong> Paradigma que organiza cÃ³digo en objetos con datos y comportamiento.<br />
<strong>Pilares:</strong> Encapsulamiento, herencia, polimorfismo.</p>
<hr />
<h2>P</h2>
<h3>Postorder Traversal</h3>
<p><strong>DefiniciÃ³n:</strong> Recorrido de Ã¡rbol: Left, Right, Root.<br />
<strong>Uso:</strong> Eliminar Ã¡rbol (hijos antes que padre), evaluar expresiones.</p>
<h3>Preorder Traversal</h3>
<p><strong>DefiniciÃ³n:</strong> Recorrido de Ã¡rbol: Root, Left, Right.<br />
<strong>Uso:</strong> Copiar/serializar Ã¡rbol.</p>
<h3>Priority Queue</h3>
<p><strong>DefiniciÃ³n:</strong> Cola donde elementos salen segÃºn prioridad, no orden de llegada.<br />
<strong>ImplementaciÃ³n:</strong> TÃ­picamente con Heap.<br />
<strong>Operaciones:</strong> Insert O(log n), extract O(log n).</p>
<h3>Partition</h3>
<p><strong>DefiniciÃ³n:</strong> En QuickSort, reorganizar array para que elementos &lt; pivot estÃ©n antes.<br />
<strong>Resultado:</strong> Pivot queda en su posiciÃ³n final.</p>
<h3>PEP8</h3>
<p><strong>DefiniciÃ³n:</strong> GuÃ­a de estilo oficial de Python.<br />
<strong>Puntos clave:</strong> 4 espacios, 79-88 chars lÃ­nea, snake_case.</p>
<h3>Producto Punto (Dot Product)</h3>
<p><strong>DefiniciÃ³n:</strong> Suma de productos de componentes correspondientes.<br />
<strong>FÃ³rmula:</strong> aÂ·b = aâ‚bâ‚ + aâ‚‚bâ‚‚ + ... + aâ‚™bâ‚™</p>
<h3>Property</h3>
<p><strong>DefiniciÃ³n:</strong> Mecanismo para controlar acceso a atributos con getters/setters.<br />
<strong>Uso:</strong> ValidaciÃ³n, cÃ¡lculo dinÃ¡mico, encapsulamiento.</p>
<hr />
<h2>Q</h2>
<h3>Queue</h3>
<p><strong>DefiniciÃ³n:</strong> Estructura de datos FIFO (First In, First Out).<br />
<strong>Operaciones:</strong> enqueue O(1), dequeue O(1).<br />
<strong>Uso:</strong> BFS, scheduling, buffers.</p>
<h3>QuickSort</h3>
<p><strong>DefiniciÃ³n:</strong> Algoritmo de ordenamiento basado en particiÃ³n.<br />
<strong>Complejidad:</strong> O(n log n) promedio, O(nÂ²) peor caso.<br />
<strong>Ventaja:</strong> In-place, cache-friendly.</p>
<hr />
<h2>R</h2>
<h3>RecursiÃ³n</h3>
<p><strong>DefiniciÃ³n:</strong> TÃ©cnica donde una funciÃ³n se llama a sÃ­ misma.<br />
<strong>Componentes:</strong> Caso base + caso recursivo.</p>
<hr />
<h2>S</h2>
<h3>Stack</h3>
<p><strong>DefiniciÃ³n:</strong> Estructura de datos LIFO (Last In, First Out).<br />
<strong>Operaciones:</strong> push O(1), pop O(1), peek O(1).<br />
<strong>Uso:</strong> Call stack, DFS, undo, parsing.</p>
<h3>Set</h3>
<p><strong>DefiniciÃ³n:</strong> ColecciÃ³n de elementos Ãºnicos sin orden.<br />
<strong>Operaciones O(1):</strong> add, remove, contains.</p>
<h3>SOLID</h3>
<p><strong>DefiniciÃ³n:</strong> 5 principios de diseÃ±o orientado a objetos.<br />
- <strong>S</strong>ingle Responsibility<br />
- <strong>O</strong>pen/Closed<br />
- <strong>L</strong>iskov Substitution<br />
- <strong>I</strong>nterface Segregation<br />
- <strong>D</strong>ependency Inversion</p>
<h3>Stable Sort</h3>
<p><strong>DefiniciÃ³n:</strong> Ordenamiento que mantiene orden relativo de elementos iguales.<br />
<strong>Ejemplo:</strong> MergeSort es estable, QuickSort no.</p>
<hr />
<h2>T</h2>
<h3>Tabulation</h3>
<p><strong>DefiniciÃ³n:</strong> Enfoque de DP que llena tabla iterativamente desde casos base.<br />
<strong>SinÃ³nimo:</strong> Bottom-up DP.<br />
<strong>Ventaja:</strong> No usa call stack.</p>
<h3>Top-Down (DP)</h3>
<p><strong>DefiniciÃ³n:</strong> Enfoque de DP recursivo con memoization.<br />
<strong>Ventaja:</strong> Solo calcula subproblemas necesarios.</p>
<h3>Tree (Ãrbol)</h3>
<p><strong>DefiniciÃ³n:</strong> Estructura jerÃ¡rquica de nodos sin ciclos.<br />
<strong>TÃ©rminos:</strong> Root, parent, child, leaf, height, depth.<br />
<strong>Tipos:</strong> Binary tree, BST, AVL, etc.</p>
<h3>Tree Traversal</h3>
<p><strong>DefiniciÃ³n:</strong> Visitar todos los nodos de un Ã¡rbol.<br />
<strong>DFS:</strong> Inorder, Preorder, Postorder.<br />
<strong>BFS:</strong> Level-order.</p>
<h3>Term Frequency (TF)</h3>
<p><strong>DefiniciÃ³n:</strong> Frecuencia de un tÃ©rmino en un documento.<br />
<strong>FÃ³rmula:</strong> TF(t,d) = count(t,d) / total_terms(d)</p>
<h3>TF-IDF</h3>
<p><strong>DefiniciÃ³n:</strong> Producto de Term Frequency Ã— Inverse Document Frequency.<br />
<strong>Uso:</strong> Medir importancia de tÃ©rmino en documento dentro de corpus.</p>
<h3>TokenizaciÃ³n</h3>
<p><strong>DefiniciÃ³n:</strong> Proceso de dividir texto en unidades (tokens).<br />
<strong>Ejemplo:</strong> "Hello, World!" â†’ ["hello", "world"]</p>
<h3>Type Hint</h3>
<p><strong>DefiniciÃ³n:</strong> AnotaciÃ³n que indica el tipo esperado de variable/parÃ¡metro/retorno.<br />
<strong>Ejemplo:</strong> <code>def greet(name: str) -&gt; str:</code></p>
<hr />
<h2>V</h2>
<h3>Vector</h3>
<p><strong>DefiniciÃ³n:</strong> Lista ordenada de nÃºmeros que representa punto/direcciÃ³n en espacio.<br />
<strong>En Python puro:</strong> <code>list[float]</code><br />
<strong>Uso en IR:</strong> Representar documentos en espacio de tÃ©rminos.</p>
<h3>Vertex (VÃ©rtice)</h3>
<p><strong>DefiniciÃ³n:</strong> Nodo en un grafo.<br />
<strong>Plural:</strong> Vertices.<br />
<strong>NotaciÃ³n:</strong> V = nÃºmero de vÃ©rtices.</p>
<h3>Vocabulario</h3>
<p><strong>DefiniciÃ³n:</strong> Conjunto de todos los tÃ©rminos Ãºnicos en un corpus.<br />
<strong>TamaÃ±o:</strong> Determina dimensiÃ³n de vectores TF-IDF.</p>
<hr />
<h2>Siglas Comunes</h2>
<table>
<thead>
<tr>
<th>Sigla</th>
<th>Significado</th>
</tr>
</thead>
<tbody>
<tr>
<td>BST</td>
<td>Binary Search Tree</td>
</tr>
<tr>
<td>BFS</td>
<td>Breadth-First Search</td>
</tr>
<tr>
<td>DFS</td>
<td>Depth-First Search</td>
</tr>
<tr>
<td>DP</td>
<td>Dynamic Programming</td>
</tr>
<tr>
<td>FIFO</td>
<td>First In, First Out</td>
</tr>
<tr>
<td>LIFO</td>
<td>Last In, First Out</td>
</tr>
<tr>
<td>OOP</td>
<td>Object-Oriented Programming</td>
</tr>
<tr>
<td>TF</td>
<td>Term Frequency</td>
</tr>
<tr>
<td>IDF</td>
<td>Inverse Document Frequency</td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_CHECKLIST" class="cover-page">
            <a name="mod_CHECKLIST"></a>
            <div class="cover-title">Checklist Final</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>â˜‘ï¸ Checklist Final</h1>
<blockquote>
<p>VerificaciÃ³n completa antes de considerar el proyecto terminado.</p>
</blockquote>
<hr />
<h2>ğŸ—ï¸ Estructura del Proyecto</h2>
<ul>
<li>[ ] Carpeta <code>src/</code> con todos los mÃ³dulos</li>
<li>[ ] Carpeta <code>tests/</code> con tests unitarios</li>
<li>[ ] Carpeta <code>docs/</code> con documentaciÃ³n</li>
<li>[ ] Carpeta <code>data/</code> con corpus de ejemplo</li>
<li>[ ] <code>README.md</code> en la raÃ­z</li>
<li>[ ] <code>pyproject.toml</code> configurado</li>
</ul>
<h3>Archivos Requeridos</h3>
<pre><code>archimedes-indexer/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py          âœ“
â”‚   â”œâ”€â”€ document.py          âœ“
â”‚   â”œâ”€â”€ tokenizer.py         âœ“
â”‚   â”œâ”€â”€ inverted_index.py    âœ“
â”‚   â”œâ”€â”€ sorting.py           âœ“
â”‚   â”œâ”€â”€ searching.py         âœ“
â”‚   â”œâ”€â”€ linear_algebra.py    âœ“
â”‚   â”œâ”€â”€ vectorizer.py        âœ“
â”‚   â”œâ”€â”€ similarity.py        âœ“
â”‚   â””â”€â”€ search_engine.py     âœ“
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ test_*.py            âœ“
â”œâ”€â”€ docs/
â”‚   â””â”€â”€ COMPLEXITY_ANALYSIS.md âœ“
â”œâ”€â”€ README.md                âœ“
â””â”€â”€ pyproject.toml           âœ“
</code></pre>
<hr />
<h2>ğŸ’» CÃ³digo</h2>
<h3>Type Hints</h3>
<ul>
<li>[ ] Todos los parÃ¡metros de funciÃ³n tienen type hints</li>
<li>[ ] Todos los retornos de funciÃ³n tienen type hints</li>
<li>[ ] Atributos de clase estÃ¡n tipados</li>
<li>[ ] <code>mypy src/</code> pasa sin errores</li>
</ul>
<h3>Estilo</h3>
<ul>
<li>[ ] PEP8 cumplido</li>
<li>[ ] <code>ruff check src/</code> pasa sin errores</li>
<li>[ ] Nombres descriptivos (no <code>x</code>, <code>temp</code>, <code>data</code>)</li>
<li>[ ] LÃ­neas &lt; 88 caracteres</li>
</ul>
<h3>DocumentaciÃ³n en CÃ³digo</h3>
<ul>
<li>[ ] Todas las clases tienen docstring</li>
<li>[ ] Todas las funciones pÃºblicas tienen docstring</li>
<li>[ ] Docstrings incluyen Args, Returns, Example</li>
</ul>
<hr />
<h2>ğŸ§ª Testing</h2>
<h3>Cobertura</h3>
<ul>
<li>[ ] <code>test_document.py</code> existe</li>
<li>[ ] <code>test_tokenizer.py</code> existe</li>
<li>[ ] <code>test_inverted_index.py</code> existe</li>
<li>[ ] <code>test_sorting.py</code> existe</li>
<li>[ ] <code>test_searching.py</code> existe</li>
<li>[ ] <code>test_vectorizer.py</code> existe</li>
<li>[ ] <code>test_similarity.py</code> existe</li>
<li>[ ] <code>test_search_engine.py</code> existe</li>
</ul>
<h3>Calidad</h3>
<ul>
<li>[ ] Coverage &gt; 80%</li>
<li>[ ] Tests para casos normales</li>
<li>[ ] Tests para edge cases (vacÃ­o, None, etc.)</li>
<li>[ ] Todos los tests pasan</li>
</ul>
<h3>Comando de VerificaciÃ³n</h3>
<pre><code class="language-bash">pytest tests/ -v --cov=src --cov-fail-under=80
</code></pre>
<hr />
<h2>ğŸ“Š AnÃ¡lisis Big O</h2>
<h3>Documento COMPLEXITY_ANALYSIS.md</h3>
<ul>
<li>[ ] AnÃ¡lisis de <code>add_document()</code></li>
<li>[ ] AnÃ¡lisis de <code>build_index()</code></li>
<li>[ ] AnÃ¡lisis de <code>search()</code></li>
<li>[ ] AnÃ¡lisis de <code>quicksort()</code></li>
<li>[ ] AnÃ¡lisis de <code>binary_search()</code></li>
<li>[ ] AnÃ¡lisis de <code>cosine_similarity()</code></li>
<li>[ ] JustificaciÃ³n para cada anÃ¡lisis</li>
</ul>
<h3>Correctitud</h3>
<ul>
<li>[ ] <code>quicksort</code>: O(n log n) promedio, O(nÂ²) peor</li>
<li>[ ] <code>binary_search</code>: O(log n)</li>
<li>[ ] <code>cosine_similarity</code>: O(V) donde V = dimensiÃ³n vector</li>
<li>[ ] Hash table operations: O(1) amortizado</li>
</ul>
<hr />
<h2>ğŸ“ DocumentaciÃ³n</h2>
<h3>README.md</h3>
<ul>
<li>[ ] TÃ­tulo y descripciÃ³n clara</li>
<li>[ ] Features principales listados</li>
<li>[ ] Instrucciones de instalaciÃ³n</li>
<li>[ ] Ejemplo de uso con cÃ³digo</li>
<li>[ ] Link a COMPLEXITY_ANALYSIS.md</li>
<li>[ ] Instrucciones para ejecutar tests</li>
<li>[ ] Escrito en inglÃ©s</li>
</ul>
<h3>Ejemplo README Check</h3>
<pre><code class="language-markdown"># Archimedes Indexer âœ“

A search engine built from scratch... âœ“

## Features âœ“
- Inverted index
- TF-IDF
- Cosine similarity
- Pure Python (no numpy)

## Installation âœ“
git clone...
pip install...

## Usage âœ“
```python
from src import SearchEngine
engine = SearchEngine()
...
</code></pre>
<h2>Testing âœ“</h2>
<p>pytest tests/</p>
<h2>Complexity âœ“</h2>
<p>See docs/COMPLEXITY_ANALYSIS.md</p>
<pre><code>
---

## ğŸ¯ Funcionalidad

### Motor de BÃºsqueda
- [ ] Puede agregar documentos
- [ ] Puede construir Ã­ndice
- [ ] Puede buscar por query
- [ ] Retorna resultados ordenados por score
- [ ] Scores estÃ¡n entre 0 y 1

### Demo
- [ ] Script de demo funciona
- [ ] Demo usa corpus de ejemplo
- [ ] Demo muestra resultados formateados

---

## ğŸš€ VerificaciÃ³n Final

Ejecuta todos estos comandos y verifica que pasen:

```bash
# 1. Type checking
mypy src/
# Esperado: Success: no issues found

# 2. Linting
ruff check src/
# Esperado: All checks passed!

# 3. Tests
pytest tests/ -v
# Esperado: X passed

# 4. Coverage
pytest tests/ --cov=src --cov-report=term-missing
# Esperado: TOTAL coverage &gt; 80%

# 5. Demo
python -c &quot;
from src.search_engine import SearchEngine
engine = SearchEngine()
engine.add_document(1, 'Test', 'python programming tutorial')
engine.add_document(2, 'Test2', 'java programming guide')
engine.build_index()
results = engine.search('python')
print('Results:', results)
assert len(results) &gt; 0
print('âœ… Demo passed!')
&quot;
</code></pre>
<hr />
<h2>âœ… DeclaraciÃ³n de Completitud</h2>
<p>Marca cuando hayas verificado todo:</p>
<ul>
<li>[ ] <strong>Estructura:</strong> Todos los archivos en su lugar</li>
<li>[ ] <strong>CÃ³digo:</strong> Type hints, estilo, documentaciÃ³n</li>
<li>[ ] <strong>Tests:</strong> Coverage &gt; 80%, todos pasan</li>
<li>[ ] <strong>Big O:</strong> AnÃ¡lisis completo y correcto</li>
<li>[ ] <strong>Docs:</strong> README profesional en inglÃ©s</li>
<li>[ ] <strong>Funcionalidad:</strong> Motor funciona correctamente</li>
</ul>
<p><strong>Fecha de completitud:</strong> <strong><em>_</em></strong><strong><em>_</em></strong>_</p>
<p><strong>PuntuaciÃ³n autoevaluada:</strong> ___ / 100</p>
        </section>
        
        <div id="mod_RECURSOS" class="cover-page">
            <a name="mod_RECURSOS"></a>
            <div class="cover-title">Recursos Recomendados</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>ğŸ“š Recursos de Aprendizaje</h1>
<blockquote>
<p>Cursos, libros, videos y herramientas recomendados.</p>
</blockquote>
<hr />
<h2>ğŸ“ Cursos Online</h2>
<h3>MatemÃ¡ticas para ML (Obligatorios)</h3>
<table>
<thead>
<tr>
<th>Curso</th>
<th>Plataforma</th>
<th>DuraciÃ³n</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.coursera.org/learn/linear-algebra-machine-learning">Mathematics for ML: Linear Algebra</a></td>
<td>Coursera</td>
<td>5 semanas</td>
</tr>
<tr>
<td><a href="https://www.coursera.org/learn/multivariate-calculus-machine-learning">Mathematics for ML: Multivariate Calculus</a></td>
<td>Coursera</td>
<td>6 semanas</td>
</tr>
<tr>
<td><a href="https://www.coursera.org/learn/machine-learning-probability-statistics">Probability &amp; Statistics for ML</a></td>
<td>Coursera</td>
<td>4 semanas</td>
</tr>
</tbody>
</table>
<h3>Algoritmos y DSA (Obligatorios)</h3>
<table>
<thead>
<tr>
<th>Curso</th>
<th>Plataforma</th>
<th>DuraciÃ³n</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.coursera.org/specializations/algorithms">Algorithms Specialization</a></td>
<td>Coursera (Stanford)</td>
<td>4 meses</td>
</tr>
<tr>
<td><a href="https://www.coursera.org/specializations/data-structures-algorithms">Data Structures &amp; Algorithms</a></td>
<td>Coursera (UCSD)</td>
<td>8 meses</td>
</tr>
</tbody>
</table>
<h3>Python (Recomendados)</h3>
<table>
<thead>
<tr>
<th>Curso</th>
<th>Plataforma</th>
<th>Nivel</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.coursera.org/specializations/python">Python for Everybody</a></td>
<td>Coursera</td>
<td>BÃ¡sico</td>
</tr>
<tr>
<td><a href="https://realpython.com/">Real Python Tutorials</a></td>
<td>Web</td>
<td>Todos</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ“– Libros</h2>
<h3>Algoritmos (Altamente Recomendados)</h3>
<table>
<thead>
<tr>
<th>Libro</th>
<th>Autor</th>
<th>Por QuÃ©</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Grokking Algorithms</strong></td>
<td>Aditya Bhargava</td>
<td>Visual, accesible, perfecto para empezar</td>
</tr>
<tr>
<td><strong>Introduction to Algorithms (CLRS)</strong></td>
<td>Cormen et al.</td>
<td>La biblia de algoritmos, referencia completa</td>
</tr>
<tr>
<td><strong>Algorithm Design Manual</strong></td>
<td>Skiena</td>
<td>PrÃ¡ctico, con problemas reales</td>
</tr>
</tbody>
</table>
<h3>Python</h3>
<table>
<thead>
<tr>
<th>Libro</th>
<th>Autor</th>
<th>Por QuÃ©</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Fluent Python</strong></td>
<td>Luciano Ramalho</td>
<td>Python avanzado y pythonic</td>
</tr>
<tr>
<td><strong>Python Cookbook</strong></td>
<td>Beazley &amp; Jones</td>
<td>Recetas prÃ¡cticas</td>
</tr>
</tbody>
</table>
<h3>MatemÃ¡ticas</h3>
<table>
<thead>
<tr>
<th>Libro</th>
<th>Autor</th>
<th>Por QuÃ©</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Linear Algebra Done Right</strong></td>
<td>Axler</td>
<td>Ãlgebra lineal rigurosa</td>
</tr>
<tr>
<td><strong>Mathematics for ML</strong></td>
<td>Deisenroth et al.</td>
<td><a href="https://mml-book.github.io/">Gratis online</a></td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ¥ Videos</h2>
<h3>Canales de YouTube</h3>
<table>
<thead>
<tr>
<th>Canal</th>
<th>Tema</th>
<th>Por QuÃ©</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.youtube.com/c/3blue1brown">3Blue1Brown</a></td>
<td>MatemÃ¡ticas visuales</td>
<td>IntuiciÃ³n geomÃ©trica increÃ­ble</td>
</tr>
<tr>
<td><a href="https://www.youtube.com/c/AbdulBari">Abdul Bari</a></td>
<td>Algoritmos</td>
<td>Explicaciones claras</td>
</tr>
<tr>
<td><a href="https://www.youtube.com/c/Coreyms">Corey Schafer</a></td>
<td>Python</td>
<td>Tutoriales prÃ¡cticos</td>
</tr>
<tr>
<td><a href="https://www.youtube.com/c/mitocw">MIT OpenCourseWare</a></td>
<td>CS general</td>
<td>Clases de MIT gratis</td>
</tr>
</tbody>
</table>
<h3>Videos EspecÃ­ficos</h3>
<table>
<thead>
<tr>
<th>Video</th>
<th>Tema</th>
<th>Link</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linear Algebra Essence</td>
<td>Ãlgebra lineal</td>
<td><a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">3B1B Playlist</a></td>
</tr>
<tr>
<td>QuickSort Visualization</td>
<td>Sorting</td>
<td><a href="https://visualgo.net/en/sorting">Visualgo</a></td>
</tr>
<tr>
<td>TF-IDF Explained</td>
<td>Information Retrieval</td>
<td><a href="https://www.youtube.com/watch?v=IIi6e5oDZ68">StatQuest</a></td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ› ï¸ Herramientas</h2>
<h3>Desarrollo</h3>
<table>
<thead>
<tr>
<th>Herramienta</th>
<th>PropÃ³sito</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://code.visualstudio.com/">VS Code</a></td>
<td>Editor de cÃ³digo</td>
</tr>
<tr>
<td><a href="https://www.python.org/">Python</a></td>
<td>3.11+ recomendado</td>
</tr>
<tr>
<td><a href="https://git-scm.com/">Git</a></td>
<td>Control de versiones</td>
</tr>
</tbody>
</table>
<h3>Python Tooling</h3>
<table>
<thead>
<tr>
<th>Herramienta</th>
<th>PropÃ³sito</th>
<th>Comando</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://mypy.readthedocs.io/">mypy</a></td>
<td>Type checking</td>
<td><code>pip install mypy</code></td>
</tr>
<tr>
<td><a href="https://github.com/astral-sh/ruff">ruff</a></td>
<td>Linting rÃ¡pido</td>
<td><code>pip install ruff</code></td>
</tr>
<tr>
<td><a href="https://pytest.org/">pytest</a></td>
<td>Testing</td>
<td><code>pip install pytest</code></td>
</tr>
<tr>
<td><a href="https://pytest-cov.readthedocs.io/">pytest-cov</a></td>
<td>Coverage</td>
<td><code>pip install pytest-cov</code></td>
</tr>
</tbody>
</table>
<h3>VisualizaciÃ³n de Algoritmos</h3>
<table>
<thead>
<tr>
<th>Herramienta</th>
<th>URL</th>
</tr>
</thead>
<tbody>
<tr>
<td>Visualgo</td>
<td><a href="https://visualgo.net/">visualgo.net</a></td>
</tr>
<tr>
<td>Python Tutor</td>
<td><a href="https://pythontutor.com/">pythontutor.com</a></td>
</tr>
<tr>
<td>Algorithm Visualizer</td>
<td><a href="https://algorithm-visualizer.org/">algorithm-visualizer.org</a></td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ’ª PrÃ¡ctica de Algoritmos</h2>
<h3>Plataformas</h3>
<table>
<thead>
<tr>
<th>Plataforma</th>
<th>Nivel</th>
<th>Enfoque</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.com/">LeetCode</a></td>
<td>Todos</td>
<td>Entrevistas tÃ©cnicas</td>
</tr>
<tr>
<td><a href="https://www.hackerrank.com/">HackerRank</a></td>
<td>Principiante-Intermedio</td>
<td>Aprendizaje estructurado</td>
</tr>
<tr>
<td><a href="https://www.codewars.com/">Codewars</a></td>
<td>Todos</td>
<td>Katas cortos</td>
</tr>
<tr>
<td><a href="https://projecteuler.net/">Project Euler</a></td>
<td>MatemÃ¡tico</td>
<td>Problemas matemÃ¡ticos</td>
</tr>
</tbody>
</table>
<h3>Problemas Recomendados por Tema</h3>
<h4>Arrays y Strings</h4>
<ul>
<li>Two Sum (LeetCode #1)</li>
<li>Valid Anagram (LeetCode #242)</li>
<li>Reverse String (LeetCode #344)</li>
</ul>
<h4>Hash Maps</h4>
<ul>
<li>Group Anagrams (LeetCode #49)</li>
<li>Word Pattern (LeetCode #290)</li>
<li>Top K Frequent Elements (LeetCode #347)</li>
</ul>
<h4>Sorting</h4>
<ul>
<li>Sort an Array (LeetCode #912)</li>
<li>Merge Intervals (LeetCode #56)</li>
<li>Kth Largest Element (LeetCode #215)</li>
</ul>
<h4>Binary Search</h4>
<ul>
<li>Binary Search (LeetCode #704)</li>
<li>Search Insert Position (LeetCode #35)</li>
<li>First Bad Version (LeetCode #278)</li>
</ul>
<hr />
<h2>ğŸ¯ Pathway de CU Boulder</h2>
<h3>Cursos del Pathway</h3>
<p>El pathway tÃ­pico incluye:</p>
<table>
<thead>
<tr>
<th>Curso</th>
<th>Tema</th>
</tr>
</thead>
<tbody>
<tr>
<td>Algorithms for Searching, Sorting, and Indexing</td>
<td>DSA bÃ¡sico</td>
</tr>
<tr>
<td>Trees and Graphs: Basics</td>
<td>Estructuras de datos</td>
</tr>
<tr>
<td>Dynamic Programming, Greedy Algorithms</td>
<td>Algoritmos avanzados</td>
</tr>
</tbody>
</table>
<h3>PreparaciÃ³n EspecÃ­fica</h3>
<ol>
<li><strong>Auditar los cursos</strong> en Coursera (gratis)</li>
<li><strong>Practicar</strong> problemas de LeetCode nivel Easy/Medium</li>
<li><strong>Dominar</strong> sorting y searching (el foco del examen)</li>
<li><strong>Entender</strong> Big O profundamente</li>
</ol>
<hr />
<h2>ğŸ“… Ruta de Aprendizaje Sugerida</h2>
<h3>Semana 1-2: Fundamentos</h3>
<ul>
<li>Curso: Mathematics for ML: Linear Algebra</li>
<li>Libro: Grokking Algorithms (Cap 1-2)</li>
<li>Videos: 3B1B Linear Algebra</li>
</ul>
<h3>Semana 3-4: DSA BÃ¡sico</h3>
<ul>
<li>Libro: Grokking Algorithms (Cap 3-5)</li>
<li>LeetCode: 10 problemas Easy de arrays</li>
<li>Video: Abdul Bari sorting algorithms</li>
</ul>
<h3>Semana 5-8: DSA Avanzado</h3>
<ul>
<li>Curso: Algorithms Specialization (Parte 1)</li>
<li>LeetCode: 20 problemas Easy-Medium</li>
<li>Implementar: QuickSort, MergeSort, Binary Search</li>
</ul>
<h3>Semana 9-12: Proyecto</h3>
<ul>
<li>Construir Archimedes Indexer</li>
<li>Documentar anÃ¡lisis Big O</li>
<li>Practicar explicar en inglÃ©s</li>
</ul>
<hr />
<h2>ğŸ”— Links Directos</h2>
<ul>
<li><a href="https://www.coursera.org/degrees/ms-artificial-intelligence-boulder">MS in AI - CU Boulder</a></li>
<li><a href="https://www.coursera.org/degrees/ms-artificial-intelligence-boulder/admissions">Pathway Details</a></li>
<li><a href="https://mml-book.github.io/">Mathematics for ML Book (Free)</a></li>
<li><a href="https://www.bigocheatsheet.com/">Big O Cheat Sheet</a></li>
<li><a href="https://wiki.python.org/moin/TimeComplexity">Python Time Complexity</a></li>
</ul>
        </section>
        
        <div id="mod_SIMULACRO_ENTREVISTA" class="cover-page">
            <a name="mod_SIMULACRO_ENTREVISTA"></a>
            <div class="cover-title">Simulacro de Entrevista</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>ğŸ¯ Simulacro de Entrevista - Pathway Prep</h1>
<blockquote>
<p>80 preguntas tipo Pathway con respuestas detalladas.</p>
</blockquote>
<hr />
<h2>ğŸ“‹ Estructura del Simulacro</h2>
<table>
<thead>
<tr>
<th>SecciÃ³n</th>
<th>Preguntas</th>
<th>Tiempo Sugerido</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python y OOP</td>
<td>10</td>
<td>15 min</td>
</tr>
<tr>
<td>Estructuras de Datos BÃ¡sicas</td>
<td>15</td>
<td>25 min</td>
</tr>
<tr>
<td>Trees y Graphs</td>
<td>15</td>
<td>30 min</td>
</tr>
<tr>
<td>Algoritmos y DP</td>
<td>20</td>
<td>40 min</td>
</tr>
<tr>
<td>MatemÃ¡ticas y Big O</td>
<td>20</td>
<td>30 min</td>
</tr>
</tbody>
</table>
<p><strong>Total:</strong> 80 preguntas, ~140 minutos</p>
<hr />
<h2>SecciÃ³n 1: Python y OOP</h2>
<h3>P1: Â¿QuÃ© son los type hints y por quÃ© usarlos?</h3>
<p><strong>R:</strong> Anotaciones que indican tipos esperados. Beneficios: documentaciÃ³n viva, detecciÃ³n de errores con mypy, mejor autocompletado.</p>
<pre><code class="language-python">def greet(name: str) -&gt; str:
    return f&quot;Hello, {name}&quot;
</code></pre>
<h3>P2: Â¿CuÃ¡l es la diferencia entre <code>list</code> y <code>tuple</code>?</h3>
<p><strong>R:</strong> <br />
- <code>list</code>: mutable, se puede modificar<br />
- <code>tuple</code>: inmutable, no se puede cambiar despuÃ©s de crear<br />
- <code>tuple</code> es hashable (puede ser clave de dict), <code>list</code> no</p>
<h3>P3: Â¿QuÃ© significa que Python sea "pass by object reference"?</h3>
<p><strong>R:</strong> Se pasa referencia al objeto. Si el objeto es mutable, cambios dentro de la funciÃ³n afectan al original. Si es inmutable, se crea nuevo objeto.</p>
<h3>P4: Â¿Para quÃ© sirve <code>__init__</code>?</h3>
<p><strong>R:</strong> Inicializar atributos de instancia cuando se crea un objeto. Es el constructor de la clase.</p>
<h3>P5: Â¿CuÃ¡l es la diferencia entre <code>__str__</code> y <code>__repr__</code>?</h3>
<p><strong>R:</strong> <br />
- <code>__str__</code>: para usuarios, legible<br />
- <code>__repr__</code>: para desarrolladores, sin ambigÃ¼edad, idealmente eval-able</p>
<h3>P6: Â¿QuÃ© es un property en Python?</h3>
<p><strong>R:</strong> Mecanismo para controlar acceso a atributos con getter/setter, manteniendo sintaxis de atributo.</p>
<h3>P7: Â¿QuÃ© significa "composiciÃ³n sobre herencia"?</h3>
<p><strong>R:</strong> Preferir contener objetos de otra clase (has-a) sobre heredar (is-a). MÃ¡s flexible y menos acoplado.</p>
<h3>P8: Â¿QuÃ© es una funciÃ³n pura?</h3>
<p><strong>R:</strong> FunciÃ³n que siempre retorna mismo output para mismo input y no tiene efectos secundarios.</p>
<h3>P9: Â¿Para quÃ© sirve <code>@dataclass</code>?</h3>
<p><strong>R:</strong> Genera automÃ¡ticamente <code>__init__</code>, <code>__repr__</code>, <code>__eq__</code> para clases que principalmente almacenan datos.</p>
<h3>P10: Â¿CÃ³mo harÃ­as una clase inmutable?</h3>
<p><strong>R:</strong> Usar <code>@dataclass(frozen=True)</code> o definir <code>__setattr__</code> para prevenir modificaciones.</p>
<hr />
<h2>SecciÃ³n 2: Estructuras de Datos BÃ¡sicas</h2>
<h3>P11: Â¿CuÃ¡l es la complejidad de buscar en una lista vs en un set?</h3>
<p><strong>R:</strong> Lista: O(n), Set: O(1) promedio. Set usa hashing.</p>
<h3>P12: Â¿CÃ³mo funciona internamente un diccionario?</h3>
<p><strong>R:</strong> Hash table. La clave se hashea para determinar posiciÃ³n en array interno. Colisiones se resuelven con probing.</p>
<h3>P13: Â¿Por quÃ© <code>dict</code> es O(1) para acceso?</h3>
<p><strong>R:</strong> Hash de la clave da posiciÃ³n directa. No necesita buscar secuencialmente.</p>
<h3>P14: Â¿QuÃ© es una colisiÃ³n en hash table?</h3>
<p><strong>R:</strong> Cuando dos claves diferentes producen el mismo hash. Se resuelve buscando siguiente slot disponible.</p>
<h3>P15: Â¿QuÃ© puede ser clave de diccionario?</h3>
<p><strong>R:</strong> Solo objetos hashables (inmutables): str, int, float, tuple, frozenset. No: list, set, dict.</p>
<h3>P16: Â¿CuÃ¡l es la diferencia entre <code>set</code> y <code>frozenset</code>?</h3>
<p><strong>R:</strong> <code>set</code> es mutable, <code>frozenset</code> inmutable. frozenset puede ser clave de dict o elemento de otro set.</p>
<h3>P17: Â¿QuÃ© es un Ã­ndice invertido?</h3>
<p><strong>R:</strong> Estructura que mapea tÃ©rminos a documentos que los contienen. <code>{"word": [doc1, doc2, ...]}</code>. Base de motores de bÃºsqueda.</p>
<h3>P18: Â¿Por quÃ© usarÃ­as un set para stop words?</h3>
<p><strong>R:</strong> BÃºsqueda O(1). Si son 50 stop words y 1000 tokens, con lista serÃ­a O(50Ã—1000)=O(50000), con set O(1000).</p>
<h3>P19: Â¿CuÃ¡l es la complejidad de <code>list.append()</code> vs <code>list.insert(0, x)</code>?</h3>
<p><strong>R:</strong> <br />
- append: O(1) amortizado<br />
- insert(0): O(n) porque mueve todos los elementos</p>
<h3>P20: Â¿QuÃ© estructura usarÃ­as para un contador de frecuencias?</h3>
<p><strong>R:</strong> <code>dict</code> o <code>collections.Counter</code>. Mapea elemento a conteo, acceso O(1).</p>
<h3>P21: Â¿CÃ³mo implementarÃ­as bÃºsqueda AND con sets?</h3>
<p><strong>R:</strong> IntersecciÃ³n: <code>set1 &amp; set2</code>. Retorna elementos en ambos.</p>
<h3>P22: Â¿CÃ³mo implementarÃ­as bÃºsqueda OR con sets?</h3>
<p><strong>R:</strong> UniÃ³n: <code>set1 | set2</code>. Retorna elementos en cualquiera.</p>
<h3>P23: Â¿QuÃ© es Document Frequency?</h3>
<p><strong>R:</strong> NÃºmero de documentos que contienen un tÃ©rmino. Usado para calcular IDF.</p>
<h3>P24: Â¿CuÃ¡ndo usarÃ­as <code>defaultdict</code>?</h3>
<p><strong>R:</strong> Cuando quieres valores por defecto automÃ¡ticos. Ej: <code>defaultdict(list)</code> crea listas vacÃ­as para claves nuevas.</p>
<h3>P25: Â¿QuÃ© es un posting list?</h3>
<p><strong>R:</strong> Lista de documentos que contienen un tÃ©rmino, almacenada en Ã­ndice invertido.</p>
<hr />
<h2>SecciÃ³n 3: Trees y Graphs â­ CRÃTICO PATHWAY</h2>
<h3>P26: Â¿QuÃ© es un Binary Tree?</h3>
<p><strong>R:</strong> Ãrbol donde cada nodo tiene mÃ¡ximo 2 hijos (left y right).</p>
<h3>P27: Â¿CuÃ¡l es la diferencia entre Binary Tree y BST?</h3>
<p><strong>R:</strong> <br />
- Binary Tree: cualquier Ã¡rbol con mÃ¡x 2 hijos<br />
- BST: Binary tree donde left &lt; root &lt; right</p>
<h3>P28: Â¿CuÃ¡les son los tres traversals DFS de un Ã¡rbol?</h3>
<p><strong>R:</strong> <br />
- Inorder: Left, Root, Right (en BST da orden ascendente)<br />
- Preorder: Root, Left, Right<br />
- Postorder: Left, Right, Root</p>
<h3>P29: Â¿CÃ³mo implementarÃ­as level-order traversal?</h3>
<p><strong>R:</strong> Usar Queue (BFS). Agregar root, luego procesar nivel por nivel.</p>
<h3>P30: Â¿CuÃ¡l es la complejidad de search en BST?</h3>
<p><strong>R:</strong> O(log n) promedio, O(n) peor caso (Ã¡rbol desbalanceado/lineal).</p>
<h3>P31: Â¿QuÃ© es un grafo dirigido vs no dirigido?</h3>
<p><strong>R:</strong> <br />
- Dirigido: edges tienen direcciÃ³n (Aâ†’B no implica Bâ†’A)<br />
- No dirigido: conexiÃ³n bidireccional (Aâ†”B)</p>
<h3>P32: Â¿CuÃ¡les son las dos formas de representar un grafo?</h3>
<p><strong>R:</strong> <br />
- Adjacency List: dict de listas, O(V+E) espacio<br />
- Adjacency Matrix: matriz VÃ—V, O(VÂ²) espacio</p>
<h3>P33: Â¿CuÃ¡l es la diferencia entre BFS y DFS?</h3>
<p><strong>R:</strong> <br />
- BFS: explora por niveles, usa Queue, encuentra shortest path<br />
- DFS: explora en profundidad, usa Stack/recursiÃ³n</p>
<h3>P34: Â¿CuÃ¡ndo usar BFS vs DFS?</h3>
<p><strong>R:</strong> <br />
- BFS: shortest path (no ponderado), nivel por nivel<br />
- DFS: detectar ciclos, caminos, backtracking</p>
<h3>P35: Â¿CÃ³mo detectar un ciclo en un grafo?</h3>
<p><strong>R:</strong> DFS marcando nodos como "en progreso" y "visitado". Si encuentras nodo "en progreso", hay ciclo.</p>
<h3>P36: Â¿QuÃ© es un DAG?</h3>
<p><strong>R:</strong> Directed Acyclic Graph. Grafo dirigido sin ciclos. Permite topological sort.</p>
<h3>P37: Â¿CuÃ¡l es la complejidad de BFS/DFS?</h3>
<p><strong>R:</strong> O(V + E) donde V = vÃ©rtices, E = edges.</p>
<h3>P38: Â¿QuÃ© estructura usa BFS y cuÃ¡l DFS?</h3>
<p><strong>R:</strong> <br />
- BFS: Queue (FIFO)<br />
- DFS: Stack (LIFO) o recursiÃ³n</p>
<h3>P39: Â¿Por quÃ© BFS garantiza shortest path en grafos no ponderados?</h3>
<p><strong>R:</strong> Porque explora todos los nodos a distancia k antes de los de distancia k+1.</p>
<h3>P40: Â¿CÃ³mo encontrarÃ­as camino mÃ¡s corto en grafo ponderado?</h3>
<p><strong>R:</strong> Dijkstra's algorithm (no cubierto en detalle, pero saber que existe).</p>
<hr />
<h2>SecciÃ³n 4: Algoritmos y DP â­ CRÃTICO PATHWAY</h2>
<h3>P41: Explica cÃ³mo funciona QuickSort.</h3>
<p><strong>R:</strong> <br />
1. Elegir pivote<br />
2. Particionar: menores a izquierda, mayores a derecha<br />
3. Recursivamente ordenar cada particiÃ³n<br />
Complejidad: O(n log n) promedio, O(nÂ²) peor caso.</p>
<h3>P42: Â¿Por quÃ© QuickSort puede ser O(nÂ²)?</h3>
<p><strong>R:</strong> Si el pivote siempre es el mÃ­nimo o mÃ¡ximo. Ej: lista ya ordenada con pivote fijo al final. Cada particiÃ³n solo reduce en 1.</p>
<h3>P28: Â¿CÃ³mo evitar el peor caso de QuickSort?</h3>
<p><strong>R:</strong> Random pivot selection. Aleatoriza la elecciÃ³n del pivote.</p>
<h3>P29: Explica MergeSort.</h3>
<p><strong>R:</strong><br />
1. Dividir lista en dos mitades<br />
2. Ordenar cada mitad recursivamente<br />
3. Fusionar las mitades ordenadas<br />
Complejidad: O(n log n) siempre.</p>
<h3>P30: Â¿CuÃ¡l es la diferencia entre QuickSort y MergeSort?</h3>
<p><strong>R:</strong><br />
- QuickSort: in-place, O(log n) espacio, no estable<br />
- MergeSort: O(n) espacio, estable, siempre O(n log n)</p>
<h3>P31: Â¿QuÃ© significa que un sort sea "estable"?</h3>
<p><strong>R:</strong> Elementos iguales mantienen su orden relativo original.</p>
<h3>P32: Explica Binary Search.</h3>
<p><strong>R:</strong> En lista ordenada, comparar con elemento medio. Si menor, buscar en mitad izquierda; si mayor, en derecha. Complejidad: O(log n).</p>
<h3>P33: Â¿CuÃ¡l es el error off-by-one mÃ¡s comÃºn en binary search?</h3>
<p><strong>R:</strong> Usar <code>while left &lt; right</code> en lugar de <code>left &lt;= right</code>, o no ajustar correctamente mid+1/mid-1.</p>
<h3>P34: Â¿QuÃ© es recursiÃ³n?</h3>
<p><strong>R:</strong> FunciÃ³n que se llama a sÃ­ misma. Requiere caso base (termina) y caso recursivo (se llama con input menor).</p>
<h3>P35: Â¿QuÃ© es el call stack?</h3>
<p><strong>R:</strong> Pila que guarda estado de cada llamada a funciÃ³n. Cada llamada recursiva agrega un frame.</p>
<h3>P36: Â¿QuÃ© es memoization?</h3>
<p><strong>R:</strong> Cachear resultados de funciones para evitar recÃ¡lculo. Ãštil en recursiÃ³n con subproblemas repetidos.</p>
<h3>P37: Â¿Por quÃ© Fibonacci naive es O(2^n)?</h3>
<p><strong>R:</strong> Cada llamada hace dos llamadas. Ãrbol de llamadas crece exponencialmente. fib(n) se recalcula muchas veces.</p>
<h3>P38: Â¿CÃ³mo optimizar Fibonacci a O(n)?</h3>
<p><strong>R:</strong> Memoization: guardar resultados en dict/cache. Cada valor se calcula solo una vez.</p>
<h3>P39: Â¿QuÃ© es Divide &amp; Conquer?</h3>
<p><strong>R:</strong> PatrÃ³n que divide problema en subproblemas, resuelve cada uno, y combina soluciones. Ej: MergeSort, QuickSort.</p>
<h3>P43: Â¿CÃ³mo fusionarÃ­as dos listas ordenadas?</h3>
<p><strong>R:</strong> Two pointers: comparar elementos actuales de ambas, agregar el menor al resultado, avanzar ese puntero. O(n+m).</p>
<h3>P44: Â¿QuÃ© es Dynamic Programming?</h3>
<p><strong>R:</strong> TÃ©cnica que guarda resultados de subproblemas para evitar recÃ¡lculo. Requiere optimal substructure + overlapping subproblems.</p>
<h3>P45: Â¿CuÃ¡les son los dos enfoques de DP?</h3>
<p><strong>R:</strong> <br />
- Top-down: Recursivo con memoization<br />
- Bottom-up: Iterativo con tabulation</p>
<h3>P46: Â¿QuÃ© es la recurrencia de Coin Change?</h3>
<p><strong>R:</strong> dp[amount] = min(dp[amount - coin] + 1) para todas las monedas vÃ¡lidas.</p>
<h3>P47: Â¿CuÃ¡ndo usar Greedy vs DP?</h3>
<p><strong>R:</strong> <br />
- Greedy: Si la mejor opciÃ³n local lleva al Ã³ptimo global<br />
- DP: Si necesitas explorar todas las opciones</p>
<h3>P48: Â¿QuÃ© es "greedy choice property"?</h3>
<p><strong>R:</strong> Propiedad donde elegir el Ã³ptimo local en cada paso lleva al Ã³ptimo global.</p>
<h3>P49: Â¿CÃ³mo funciona Activity Selection greedy?</h3>
<p><strong>R:</strong> Ordenar por tiempo de fin, siempre elegir la que termina primero y no se superpone.</p>
<h3>P50: Â¿QuÃ© es un Heap?</h3>
<p><strong>R:</strong> Ãrbol binario completo con propiedad heap (parent &lt;= children para min-heap).</p>
<h3>P51: Â¿CuÃ¡les son las complejidades de operaciones en Heap?</h3>
<p><strong>R:</strong> Insert: O(log n), Extract-min: O(log n), Peek: O(1), Heapify: O(n).</p>
<h3>P52: Â¿CÃ³mo encontrar los K elementos mÃ¡s grandes?</h3>
<p><strong>R:</strong> Usar min-heap de tamaÃ±o k. Para cada elemento, si es mayor que el mÃ­nimo del heap, reemplazar.</p>
<h3>P53: Â¿Por quÃ© usar min-heap para K largest?</h3>
<p><strong>R:</strong> Min-heap mantiene el k-Ã©simo mÃ¡s grande en la raÃ­z. Elementos mÃ¡s grandes que la raÃ­z entran al heap.</p>
<h3>P54: Â¿QuÃ© es Priority Queue?</h3>
<p><strong>R:</strong> Cola donde elementos salen por prioridad, no por orden de llegada. Se implementa con Heap.</p>
<h3>P55: Â¿CÃ³mo hacer max-heap en Python?</h3>
<p><strong>R:</strong> heapq es min-heap. Para max-heap, negar los valores al insertar y al extraer.</p>
<hr />
<h2>SecciÃ³n 5: MatemÃ¡ticas y Big O</h2>
<h3>P56: Â¿QuÃ© significa O(n)?</h3>
<p><strong>R:</strong> El tiempo crece linealmente con el tamaÃ±o de entrada. Duplicar n duplica el tiempo.</p>
<h3>P57: Ordena de menor a mayor: O(nÂ²), O(1), O(n log n), O(log n), O(n)</h3>
<p><strong>R:</strong> O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(nÂ²)</p>
<h3>P58: Â¿CuÃ¡ntas comparaciones hace binary search en 1 millÃ³n de elementos?</h3>
<p><strong>R:</strong> logâ‚‚(1,000,000) â‰ˆ 20 comparaciones.</p>
<h3>P59: Â¿QuÃ© es el producto punto?</h3>
<p><strong>R:</strong> Suma de productos de componentes correspondientes: aÂ·b = aâ‚bâ‚ + aâ‚‚bâ‚‚ + ... Resultado es escalar.</p>
<h3>P45: Â¿QuÃ© es la norma de un vector?</h3>
<p><strong>R:</strong> Su longitud/magnitud. ||v|| = âˆš(vâ‚Â² + vâ‚‚Â² + ...). Distancia del origen al punto.</p>
<h3>P46: Â¿QuÃ© mide la similitud de coseno?</h3>
<p><strong>R:</strong> El coseno del Ã¡ngulo entre vectores. 1 = misma direcciÃ³n, 0 = perpendiculares. Mide similitud ignorando magnitud.</p>
<h3>P47: Â¿QuÃ© es TF (Term Frequency)?</h3>
<p><strong>R:</strong> Frecuencia de un tÃ©rmino en un documento, normalizada por longitud. TF = count/total_terms.</p>
<h3>P48: Â¿QuÃ© es IDF (Inverse Document Frequency)?</h3>
<p><strong>R:</strong> Mide quÃ© tan raro es un tÃ©rmino. IDF = log(N/df). TÃ©rminos raros tienen IDF alto.</p>
<h3>P49: Â¿Por quÃ© usamos TF-IDF en lugar de solo TF?</h3>
<p><strong>R:</strong> TF solo mide frecuencia local. IDF penaliza palabras comunes ("the", "is"). TF-IDF balancea ambos.</p>
<h3>P50: Â¿CuÃ¡l es la complejidad de calcular similitud de coseno?</h3>
<p><strong>R:</strong> O(V) donde V es la dimensiÃ³n del vector (tamaÃ±o del vocabulario). Hay que recorrer todos los componentes.</p>
<hr />
<h2>ğŸ¯ AutoevaluaciÃ³n</h2>
<table>
<thead>
<tr>
<th>Respuestas Correctas</th>
<th>Nivel</th>
</tr>
</thead>
<tbody>
<tr>
<td>65-80</td>
<td>ğŸ† Listo para Pathway</td>
</tr>
<tr>
<td>50-64</td>
<td>âœ… Buen nivel, reforzar gaps</td>
</tr>
<tr>
<td>35-49</td>
<td>âš ï¸ Necesita mÃ¡s estudio</td>
</tr>
<tr>
<td>&lt;35</td>
<td>âŒ Revisar mÃ³dulos</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ’¡ Tips para la Entrevista Real</h2>
<ol>
<li><strong>Explica tu pensamiento:</strong> Verbaliza mientras resuelves</li>
<li><strong>Empieza simple:</strong> Primero soluciÃ³n bruta, luego optimiza</li>
<li><strong>Pregunta si dudas:</strong> Clarifica requisitos</li>
<li><strong>Analiza Big O:</strong> Siempre menciona complejidad</li>
<li><strong>Practica en inglÃ©s:</strong> Todo el Pathway es en inglÃ©s</li>
</ol>
        </section>
        
        <div id="mod_DECISIONES_TECH" class="cover-page">
            <a name="mod_DECISIONES_TECH"></a>
            <div class="cover-title">Decisiones TÃ©cnicas</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>ğŸ”§ Decisiones TÃ©cnicas (ADRs)</h1>
<blockquote>
<p>Architecture Decision Records para el proyecto Archimedes Indexer.</p>
</blockquote>
<hr />
<h2>Ãndice de Decisiones</h2>
<table>
<thead>
<tr>
<th>#</th>
<th>DecisiÃ³n</th>
<th>Estado</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Python puro sin librerÃ­as</td>
<td>âœ… Aceptada</td>
</tr>
<tr>
<td>2</td>
<td>VersiÃ³n de Python 3.11+</td>
<td>âœ… Aceptada</td>
</tr>
<tr>
<td>3</td>
<td>Estructura src/ layout</td>
<td>âœ… Aceptada</td>
</tr>
<tr>
<td>4</td>
<td>Set vs List para posting lists</td>
<td>âœ… Aceptada</td>
</tr>
<tr>
<td>5</td>
<td>QuickSort con random pivot</td>
<td>âœ… Aceptada</td>
</tr>
<tr>
<td>6</td>
<td>TF-IDF normalizado</td>
<td>âœ… Aceptada</td>
</tr>
<tr>
<td>7</td>
<td>pytest para testing</td>
<td>âœ… Aceptada</td>
</tr>
<tr>
<td>8</td>
<td>ruff para linting</td>
<td>âœ… Aceptada</td>
</tr>
</tbody>
</table>
<hr />
<h2>ADR-001: Python Puro sin LibrerÃ­as</h2>
<h3>Contexto</h3>
<p>El objetivo del proyecto es aprender fundamentos de CS, no usar herramientas.</p>
<h3>DecisiÃ³n</h3>
<p><strong>Prohibir</strong> numpy, pandas, sklearn, y cualquier librerÃ­a de ML/data science.</p>
<h3>Consecuencias</h3>
<ul>
<li>âœ… Fuerza entendimiento profundo de algoritmos</li>
<li>âœ… CÃ³digo mÃ¡s simple de debuggear</li>
<li>âœ… Demuestra habilidad, no uso de herramientas</li>
<li>âŒ Menos eficiente que librerÃ­as optimizadas</li>
<li>âŒ MÃ¡s cÃ³digo para escribir</li>
</ul>
<hr />
<h2>ADR-002: Python 3.11+</h2>
<h3>Contexto</h3>
<p>Necesitamos decidir versiÃ³n mÃ­nima de Python.</p>
<h3>DecisiÃ³n</h3>
<p>Usar <strong>Python 3.11</strong> como mÃ­nimo.</p>
<h3>JustificaciÃ³n</h3>
<ul>
<li>Sintaxis <code>list[str]</code> sin <code>from __future__ import annotations</code></li>
<li>Union types con <code>|</code> (ej: <code>str | None</code>)</li>
<li>Mejor performance</li>
<li>Mensajes de error mÃ¡s claros</li>
</ul>
<h3>Consecuencias</h3>
<ul>
<li>âœ… CÃ³digo mÃ¡s limpio y moderno</li>
<li>âœ… Mejor experiencia de desarrollo</li>
<li>âŒ No compatible con Python 3.9/3.10</li>
</ul>
<hr />
<h2>ADR-003: Estructura src/ Layout</h2>
<h3>Contexto</h3>
<p>Hay dos layouts comunes: flat (mÃ³dulos en raÃ­z) y src/ (mÃ³dulos en carpeta src/).</p>
<h3>DecisiÃ³n</h3>
<p>Usar <strong>src/ layout</strong>:</p>
<pre><code>project/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ module.py
â””â”€â”€ tests/
</code></pre>
<h3>JustificaciÃ³n</h3>
<ul>
<li>Evita importar accidentalmente cÃ³digo no instalado</li>
<li>EstÃ¡ndar en proyectos profesionales</li>
<li>Compatible con empaquetado moderno</li>
</ul>
<hr />
<h2>ADR-004: Set vs List para Posting Lists</h2>
<h3>Contexto</h3>
<p>Posting lists mapean tÃ©rmino â†’ documentos. Â¿Usar list o set?</p>
<h3>DecisiÃ³n</h3>
<p>Usar <strong>set[int]</strong> para doc_ids.</p>
<h3>JustificaciÃ³n</h3>
<ul>
<li>O(1) para verificar si documento contiene tÃ©rmino</li>
<li>IntersecciÃ³n/uniÃ³n nativas para AND/OR</li>
<li>No importa el orden en la mayorÃ­a de casos</li>
</ul>
<h3>Trade-offs</h3>
<ul>
<li>âœ… Operaciones de conjuntos eficientes</li>
<li>âŒ No mantiene orden de inserciÃ³n</li>
<li>âŒ Necesita convertir a list para ordenar por score</li>
</ul>
<hr />
<h2>ADR-005: QuickSort con Random Pivot</h2>
<h3>Contexto</h3>
<p>QuickSort puede ser O(nÂ²) con pivot malo.</p>
<h3>DecisiÃ³n</h3>
<p>Usar <strong>random pivot selection</strong>.</p>
<h3>JustificaciÃ³n</h3>
<ul>
<li>Evita peor caso en datos ya ordenados</li>
<li>O(n log n) esperado</li>
<li>FÃ¡cil de implementar</li>
</ul>
<h3>Alternativas Consideradas</h3>
<ul>
<li>Pivot fijo (primero/Ãºltimo): Rechazado, vulnerable a datos ordenados</li>
<li>Median of three: VÃ¡lido pero mÃ¡s complejo</li>
<li>Cambiar a MergeSort: Usa mÃ¡s memoria</li>
</ul>
<hr />
<h2>ADR-006: TF-IDF Normalizado</h2>
<h3>Contexto</h3>
<p>Hay variantes de TF-IDF. Â¿CuÃ¡l usar?</p>
<h3>DecisiÃ³n</h3>
<p>Usar fÃ³rmula estÃ¡ndar:<br />
- TF = count(term, doc) / total_terms(doc)<br />
- IDF = log(N / df(term))<br />
- TF-IDF = TF Ã— IDF</p>
<h3>JustificaciÃ³n</h3>
<ul>
<li>FÃ¡cil de entender y explicar</li>
<li>Documentos largos no dominan</li>
<li>Consistente con literatura</li>
</ul>
<hr />
<h2>ADR-007: pytest para Testing</h2>
<h3>Contexto</h3>
<p>Python tiene varias opciones de testing: unittest, pytest, nose.</p>
<h3>DecisiÃ³n</h3>
<p>Usar <strong>pytest</strong>.</p>
<h3>JustificaciÃ³n</h3>
<ul>
<li>Sintaxis mÃ¡s simple (assert nativo)</li>
<li>Fixtures potentes</li>
<li>Mejor output de errores</li>
<li>pytest-cov para coverage</li>
</ul>
<h3>Ejemplo</h3>
<pre><code class="language-python"># pytest style (simple)
def test_tokenize():
    assert tokenize(&quot;Hello&quot;) == [&quot;hello&quot;]

# unittest style (verbose)
class TestTokenize(unittest.TestCase):
    def test_tokenize(self):
        self.assertEqual(tokenize(&quot;Hello&quot;), [&quot;hello&quot;])
</code></pre>
<hr />
<h2>ADR-008: ruff para Linting</h2>
<h3>Contexto</h3>
<p>Opciones de linting: flake8, pylint, ruff.</p>
<h3>DecisiÃ³n</h3>
<p>Usar <strong>ruff</strong>.</p>
<h3>JustificaciÃ³n</h3>
<ul>
<li>10-100x mÃ¡s rÃ¡pido que alternativas</li>
<li>Combina mÃºltiples herramientas (flake8, isort, pyupgrade)</li>
<li>CorrecciÃ³n automÃ¡tica (<code>--fix</code>)</li>
<li>Desarrollo activo</li>
</ul>
<h3>ConfiguraciÃ³n</h3>
<pre><code class="language-toml">[tool.ruff]
line-length = 88
select = [&quot;E&quot;, &quot;F&quot;, &quot;W&quot;, &quot;I&quot;, &quot;N&quot;, &quot;UP&quot;]
</code></pre>
<hr />
<h2>Matriz de Decisiones</h2>
<table>
<thead>
<tr>
<th>Ãrea</th>
<th>Herramienta/Enfoque</th>
<th>Por QuÃ©</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lenguaje</td>
<td>Python 3.11+</td>
<td>Sintaxis moderna</td>
</tr>
<tr>
<td>LibrerÃ­as</td>
<td>Ninguna (solo stdlib)</td>
<td>Aprendizaje</td>
</tr>
<tr>
<td>Layout</td>
<td>src/</td>
<td>Profesional</td>
</tr>
<tr>
<td>Posting Lists</td>
<td>set</td>
<td>O(1) lookup</td>
</tr>
<tr>
<td>Sorting</td>
<td>QuickSort random</td>
<td>O(n log n) esperado</td>
</tr>
<tr>
<td>TF-IDF</td>
<td>Normalizado</td>
<td>EstÃ¡ndar</td>
</tr>
<tr>
<td>Testing</td>
<td>pytest</td>
<td>Simple, potente</td>
</tr>
<tr>
<td>Linting</td>
<td>ruff</td>
<td>RÃ¡pido, moderno</td>
</tr>
<tr>
<td>Type checking</td>
<td>mypy</td>
<td>EstÃ¡ndar</td>
</tr>
</tbody>
</table>
        </section>
        
        <div id="mod_RUBRICA_EVALUACION" class="cover-page">
            <a name="mod_RUBRICA_EVALUACION"></a>
            <div class="cover-title">RÃºbrica de EvaluaciÃ³n</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>ğŸ“Š RÃºbrica de EvaluaciÃ³n</h1>
<blockquote>
<p>Criterios para evaluar el proyecto Archimedes Indexer.</p>
</blockquote>
<hr />
<h2>Escala de PuntuaciÃ³n</h2>
<table>
<thead>
<tr>
<th>PuntuaciÃ³n</th>
<th>Nivel</th>
<th>Significado</th>
</tr>
</thead>
<tbody>
<tr>
<td>90-100</td>
<td>ğŸ† Excelente</td>
<td>Listo para Pathway y entrevistas</td>
</tr>
<tr>
<td>75-89</td>
<td>âœ… Bueno</td>
<td>Reforzar Ã¡reas dÃ©biles</td>
</tr>
<tr>
<td>60-74</td>
<td>âš ï¸ Suficiente</td>
<td>MÃ¡s prÃ¡ctica antes de Pathway</td>
</tr>
<tr>
<td>&lt;60</td>
<td>âŒ Insuficiente</td>
<td>Revisar mÃ³dulos fundamentales</td>
</tr>
</tbody>
</table>
<hr />
<h2>Desglose por CategorÃ­a (100 puntos)</h2>
<h3>1. Funcionalidad (30 pts)</h3>
<table>
<thead>
<tr>
<th>Criterio</th>
<th>Pts</th>
<th>DescripciÃ³n</th>
</tr>
</thead>
<tbody>
<tr>
<td>Motor funcional</td>
<td>10</td>
<td>Indexa documentos y retorna resultados</td>
</tr>
<tr>
<td>Ranking correcto</td>
<td>10</td>
<td>Resultados ordenados por relevancia</td>
</tr>
<tr>
<td>BÃºsqueda AND/OR</td>
<td>5</td>
<td>Soporta ambos tipos de consulta</td>
</tr>
<tr>
<td>Edge cases</td>
<td>5</td>
<td>Maneja queries vacÃ­as, docs vacÃ­os, etc.</td>
</tr>
</tbody>
</table>
<h3>2. Calidad de CÃ³digo (25 pts)</h3>
<table>
<thead>
<tr>
<th>Criterio</th>
<th>Pts</th>
<th>DescripciÃ³n</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type hints</td>
<td>5</td>
<td>Todos los parÃ¡metros y retornos tipados</td>
</tr>
<tr>
<td>Docstrings</td>
<td>5</td>
<td>Todas las funciones pÃºblicas documentadas</td>
</tr>
<tr>
<td>PEP8</td>
<td>5</td>
<td>CÃ³digo pasa linters sin warnings</td>
</tr>
<tr>
<td>Estructura</td>
<td>5</td>
<td>MÃ³dulos separados, imports limpios</td>
</tr>
<tr>
<td>SOLID bÃ¡sico</td>
<td>5</td>
<td>Cada clase una responsabilidad</td>
</tr>
</tbody>
</table>
<h3>3. Testing (20 pts)</h3>
<table>
<thead>
<tr>
<th>Criterio</th>
<th>Pts</th>
<th>DescripciÃ³n</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tests unitarios</td>
<td>8</td>
<td>Tests para cada mÃ³dulo</td>
</tr>
<tr>
<td>Tests integraciÃ³n</td>
<td>4</td>
<td>Test del flujo completo</td>
</tr>
<tr>
<td>Coverage &gt; 80%</td>
<td>4</td>
<td>Cobertura de cÃ³digo</td>
</tr>
<tr>
<td>Edge cases testeados</td>
<td>4</td>
<td>Casos lÃ­mite cubiertos</td>
</tr>
</tbody>
</table>
<h3>4. AnÃ¡lisis Big O (15 pts)</h3>
<table>
<thead>
<tr>
<th>Criterio</th>
<th>Pts</th>
<th>DescripciÃ³n</th>
</tr>
</thead>
<tbody>
<tr>
<td>Documento completo</td>
<td>5</td>
<td>AnÃ¡lisis de todas las operaciones</td>
</tr>
<tr>
<td>Correctitud</td>
<td>5</td>
<td>AnÃ¡lisis matemÃ¡ticamente correcto</td>
</tr>
<tr>
<td>JustificaciÃ³n</td>
<td>5</td>
<td>Explica el razonamiento</td>
</tr>
</tbody>
</table>
<h3>5. DocumentaciÃ³n (10 pts)</h3>
<table>
<thead>
<tr>
<th>Criterio</th>
<th>Pts</th>
<th>DescripciÃ³n</th>
</tr>
</thead>
<tbody>
<tr>
<td>README.md</td>
<td>5</td>
<td>Profesional, en inglÃ©s, con ejemplos</td>
</tr>
<tr>
<td>Instrucciones uso</td>
<td>3</td>
<td>CÃ³mo instalar y ejecutar</td>
</tr>
<tr>
<td>Demo/ejemplo</td>
<td>2</td>
<td>CÃ³digo de ejemplo funcional</td>
</tr>
</tbody>
</table>
<hr />
<h2>Checklist RÃ¡pido</h2>
<h3>âœ… Funcionalidad</h3>
<ul>
<li>[ ] <code>SearchEngine.add_document()</code> funciona</li>
<li>[ ] <code>SearchEngine.build_index()</code> funciona</li>
<li>[ ] <code>SearchEngine.search()</code> retorna resultados ordenados</li>
<li>[ ] Resultados tienen score entre 0 y 1</li>
</ul>
<h3>âœ… CÃ³digo</h3>
<ul>
<li>[ ] <code>mypy src/</code> pasa sin errores</li>
<li>[ ] <code>ruff check src/</code> pasa sin errores</li>
<li>[ ] Todas las funciones tienen docstrings</li>
<li>[ ] No hay cÃ³digo duplicado</li>
</ul>
<h3>âœ… Tests</h3>
<ul>
<li>[ ] <code>pytest tests/</code> pasa</li>
<li>[ ] Coverage &gt; 80%</li>
<li>[ ] Tests para cada mÃ³dulo</li>
</ul>
<h3>âœ… DocumentaciÃ³n</h3>
<ul>
<li>[ ] README.md existe y estÃ¡ completo</li>
<li>[ ] COMPLEXITY_ANALYSIS.md existe</li>
<li>[ ] Ejemplos de uso incluidos</li>
</ul>
<hr />
<h2>Ejemplos de EvaluaciÃ³n</h2>
<h3>Ejemplo: AnÃ¡lisis Big O (15/15 pts)</h3>
<pre><code class="language-markdown"># COMPLEXITY_ANALYSIS.md

## add_document(doc_id, tokens)
- Complejidad: O(t) donde t = len(tokens)
- JustificaciÃ³n: Iteramos una vez sobre los tokens para agregarlos al Ã­ndice.
  Cada operaciÃ³n de agregar al set es O(1) amortizado.

## search(query)
- Complejidad: O(q + V + N Ã— V + N log N)
  - O(q): Tokenizar query
  - O(V): Crear vector query (V = vocabulario)
  - O(N Ã— V): Calcular similitud con cada documento
  - O(N log N): Ordenar resultados
- Simplificado: O(N Ã— V) domina para corpus grandes

## quicksort(items)
- Promedio: O(n log n)
- Peor caso: O(nÂ²) cuando el pivote es siempre el mÃ­nimo/mÃ¡ximo
- Espacio: O(log n) para el call stack
</code></pre>
<h3>Ejemplo: Test Unitario Bien Escrito</h3>
<pre><code class="language-python"># test_similarity.py
import pytest
from src.similarity import cosine_similarity

class TestCosineSimilarity:
    def test_identical_vectors(self):
        &quot;&quot;&quot;Identical vectors should have similarity 1.0.&quot;&quot;&quot;
        v = [1.0, 2.0, 3.0]
        assert cosine_similarity(v, v) == pytest.approx(1.0)

    def test_orthogonal_vectors(self):
        &quot;&quot;&quot;Orthogonal vectors should have similarity 0.0.&quot;&quot;&quot;
        v1 = [1.0, 0.0]
        v2 = [0.0, 1.0]
        assert cosine_similarity(v1, v2) == pytest.approx(0.0)

    def test_zero_vector(self):
        &quot;&quot;&quot;Zero vector should return 0.0 similarity.&quot;&quot;&quot;
        v1 = [0.0, 0.0]
        v2 = [1.0, 1.0]
        assert cosine_similarity(v1, v2) == 0.0
</code></pre>
<hr />
<h2>Comando de VerificaciÃ³n Final</h2>
<pre><code class="language-bash"># Verificar todo antes de entregar
mypy src/
ruff check src/
pytest tests/ -v --cov=src --cov-report=term-missing
</code></pre>
<p><strong>Objetivo:</strong> Todos los comandos deben pasar sin errores.</p>
        </section>
        
        <div id="mod_REFERENCIAS_CRUZADAS" class="cover-page">
            <a name="mod_REFERENCIAS_CRUZADAS"></a>
            <div class="cover-title">Referencias Cruzadas</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>ğŸ”— Mapa de Referencias Cruzadas</h1>
<blockquote>
<p>NavegaciÃ³n completa entre todos los documentos de la guÃ­a.</p>
</blockquote>
<hr />
<h2>ğŸ“Š Matriz de Dependencias de MÃ³dulos</h2>
<pre><code>ORDEN Ã“PTIMO DE ESTUDIO (Flujo de Dependencias):

01 Python Profesional
 â†“
02 OOP desde Cero
 â†“
03 LÃ³gica Discreta â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â†“                                        â”‚
04 Arrays y Strings                       â”‚ Fundamentos
 â†“                                        â”‚ de Big O
05 Hash Maps y Sets â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 â†“
06 Ãndice Invertido
 â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BLOQUE DSA AVANZADO (Pathway Critical)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 13 Linked Lists, Stacks, Queues          â”‚
â”‚  â†“                                       â”‚
â”‚ 14 Trees y BST                           â”‚
â”‚  â†“                                       â”‚
â”‚ 15 Graphs, BFS, DFS                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BLOQUE ALGORITMOS (Pathway Critical)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 07 RecursiÃ³n â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â†“                        â†“              â”‚
â”‚ 08 Sorting           16 Dynamic Prog     â”‚
â”‚  â†“                        â†“              â”‚
â”‚ 09 Binary Search     17 Greedy           â”‚
â”‚                           â†“              â”‚
â”‚                      18 Heaps            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 â†“
10 Ãlgebra Lineal
 â†“
11 TF-IDF y Coseno
 â†“
12 PROYECTO INTEGRADOR
</code></pre>
<hr />
<h2>ğŸ“– Referencias por MÃ³dulo</h2>
<h3>01_PYTHON_PROFESIONAL.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#type-hint</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#pep8</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_EJERCICIOS">EJERCICIOS.md#mÃ³dulo-01</a></td>
<td>Ejercicios</td>
</tr>
</tbody>
</table>
<h3>02_OOP_DESDE_CERO.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td>01_PYTHON_PROFESIONAL.md</td>
<td>Prerrequisito</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#clase</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#oop</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#solid</a></td>
<td>TÃ©rmino</td>
</tr>
</tbody>
</table>
<h3>03_LOGICA_DISCRETA.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#big-o-notation</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#set</a></td>
<td>TÃ©rmino</td>
</tr>
</tbody>
</table>
<h3>04_ARRAYS_STRINGS.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#array</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td>03_LOGICA_DISCRETA.md (Big O)</td>
<td>Prerrequisito</td>
</tr>
</tbody>
</table>
<h3>05_HASHMAPS_SETS.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#hash-map</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#colision</a></td>
<td>TÃ©rmino</td>
</tr>
</tbody>
</table>
<h3>06_INVERTED_INDEX.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td>05_HASHMAPS_SETS.md</td>
<td>Prerrequisito</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#indice-invertido</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td>12_PROYECTO_INTEGRADOR.md</td>
<td>Uso en proyecto</td>
</tr>
</tbody>
</table>
<h3>07_RECURSION.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#recursion</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#caso-base</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#memoization</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td>13_LINKED_LISTS.md (call stack)</td>
<td>Concepto relacionado</td>
</tr>
</tbody>
</table>
<h3>08_SORTING.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td>07_RECURSION.md</td>
<td>Prerrequisito</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#quicksort</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#divide-conquer</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td>12_PROYECTO_INTEGRADOR.md</td>
<td>Uso en proyecto</td>
</tr>
</tbody>
</table>
<h3>09_BINARY_SEARCH.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td>08_SORTING.md</td>
<td>Prerrequisito (datos ordenados)</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#binary-search</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#off-by-one</a></td>
<td>TÃ©rmino</td>
</tr>
</tbody>
</table>
<h3>10_ALGEBRA_LINEAL.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#vector</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#producto-punto</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#norma</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td>11_TFIDF_COSENO.md</td>
<td>Siguiente</td>
</tr>
</tbody>
</table>
<h3>11_TFIDF_COSENO.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td>10_ALGEBRA_LINEAL.md</td>
<td>Prerrequisito</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#tf</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#idf</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#cosine-similarity</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td>12_PROYECTO_INTEGRADOR.md</td>
<td>Uso en proyecto</td>
</tr>
</tbody>
</table>
<h3>12_PROYECTO_INTEGRADOR.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td>Todos los mÃ³dulos 01-11</td>
<td>Prerrequisitos</td>
</tr>
<tr>
<td>CHECKLIST.md</td>
<td>VerificaciÃ³n</td>
</tr>
<tr>
<td>RUBRICA_EVALUACION.md</td>
<td>EvaluaciÃ³n</td>
</tr>
</tbody>
</table>
<h3>13_LINKED_LISTS_STACKS_QUEUES.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#linked-list</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#stack</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#queue</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#lifo</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#fifo</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td>14_TREES.md</td>
<td>Siguiente</td>
</tr>
<tr>
<td>15_GRAPHS.md</td>
<td>Siguiente (Queue para BFS)</td>
</tr>
</tbody>
</table>
<h3>14_TREES.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td>13_LINKED_LISTS.md</td>
<td>Prerrequisito (nodos, punteros)</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#tree</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#bst</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#inorder</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td>15_GRAPHS.md</td>
<td>Siguiente</td>
</tr>
</tbody>
</table>
<h3>15_GRAPHS.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td>13_LINKED_LISTS.md (Queue, Stack)</td>
<td>Prerrequisito</td>
</tr>
<tr>
<td>14_TREES.md (conceptos de nodos)</td>
<td>Prerrequisito</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#graph</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#bfs</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#dfs</a></td>
<td>TÃ©rmino</td>
</tr>
</tbody>
</table>
<h3>16_DYNAMIC_PROGRAMMING.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td>07_RECURSION.md</td>
<td>Prerrequisito</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#dynamic-programming</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#memoization</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#tabulation</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#optimal-substructure</a></td>
<td>TÃ©rmino</td>
</tr>
</tbody>
</table>
<h3>17_GREEDY.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td>16_DYNAMIC_PROGRAMMING.md (comparaciÃ³n)</td>
<td>Relacionado</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#greedy</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td>18_HEAPS.md (Huffman usa heap)</td>
<td>Siguiente</td>
</tr>
</tbody>
</table>
<h3>18_HEAPS.md</h3>
<table>
<thead>
<tr>
<th>Referencia a</th>
<th>Tipo</th>
</tr>
</thead>
<tbody>
<tr>
<td>14_TREES.md (Ã¡rbol binario completo)</td>
<td>Prerrequisito</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#heap</a></td>
<td>TÃ©rmino</td>
</tr>
<tr>
<td><a href="#mod_GLOSARIO">GLOSARIO.md#priority-queue</a></td>
<td>TÃ©rmino</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ“š Referencias en Documentos Auxiliares</h2>
<h3>EJERCICIOS.md</h3>
<ul>
<li>Enlaza a cada mÃ³dulo para los ejercicios correspondientes</li>
<li>Enlaza a EJERCICIOS_SOLUCIONES.md para respuestas</li>
</ul>
<h3>EJERCICIOS_SOLUCIONES.md</h3>
<ul>
<li>Enlaza de vuelta a EJERCICIOS.md</li>
<li>Referencias a mÃ³dulos para contexto</li>
</ul>
<h3>GLOSARIO.md</h3>
<ul>
<li>Referenciado desde todos los mÃ³dulos</li>
<li>Organizado A-Z con siglas al final</li>
</ul>
<h3>SIMULACRO_ENTREVISTA.md</h3>
<ul>
<li>Referencias a mÃ³dulos por secciÃ³n temÃ¡tica</li>
<li>Enlaza a RECURSOS.md para mÃ¡s prÃ¡ctica</li>
</ul>
<h3>RECURSOS.md</h3>
<ul>
<li>Organizado por tema (MatemÃ¡ticas, DSA, Python)</li>
<li>URLs a cursos del Pathway</li>
</ul>
<h3>CHECKLIST.md</h3>
<ul>
<li>Referencias a todos los componentes del proyecto</li>
<li>Enlaza a RUBRICA_EVALUACION.md</li>
</ul>
<h3>RUBRICA_EVALUACION.md</h3>
<ul>
<li>Criterios que mapean a mÃ³dulos especÃ­ficos</li>
</ul>
<hr />
<h2>âœ… VerificaciÃ³n de Enlaces</h2>
<h3>Comandos para Verificar</h3>
<pre><code class="language-bash"># Verificar enlaces internos rotos
grep -r &quot;\[.*\](#mod__)&quot; guia_archimedes/*.md | \
  grep -v &quot;http&quot; | \
  while read line; do
    file=$(echo &quot;$line&quot; | cut -d: -f1)
    link=$(echo &quot;$line&quot; | grep -oP '\(.*?\.md\)' | tr -d '()')
    if [[ ! -z &quot;$link&quot; &amp;&amp; ! -f &quot;guia_archimedes/$link&quot; ]]; then
      echo &quot;BROKEN: $file -&gt; $link&quot;
    fi
  done
</code></pre>
<hr />
<h2>ğŸ—ºï¸ Flujo de NavegaciÃ³n Recomendado</h2>
<h3>Para Principiante (Ruta Completa)</h3>
<pre><code>index.md â†’ 00_INDICE.md â†’ 01 â†’ 02 â†’ 03 â†’ 04 â†’ 05 â†’ 06 â†’ 
13 â†’ 14 â†’ 15 â†’ 07 â†’ 08 â†’ 09 â†’ 16 â†’ 17 â†’ 18 â†’ 10 â†’ 11 â†’ 12
</code></pre>
<h3>Para Pathway (Solo DSA)</h3>
<pre><code>00_INDICE.md â†’ 04 â†’ 05 â†’ 13 â†’ 14 â†’ 15 â†’ 07 â†’ 08 â†’ 09 â†’ 16 â†’ 17 â†’ 18 â†’ 
SIMULACRO_ENTREVISTA.md
</code></pre>
<h3>Para Referencia RÃ¡pida</h3>
<pre><code>GLOSARIO.md (tÃ©rminos) â†’ MÃ³dulo especÃ­fico â†’ EJERCICIOS.md
</code></pre>
        </section>
        
        <div id="mod_EVALUACION_GUIA" class="cover-page">
            <a name="mod_EVALUACION_GUIA"></a>
            <div class="cover-title">EvaluaciÃ³n de la GuÃ­a</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>ğŸ“Š EvaluaciÃ³n de la GuÃ­a Archimedes Indexer</h1>
<blockquote>
<p>AnÃ¡lisis de completitud y calidad para preparaciÃ³n del Pathway MS AI Boulder.</p>
</blockquote>
<hr />
<h2>âœ… EvaluaciÃ³n por Criterio</h2>
<h3>1. Cobertura de Temas del Pathway</h3>
<table>
<thead>
<tr>
<th>Tema Pathway</th>
<th>MÃ³dulos</th>
<th>Estado</th>
</tr>
</thead>
<tbody>
<tr>
<td>Arrays y Strings</td>
<td>04</td>
<td>âœ… Completo</td>
</tr>
<tr>
<td>Hash Tables</td>
<td>05</td>
<td>âœ… Completo</td>
</tr>
<tr>
<td>Linked Lists</td>
<td>13</td>
<td>âœ… Completo</td>
</tr>
<tr>
<td>Stacks y Queues</td>
<td>13</td>
<td>âœ… Completo</td>
</tr>
<tr>
<td>Trees y BST</td>
<td>14</td>
<td>âœ… Completo</td>
</tr>
<tr>
<td>Graphs, BFS, DFS</td>
<td>15</td>
<td>âœ… Completo</td>
</tr>
<tr>
<td>Sorting (Quick, Merge)</td>
<td>08</td>
<td>âœ… Completo</td>
</tr>
<tr>
<td>Searching (Binary)</td>
<td>09</td>
<td>âœ… Completo</td>
</tr>
<tr>
<td>Recursion</td>
<td>07</td>
<td>âœ… Completo</td>
</tr>
<tr>
<td>Dynamic Programming</td>
<td>16</td>
<td>âœ… Completo</td>
</tr>
<tr>
<td>Greedy Algorithms</td>
<td>17</td>
<td>âœ… Completo</td>
</tr>
<tr>
<td>Heaps</td>
<td>18</td>
<td>âœ… Completo</td>
</tr>
<tr>
<td>Big O Analysis</td>
<td>03 + todos</td>
<td>âœ… Completo</td>
</tr>
</tbody>
</table>
<p><strong>Resultado: 13/13 temas cubiertos (100%)</strong></p>
<hr />
<h3>2. MetodologÃ­a PedagÃ³gica</h3>
<table>
<thead>
<tr>
<th>Elemento</th>
<th>Presencia</th>
<th>Calidad</th>
</tr>
</thead>
<tbody>
<tr>
<td>AnalogÃ­as visuales</td>
<td>âœ… Todos</td>
<td>Alta</td>
</tr>
<tr>
<td>ExplicaciÃ³n Feynman</td>
<td>âœ… Todos</td>
<td>Alta</td>
</tr>
<tr>
<td>CÃ³digo ejecutable</td>
<td>âœ… Todos</td>
<td>Alta</td>
</tr>
<tr>
<td>Errores comunes</td>
<td>âœ… Todos</td>
<td>Alta</td>
</tr>
<tr>
<td>Ejercicios</td>
<td>âœ… 55+</td>
<td>Alta</td>
</tr>
<tr>
<td>Recursos externos</td>
<td>âœ… Completo</td>
<td>Alta</td>
</tr>
</tbody>
</table>
<p><strong>Resultado: 6/6 elementos (100%)</strong></p>
<hr />
<h3>3. ProgresiÃ³n de Dificultad</h3>
<pre><code>NIVEL 1 - BÃ¡sico (Semanas 1-4):
â”œâ”€â”€ 01 Python Profesional    ğŸŸ¢
â”œâ”€â”€ 02 OOP desde Cero        ğŸŸ¢
â”œâ”€â”€ 03 LÃ³gica Discreta       ğŸŸ¢
â””â”€â”€ 04 Arrays y Strings      ğŸŸ¢

NIVEL 2 - Intermedio (Semanas 5-12):
â”œâ”€â”€ 05 Hash Maps             ğŸŸ¡
â”œâ”€â”€ 06 Ãndice Invertido      ğŸŸ¡
â”œâ”€â”€ 13 Linked Lists/Stacks   ğŸŸ¡
â”œâ”€â”€ 14 Trees y BST           ğŸŸ¡
â”œâ”€â”€ 07 RecursiÃ³n             ğŸŸ¡
â””â”€â”€ 09 Binary Search         ğŸŸ¡

NIVEL 3 - Avanzado (Semanas 13-20):
â”œâ”€â”€ 15 Graphs                ğŸ”´
â”œâ”€â”€ 08 Sorting               ğŸ”´
â”œâ”€â”€ 16 Dynamic Programming   ğŸ”´
â”œâ”€â”€ 17 Greedy                ğŸ”´
â”œâ”€â”€ 18 Heaps                 ğŸ”´
â””â”€â”€ 10-11 Ãlgebra/TF-IDF     ğŸ”´

NIVEL 4 - IntegraciÃ³n (Semanas 21-24):
â””â”€â”€ 12 Proyecto Integrador   ğŸ”´ğŸ”´
</code></pre>
<p><strong>Resultado: ProgresiÃ³n lÃ³gica y gradual âœ…</strong></p>
<hr />
<h3>4. Estructura de MÃ³dulos</h3>
<p>Cada mÃ³dulo contiene:</p>
<table>
<thead>
<tr>
<th>SecciÃ³n</th>
<th>Presente en</th>
</tr>
</thead>
<tbody>
<tr>
<td>Objetivo claro (ğŸ¯)</td>
<td>18/18 mÃ³dulos</td>
</tr>
<tr>
<td>AnalogÃ­a (ğŸ§ )</td>
<td>18/18 mÃ³dulos</td>
</tr>
<tr>
<td>Contenido con Ã­ndice</td>
<td>18/18 mÃ³dulos</td>
</tr>
<tr>
<td>CÃ³digo con type hints</td>
<td>18/18 mÃ³dulos</td>
</tr>
<tr>
<td>AnÃ¡lisis Big O</td>
<td>18/18 mÃ³dulos</td>
</tr>
<tr>
<td>Errores comunes (âš ï¸)</td>
<td>18/18 mÃ³dulos</td>
</tr>
<tr>
<td>Ejercicios (ğŸ”§)</td>
<td>18/18 mÃ³dulos</td>
</tr>
<tr>
<td>Recursos externos</td>
<td>18/18 mÃ³dulos</td>
</tr>
<tr>
<td>NavegaciÃ³n</td>
<td>18/18 mÃ³dulos</td>
</tr>
</tbody>
</table>
<p><strong>Resultado: Estructura consistente 100%</strong></p>
<hr />
<h3>5. Material de PrÃ¡ctica</h3>
<table>
<thead>
<tr>
<th>Tipo</th>
<th>Cantidad</th>
<th>Suficiente</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ejercicios bÃ¡sicos</td>
<td>~30</td>
<td>âœ…</td>
</tr>
<tr>
<td>Ejercicios avanzados</td>
<td>~25</td>
<td>âœ…</td>
</tr>
<tr>
<td>Preguntas simulacro</td>
<td>80</td>
<td>âœ…</td>
</tr>
<tr>
<td>Problemas de integraciÃ³n</td>
<td>10</td>
<td>âœ…</td>
</tr>
</tbody>
</table>
<p><strong>Total: ~145 ejercicios/preguntas</strong></p>
<hr />
<h3>6. Referencias y NavegaciÃ³n</h3>
<table>
<thead>
<tr>
<th>Documento</th>
<th>Referencias</th>
<th>Estado</th>
</tr>
</thead>
<tbody>
<tr>
<td>GLOSARIO.md</td>
<td>80+ tÃ©rminos</td>
<td>âœ… Completo</td>
</tr>
<tr>
<td>EJERCICIOS.md</td>
<td>Todos los mÃ³dulos</td>
<td>âœ… Completo</td>
</tr>
<tr>
<td>SIMULACRO_ENTREVISTA.md</td>
<td>5 secciones, 80 preguntas</td>
<td>âœ… Completo</td>
</tr>
<tr>
<td>RECURSOS.md</td>
<td>Cursos, libros, videos</td>
<td>âœ… Completo</td>
</tr>
<tr>
<td>REFERENCIAS_CRUZADAS.md</td>
<td>Mapa completo</td>
<td>âœ… Completo</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ¯ EvaluaciÃ³n Final</h2>
<h3>Pregunta: Â¿Puede alguien con Python bÃ¡sico aprobar el Pathway con esta guÃ­a?</h3>
<p><strong>RESPUESTA: SÃ</strong>, si sigue la guÃ­a completa, porque:</p>
<ol>
<li><strong>Fundamentos cubiertos:</strong> Desde variables hasta clases</li>
<li><strong>DSA completo:</strong> Todas las estructuras y algoritmos del Pathway</li>
<li><strong>PrÃ¡ctica suficiente:</strong> 145+ ejercicios y preguntas</li>
<li><strong>ProgresiÃ³n clara:</strong> De bÃ¡sico a avanzado en 6 meses</li>
<li><strong>Proyecto real:</strong> Demuestra dominio integrado</li>
</ol>
<h3>PuntuaciÃ³n Global</h3>
<table>
<thead>
<tr>
<th>Criterio</th>
<th>Peso</th>
<th>PuntuaciÃ³n</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cobertura de temas</td>
<td>30%</td>
<td>30/30</td>
</tr>
<tr>
<td>MetodologÃ­a pedagÃ³gica</td>
<td>25%</td>
<td>25/25</td>
</tr>
<tr>
<td>Calidad del contenido</td>
<td>25%</td>
<td>24/25</td>
</tr>
<tr>
<td>Material de prÃ¡ctica</td>
<td>10%</td>
<td>10/10</td>
</tr>
<tr>
<td>Referencias y navegaciÃ³n</td>
<td>10%</td>
<td>10/10</td>
</tr>
</tbody>
</table>
<p><strong>TOTAL: 99/100</strong> â­â­â­â­â­</p>
<hr />
<h2>ğŸ“‹ Orden Recomendado de Estudio</h2>
<h3>Orden Ã“ptimo (Diferente a NumeraciÃ³n)</h3>
<pre><code>FASE 1 - Fundamentos Python (Mes 1):
01 â†’ 02 â†’ 03 â†’ 04

FASE 2 - Estructuras BÃ¡sicas (Mes 2):
05 â†’ 06

FASE 3 - DSA Lineal (Mes 3):
13 (Linked Lists, Stacks, Queues)

FASE 4 - DSA JerÃ¡rquico (Mes 3-4):
14 (Trees) â†’ 15 (Graphs)

FASE 5 - Algoritmos (Mes 4):
07 (RecursiÃ³n) â†’ 08 (Sorting) â†’ 09 (Binary Search)

FASE 6 - OptimizaciÃ³n (Mes 5):
16 (DP) â†’ 17 (Greedy) â†’ 18 (Heaps)

FASE 7 - MatemÃ¡ticas (Mes 5):
10 (Ãlgebra) â†’ 11 (TF-IDF)

FASE 8 - IntegraciÃ³n (Mes 6):
12 (Proyecto)
</code></pre>
<p><strong>Nota:</strong> La numeraciÃ³n 13-18 despuÃ©s del 06 es intencional para agrupar DSA avanzado como bloque separado.</p>
<hr />
<h2>âš ï¸ Ãreas de Mejora Menor</h2>
<ol>
<li><strong>NumeraciÃ³n no secuencial:</strong> 13-18 despuÃ©s de 06 puede confundir</li>
<li>
<p><strong>MitigaciÃ³n:</strong> REFERENCIAS_CRUZADAS.md explica el orden</p>
</li>
<li>
<p><strong>Algunos mÃ³dulos mÃ¡s largos que otros</strong></p>
</li>
<li>
<p><strong>Aceptable:</strong> Refleja complejidad real del tema</p>
</li>
<li>
<p><strong>Proyecto no incluye Trees/Graphs directamente</strong></p>
</li>
<li><strong>Aceptable:</strong> El motor de bÃºsqueda usa las estructuras fundamentales</li>
</ol>
<hr />
<h2>ğŸš€ CertificaciÃ³n de Completitud</h2>
<p>Esta guÃ­a estÃ¡ <strong>COMPLETA Y LISTA</strong> para uso como preparaciÃ³n para:</p>
<ul>
<li>âœ… Pathway de admisiÃ³n al MS in AI de CU Boulder</li>
<li>âœ… Entrevistas tÃ©cnicas (DSA)</li>
<li>âœ… Fundamentos de Computer Science</li>
</ul>
<p><strong>Fecha de evaluaciÃ³n:</strong> Diciembre 2025<br />
<strong>VersiÃ³n:</strong> 1.0 Completa</p>
        </section>
        
        <div id="mod_DEMO_SCRIPT" class="cover-page">
            <a name="mod_DEMO_SCRIPT"></a>
            <div class="cover-title">Demo Script - Archimedes Indexer</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>ğŸš€ Demo Script - Archimedes Indexer</h1>
<blockquote>
<p>Script ejecutable para probar el motor de bÃºsqueda.</p>
</blockquote>
<hr />
<h2>ğŸ“‹ CÃ³digo de Demo Completo</h2>
<p>Copia este cÃ³digo en un archivo <code>demo.py</code> y ejecÃºtalo:</p>
<pre><code class="language-python">#!/usr/bin/env python3
&quot;&quot;&quot;
Archimedes Indexer - Demo Script
================================

Este script demuestra todas las funcionalidades del motor de bÃºsqueda
implementado desde cero sin librerÃ­as externas (excepto math).

Ejecutar: python demo.py
&quot;&quot;&quot;

import math
from collections import defaultdict
from dataclasses import dataclass, field
from typing import Iterator, NamedTuple


# ============================================================================
# DOCUMENTO Y CORPUS
# ============================================================================

@dataclass
class Document:
    &quot;&quot;&quot;Un documento indexable.&quot;&quot;&quot;
    doc_id: int
    title: str
    content: str
    tokens: list[str] = field(default_factory=list)


class Corpus:
    &quot;&quot;&quot;ColecciÃ³n de documentos.&quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self._documents: list[Document] = []
        self._id_to_index: dict[int, int] = {}

    def add(self, doc: Document) -&gt; None:
        self._id_to_index[doc.doc_id] = len(self._documents)
        self._documents.append(doc)

    def get_by_index(self, index: int) -&gt; Document:
        return self._documents[index]

    def __len__(self) -&gt; int:
        return len(self._documents)

    def __iter__(self) -&gt; Iterator[Document]:
        return iter(self._documents)


# ============================================================================
# TOKENIZER
# ============================================================================

class Tokenizer:
    &quot;&quot;&quot;Tokenizador con stop words.&quot;&quot;&quot;

    STOP_WORDS = {
        'the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been',
        'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will',
        'would', 'could', 'should', 'may', 'might', 'must', 'shall',
        'can', 'of', 'at', 'by', 'for', 'with', 'about', 'against',
        'between', 'into', 'through', 'during', 'before', 'after',
        'above', 'below', 'to', 'from', 'up', 'down', 'in', 'out',
        'on', 'off', 'over', 'under', 'again', 'further', 'then',
        'once', 'here', 'there', 'when', 'where', 'why', 'how',
        'all', 'each', 'few', 'more', 'most', 'other', 'some',
        'such', 'no', 'nor', 'not', 'only', 'own', 'same', 'so',
        'than', 'too', 'very', 'and', 'but', 'if', 'or', 'because',
        'as', 'until', 'while', 'this', 'that', 'these', 'those',
        'it', 'its'
    }

    def tokenize(self, text: str) -&gt; list[str]:
        &quot;&quot;&quot;Tokeniza texto eliminando puntuaciÃ³n y stop words.&quot;&quot;&quot;
        # Eliminar puntuaciÃ³n
        cleaned = ''
        for char in text.lower():
            if char.isalnum() or char.isspace():
                cleaned += char
            else:
                cleaned += ' '

        # Split y filtrar
        tokens = []
        for word in cleaned.split():
            if len(word) &gt; 1 and word not in self.STOP_WORDS:
                tokens.append(word)

        return tokens


# ============================================================================
# ÃNDICE INVERTIDO
# ============================================================================

class InvertedIndex:
    &quot;&quot;&quot;Ãndice invertido para bÃºsqueda rÃ¡pida.&quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self._index: dict[str, set[int]] = defaultdict(set)

    def add_document(self, doc_id: int, tokens: list[str]) -&gt; None:
        &quot;&quot;&quot;Agrega documento al Ã­ndice. O(T)&quot;&quot;&quot;
        for token in tokens:
            self._index[token].add(doc_id)

    def search_or(self, terms: list[str]) -&gt; set[int]:
        &quot;&quot;&quot;Busca documentos con ANY tÃ©rmino. O(Q)&quot;&quot;&quot;
        result: set[int] = set()
        for term in terms:
            result |= self._index.get(term, set())
        return result


# ============================================================================
# TF-IDF VECTORIZER
# ============================================================================

class TFIDFVectorizer:
    &quot;&quot;&quot;Vectorizador TF-IDF desde cero.&quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self._vocabulary: dict[str, int] = {}
        self._idf: list[float] = []

    @property
    def vocabulary_size(self) -&gt; int:
        return len(self._vocabulary)

    def fit_transform(self, corpus: list[list[str]]) -&gt; list[list[float]]:
        &quot;&quot;&quot;Construye vocabulario y transforma corpus.&quot;&quot;&quot;
        # Construir vocabulario
        vocab_set: set[str] = set()
        for doc in corpus:
            vocab_set.update(doc)

        self._vocabulary = {term: idx for idx, term in enumerate(sorted(vocab_set))}
        V = len(self._vocabulary)
        N = len(corpus)

        # Calcular DF
        df = [0] * V
        for doc in corpus:
            seen: set[str] = set()
            for term in doc:
                if term not in seen:
                    df[self._vocabulary[term]] += 1
                    seen.add(term)

        # Calcular IDF
        self._idf = [math.log(N / df[i]) if df[i] &gt; 0 else 0 for i in range(V)]

        # Transformar cada documento
        vectors = []
        for doc in corpus:
            vectors.append(self._transform_single(doc))

        return vectors

    def _transform_single(self, tokens: list[str]) -&gt; list[float]:
        &quot;&quot;&quot;Transforma un documento a vector TF-IDF.&quot;&quot;&quot;
        V = len(self._vocabulary)
        vector = [0.0] * V

        if not tokens:
            return vector

        # Calcular TF
        tf: dict[str, int] = {}
        for token in tokens:
            tf[token] = tf.get(token, 0) + 1

        total = len(tokens)

        for term, count in tf.items():
            if term in self._vocabulary:
                idx = self._vocabulary[term]
                vector[idx] = (count / total) * self._idf[idx]

        return vector

    def transform_query(self, tokens: list[str]) -&gt; list[float]:
        &quot;&quot;&quot;Transforma query a vector TF-IDF.&quot;&quot;&quot;
        return self._transform_single(tokens)


# ============================================================================
# SIMILITUD DE COSENO
# ============================================================================

def cosine_similarity(v1: list[float], v2: list[float]) -&gt; float:
    &quot;&quot;&quot;Calcula similitud de coseno entre dos vectores. O(V)&quot;&quot;&quot;
    dot = sum(a * b for a, b in zip(v1, v2))
    mag1 = math.sqrt(sum(x * x for x in v1))
    mag2 = math.sqrt(sum(x * x for x in v2))

    if mag1 == 0 or mag2 == 0:
        return 0.0

    return dot / (mag1 * mag2)


# ============================================================================
# QUICKSORT
# ============================================================================

def quicksort(items: list, key=None):
    &quot;&quot;&quot;QuickSort con soporte para key function.&quot;&quot;&quot;
    if len(items) &lt;= 1:
        return items

    if key is None:
        key = lambda x: x

    pivot = items[len(items) // 2]
    pivot_val = key(pivot)

    less = [x for x in items if key(x) &lt; pivot_val]
    equal = [x for x in items if key(x) == pivot_val]
    greater = [x for x in items if key(x) &gt; pivot_val]

    return quicksort(less, key) + equal + quicksort(greater, key)


# ============================================================================
# SEARCH ENGINE
# ============================================================================

class SearchResult(NamedTuple):
    &quot;&quot;&quot;Resultado de bÃºsqueda.&quot;&quot;&quot;
    doc_id: int
    title: str
    score: float
    snippet: str


class SearchEngine:
    &quot;&quot;&quot;Motor de bÃºsqueda completo.&quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self.corpus = Corpus()
        self.tokenizer = Tokenizer()
        self.index = InvertedIndex()
        self.vectorizer = TFIDFVectorizer()
        self._document_vectors: list[list[float]] = []
        self._indexed = False

    def add_document(self, doc_id: int, title: str, content: str) -&gt; None:
        &quot;&quot;&quot;Agrega documento al corpus.&quot;&quot;&quot;
        doc = Document(doc_id=doc_id, title=title, content=content)
        self.corpus.add(doc)
        self._indexed = False

    def build_index(self) -&gt; None:
        &quot;&quot;&quot;Construye Ã­ndice invertido y vectores TF-IDF.&quot;&quot;&quot;
        self.index = InvertedIndex()
        tokenized_docs: list[list[str]] = []

        for doc in self.corpus:
            tokens = self.tokenizer.tokenize(doc.content)
            doc.tokens = tokens
            tokenized_docs.append(tokens)
            self.index.add_document(doc.doc_id, tokens)

        self._document_vectors = self.vectorizer.fit_transform(tokenized_docs)
        self._indexed = True

    def search(self, query: str, top_k: int = 5) -&gt; list[SearchResult]:
        &quot;&quot;&quot;Busca documentos relevantes.&quot;&quot;&quot;
        if not self._indexed:
            raise RuntimeError(&quot;Debe llamar build_index() primero&quot;)

        query_tokens = self.tokenizer.tokenize(query)
        if not query_tokens:
            return []

        candidates = self.index.search_or(query_tokens)
        if not candidates:
            return []

        query_vector = self.vectorizer.transform_query(query_tokens)

        results: list[tuple[int, float]] = []
        for doc_idx, doc in enumerate(self.corpus):
            if doc.doc_id in candidates:
                score = cosine_similarity(query_vector, self._document_vectors[doc_idx])
                if score &gt; 0:
                    results.append((doc_idx, score))

        results = quicksort(results, key=lambda x: -x[1])

        search_results: list[SearchResult] = []
        for doc_idx, score in results[:top_k]:
            doc = self.corpus.get_by_index(doc_idx)
            snippet = doc.content[:100] + &quot;...&quot; if len(doc.content) &gt; 100 else doc.content
            search_results.append(SearchResult(
                doc_id=doc.doc_id,
                title=doc.title,
                score=round(score, 4),
                snippet=snippet
            ))

        return search_results


# ============================================================================
# DEMO
# ============================================================================

def main():
    print(&quot;=&quot; * 70)
    print(&quot;ğŸ” ARCHIMEDES INDEXER - DEMO&quot;)
    print(&quot;=&quot; * 70)
    print()

    # Crear motor de bÃºsqueda
    engine = SearchEngine()

    # Agregar documentos de ejemplo
    documents = [
        (1, &quot;Introduction to Python Programming&quot;,
         &quot;Python is a powerful programming language. Python is easy to learn and &quot;
         &quot;widely used in data science, web development, and artificial intelligence. &quot;
         &quot;Python has a simple syntax that is easy for beginners.&quot;),

        (2, &quot;Machine Learning Fundamentals&quot;,
         &quot;Machine learning is a subset of artificial intelligence. It enables &quot;
         &quot;computers to learn from data without being explicitly programmed. &quot;
         &quot;Common algorithms include neural networks and decision trees.&quot;),

        (3, &quot;Data Structures and Algorithms&quot;,
         &quot;Data structures like arrays, linked lists, and trees are fundamental &quot;
         &quot;in computer science. Algorithms such as sorting and searching are &quot;
         &quot;essential for efficient programming.&quot;),

        (4, &quot;Web Development with JavaScript&quot;,
         &quot;JavaScript is the language of the web. It enables interactive websites &quot;
         &quot;and runs in all modern browsers. Node.js allows JavaScript on servers.&quot;),

        (5, &quot;Deep Learning and Neural Networks&quot;,
         &quot;Deep learning uses neural networks with many layers. It has revolutionized &quot;
         &quot;artificial intelligence, enabling breakthroughs in image recognition, &quot;
         &quot;natural language processing, and autonomous vehicles.&quot;),

        (6, &quot;Python for Data Science&quot;,
         &quot;Python is the most popular language for data science. Libraries like &quot;
         &quot;pandas and numpy make data analysis easy. Python is also used for &quot;
         &quot;machine learning with scikit-learn and tensorflow.&quot;),

        (7, &quot;Algorithms for Searching and Sorting&quot;,
         &quot;Searching algorithms like binary search find elements efficiently. &quot;
         &quot;Sorting algorithms like quicksort and mergesort organize data. &quot;
         &quot;Understanding Big O notation is crucial for algorithm analysis.&quot;),
    ]

    print(&quot;ğŸ“š Agregando documentos...&quot;)
    for doc_id, title, content in documents:
        engine.add_document(doc_id, title, content)
        print(f&quot;   + [{doc_id}] {title}&quot;)

    print()
    print(&quot;âš™ï¸  Construyendo Ã­ndice...&quot;)
    engine.build_index()
    print(f&quot;   âœ“ Ãndice construido: {engine.vectorizer.vocabulary_size} tÃ©rminos Ãºnicos&quot;)
    print()

    # Realizar bÃºsquedas
    queries = [
        &quot;python programming&quot;,
        &quot;machine learning artificial intelligence&quot;,
        &quot;sorting algorithms&quot;,
        &quot;web development&quot;,
        &quot;neural networks deep learning&quot;,
    ]

    for query in queries:
        print(&quot;-&quot; * 70)
        print(f&quot;ğŸ” QUERY: \&quot;{query}\&quot;&quot;)
        print(&quot;-&quot; * 70)

        results = engine.search(query, top_k=3)

        if results:
            for i, result in enumerate(results, 1):
                print(f&quot;\n   {i}. {result.title}&quot;)
                print(f&quot;      Score: {result.score:.4f}&quot;)
                print(f&quot;      Preview: {result.snippet[:80]}...&quot;)
        else:
            print(&quot;   No se encontraron resultados.&quot;)

        print()

    print(&quot;=&quot; * 70)
    print(&quot;âœ… Demo completado!&quot;)
    print(&quot;=&quot; * 70)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<hr />
<h2>ğŸ–¥ï¸ Salida Esperada</h2>
<pre><code>======================================================================
ğŸ” ARCHIMEDES INDEXER - DEMO
======================================================================

ğŸ“š Agregando documentos...
   + [1] Introduction to Python Programming
   + [2] Machine Learning Fundamentals
   + [3] Data Structures and Algorithms
   + [4] Web Development with JavaScript
   + [5] Deep Learning and Neural Networks
   + [6] Python for Data Science
   + [7] Algorithms for Searching and Sorting

âš™ï¸  Construyendo Ã­ndice...
   âœ“ Ãndice construido: 89 tÃ©rminos Ãºnicos

----------------------------------------------------------------------
ğŸ” QUERY: &quot;python programming&quot;
----------------------------------------------------------------------

   1. Introduction to Python Programming
      Score: 0.4523
      Preview: Python is a powerful programming language. Python is easy to learn...

   2. Python for Data Science
      Score: 0.2187
      Preview: Python is the most popular language for data science. Libraries like...

----------------------------------------------------------------------
ğŸ” QUERY: &quot;machine learning artificial intelligence&quot;
----------------------------------------------------------------------

   1. Machine Learning Fundamentals
      Score: 0.4891
      Preview: Machine learning is a subset of artificial intelligence. It enables...

   2. Deep Learning and Neural Networks
      Score: 0.3456
      Preview: Deep learning uses neural networks with many layers. It has revolut...
</code></pre>
<hr />
<h2>ğŸ“ Notas</h2>
<ul>
<li>Este script es <strong>100% Python puro</strong> (solo usa <code>math</code> de la stdlib)</li>
<li>Demuestra todos los componentes del proyecto integrador</li>
<li>Puedes modificar los documentos y queries para experimentar</li>
</ul>
        </section>
        
        <div id="mod_MAINTENANCE_GUIDE" class="cover-page">
            <a name="mod_MAINTENANCE_GUIDE"></a>
            <div class="cover-title">GuÃ­a de Mantenimiento</div>
            <div class="cover-subtitle">GuÃ­a Archimedes Indexer</div>
            <div class="cover-meta">DUQUEOM Â· 2025</div>
        </div>
        <section>
            <h1>ğŸ”„ GuÃ­a de Mantenimiento</h1>
<blockquote>
<p>CÃ³mo mantener y actualizar la guÃ­a Archimedes Indexer.</p>
</blockquote>
<hr />
<h2>ğŸ“… Calendario de Mantenimiento</h2>
<h3>Mensual</h3>
<ul>
<li>[ ] Verificar que todos los links externos funcionan</li>
<li>[ ] Revisar si hay nuevos recursos relevantes</li>
<li>[ ] Actualizar RECURSOS.md si hay cursos nuevos</li>
</ul>
<h3>Trimestral</h3>
<ul>
<li>[ ] Revisar que el cÃ³digo de ejemplo sigue funcionando</li>
<li>[ ] Actualizar versiones de Python si hay nueva LTS</li>
<li>[ ] Revisar feedback de usuarios (si hay)</li>
</ul>
<h3>Semestral</h3>
<ul>
<li>[ ] Revisar cambios en Pathway de CU Boulder</li>
<li>[ ] Actualizar SIMULACRO_ENTREVISTA.md con nuevas preguntas</li>
<li>[ ] Verificar que herramientas recomendadas siguen activas</li>
</ul>
<hr />
<h2>ğŸ” VerificaciÃ³n de la GuÃ­a</h2>
<h3>Script de VerificaciÃ³n de Links</h3>
<pre><code class="language-bash">#!/bin/bash
# check_links.sh

echo &quot;Checking internal links...&quot;
grep -r &quot;\[.*\](#mod__)&quot; guia_archimedes/*.md | while read line; do
    file=$(echo &quot;$line&quot; | cut -d: -f1)
    link=$(echo &quot;$line&quot; | grep -oP '\(.*?\.md\)' | tr -d '()')
    if [[ ! -z &quot;$link&quot; &amp;&amp; ! -f &quot;guia_archimedes/$link&quot; ]]; then
        echo &quot;BROKEN: $file -&gt; $link&quot;
    fi
done

echo &quot;Done!&quot;
</code></pre>
<h3>VerificaciÃ³n de Estructura</h3>
<pre><code class="language-bash"># Verificar que todos los mÃ³dulos existen
for i in {01..12}; do
    if [[ ! -f &quot;guia_archimedes/${i}_*.md&quot; ]]; then
        echo &quot;MISSING: MÃ³dulo $i&quot;
    fi
done

# Verificar documentos auxiliares
for doc in EJERCICIOS EJERCICIOS_SOLUCIONES GLOSARIO RUBRICA_EVALUACION CHECKLIST RECURSOS SIMULACRO_ENTREVISTA; do
    if [[ ! -f &quot;guia_archimedes/${doc}.md&quot; ]]; then
        echo &quot;MISSING: $doc.md&quot;
    fi
done
</code></pre>
<hr />
<h2>ğŸ“ Estructura de un MÃ³dulo</h2>
<p>Cada mÃ³dulo debe seguir esta estructura:</p>
<pre><code class="language-markdown"># XX - TÃ­tulo del MÃ³dulo

&gt; **ğŸ¯ Objetivo:** [DescripciÃ³n en una lÃ­nea]

---

## ğŸ§  AnalogÃ­a: [Nombre]

[Diagrama ASCII y explicaciÃ³n]

---

## ğŸ“‹ Contenido

1. [SecciÃ³n 1](#1-seccion)
2. [SecciÃ³n 2](#2-seccion)
...

---

## 1. SecciÃ³n {#1-seccion}

### 1.1 SubsecciÃ³n

[Contenido con cÃ³digo, tablas, diagramas]

---

## âš ï¸ Errores Comunes

[Lista de errores tÃ­picos]

---

## ğŸ”§ Ejercicios PrÃ¡cticos

### Ejercicio X.1
Ver [EJERCICIOS.md](#mod_EJERCICIOS)

---

## ğŸ“š Recursos Externos

| Recurso | Tipo | Prioridad |
|---------|------|-----------|
| [...] | ... | ğŸ”´/ğŸŸ¡/ğŸŸ¢ |

---

## ğŸ”— Referencias del Glosario

- [TÃ©rmino](#mod_GLOSARIO)

---

## ğŸ§­ NavegaciÃ³n

| â† Anterior | Ãndice | Siguiente â†’ |
|------------|--------|-------------|
| [XX_ANTERIOR](#mod_XX_ANTERIOR) | [00_INDICE](#mod_00_INDICE) | [XX_SIGUIENTE](#mod_XX_SIGUIENTE) |
</code></pre>
<hr />
<h2>ğŸ†• Agregar Nuevo Contenido</h2>
<h3>Nuevo Ejercicio</h3>
<ol>
<li>Agregar en <code>EJERCICIOS.md</code> en la secciÃ³n del mÃ³dulo correspondiente</li>
<li>Agregar soluciÃ³n en <code>EJERCICIOS_SOLUCIONES.md</code></li>
<li>Actualizar el Ã­ndice al inicio de ambos archivos</li>
</ol>
<h3>Nuevo TÃ©rmino en Glosario</h3>
<ol>
<li>Agregar en orden alfabÃ©tico en <code>GLOSARIO.md</code></li>
<li>Seguir formato:<br />
<code>markdown
   ### TÃ©rmino
   **DefiniciÃ³n:** [DefiniciÃ³n tÃ©cnica]
   **AnalogÃ­a:** [ExplicaciÃ³n simple]
   **Ejemplo:** [CÃ³digo o caso de uso]</code></li>
</ol>
<h3>Nueva Pregunta en Simulacro</h3>
<ol>
<li>Agregar en secciÃ³n correspondiente de <code>SIMULACRO_ENTREVISTA.md</code></li>
<li>Actualizar conteo total en encabezado</li>
<li>Incluir respuesta detallada</li>
</ol>
<hr />
<h2>ğŸ¨ Convenciones de Estilo</h2>
<h3>Iconos</h3>
<table>
<thead>
<tr>
<th>Icono</th>
<th>Uso</th>
</tr>
</thead>
<tbody>
<tr>
<td>ğŸ¯</td>
<td>Objetivo</td>
</tr>
<tr>
<td>ğŸ§ </td>
<td>AnalogÃ­a/Concepto</td>
</tr>
<tr>
<td>ğŸ“‹</td>
<td>Ãndice/Lista</td>
</tr>
<tr>
<td>âš ï¸</td>
<td>Advertencia</td>
</tr>
<tr>
<td>ğŸ’¡</td>
<td>Tip</td>
</tr>
<tr>
<td>âœ…</td>
<td>Correcto/Buena prÃ¡ctica</td>
</tr>
<tr>
<td>âŒ</td>
<td>Incorrecto/Anti-patrÃ³n</td>
</tr>
<tr>
<td>ğŸ”§</td>
<td>Ejercicio prÃ¡ctico</td>
</tr>
<tr>
<td>ğŸ“š</td>
<td>Recursos externos</td>
</tr>
<tr>
<td>ğŸ”—</td>
<td>Referencia cruzada</td>
</tr>
<tr>
<td>ğŸ§­</td>
<td>NavegaciÃ³n</td>
</tr>
</tbody>
</table>
<h3>CÃ³digo</h3>
<ul>
<li>Usar Python 3.11+ syntax</li>
<li>Incluir type hints siempre</li>
<li>Agregar docstrings en ejemplos largos</li>
<li>Marcar cÃ³digo malo con <code># âŒ</code> y bueno con <code># âœ…</code></li>
</ul>
<h3>Tablas</h3>
<ul>
<li>Usar para comparaciones, Ã­ndices, referencias</li>
<li>Mantener columnas alineadas</li>
<li>Primera columna descriptiva</li>
</ul>
<hr />
<h2>ğŸ“Š MÃ©tricas de Calidad</h2>
<h3>Completitud</h3>
<ul>
<li>[ ] 12 mÃ³dulos (01-12)</li>
<li>[ ] Ãndice principal (00_INDICE.md)</li>
<li>[ ] SYLLABUS y PLAN_ESTUDIOS</li>
<li>[ ] Documentos auxiliares completos</li>
</ul>
<h3>Consistencia</h3>
<ul>
<li>[ ] Todos los mÃ³dulos siguen la estructura</li>
<li>[ ] Links internos funcionan</li>
<li>[ ] NumeraciÃ³n correcta</li>
</ul>
<h3>Claridad</h3>
<ul>
<li>[ ] Cada mÃ³dulo tiene objetivo claro</li>
<li>[ ] AnalogÃ­as ayudan a entender</li>
<li>[ ] CÃ³digo es ejecutable</li>
</ul>
<hr />
<h2>ğŸ› Reporte de Errores</h2>
<p>Si encuentras un error:</p>
<ol>
<li>Identifica el archivo y lÃ­nea</li>
<li>Describe el problema</li>
<li>PropÃ³n correcciÃ³n si es posible</li>
<li>Actualiza el archivo directamente</li>
</ol>
<hr />
<h2>ğŸ“ Estructura de Archivos</h2>
<pre><code>guia_archimedes/
â”œâ”€â”€ index.md                           # Landing page
â”œâ”€â”€ 00_INDICE.md                       # Ãndice principal
â”œâ”€â”€ SYLLABUS.md                        # Programa del curso
â”œâ”€â”€ PLAN_ESTUDIOS.md                   # Cronograma dÃ­a a dÃ­a
â”‚
â”œâ”€â”€ # MÃ“DULOS FUNDAMENTALES (01-06)
â”œâ”€â”€ 01_PYTHON_PROFESIONAL.md           # Type hints, PEP8
â”œâ”€â”€ 02_OOP_DESDE_CERO.md               # Clases, SOLID
â”œâ”€â”€ 03_LOGICA_DISCRETA.md              # Big O, conjuntos
â”œâ”€â”€ 04_ARRAYS_STRINGS.md               # Listas, slicing
â”œâ”€â”€ 05_HASHMAPS_SETS.md                # Diccionarios, hashing
â”œâ”€â”€ 06_INVERTED_INDEX.md               # Ãndice invertido
â”‚
â”œâ”€â”€ # MÃ“DULOS DSA AVANZADO (13-15) â­ PATHWAY
â”œâ”€â”€ 13_LINKED_LISTS_STACKS_QUEUES.md   # Estructuras lineales
â”œâ”€â”€ 14_TREES.md                        # BST, traversals
â”œâ”€â”€ 15_GRAPHS.md                       # BFS, DFS
â”‚
â”œâ”€â”€ # MÃ“DULOS ALGORITMOS (07-09, 16-18) â­ PATHWAY
â”œâ”€â”€ 07_RECURSION.md                    # Divide &amp; conquer
â”œâ”€â”€ 08_SORTING.md                      # QuickSort, MergeSort
â”œâ”€â”€ 09_BINARY_SEARCH.md                # BÃºsqueda binaria
â”œâ”€â”€ 16_DYNAMIC_PROGRAMMING.md          # DP, memoization
â”œâ”€â”€ 17_GREEDY.md                       # Greedy algorithms
â”œâ”€â”€ 18_HEAPS.md                        # Priority queues
â”‚
â”œâ”€â”€ # MÃ“DULOS MATEMÃTICAS (10-11)
â”œâ”€â”€ 10_ALGEBRA_LINEAL.md               # Vectores, matrices
â”œâ”€â”€ 11_TFIDF_COSENO.md                 # TF-IDF, coseno
â”‚
â”œâ”€â”€ # PROYECTO INTEGRADOR
â”œâ”€â”€ 12_PROYECTO_INTEGRADOR.md          # Motor de bÃºsqueda
â”‚
â”œâ”€â”€ # DOCUMENTOS AUXILIARES
â”œâ”€â”€ EJERCICIOS.md                      # 55+ ejercicios
â”œâ”€â”€ EJERCICIOS_SOLUCIONES.md           # Soluciones
â”œâ”€â”€ GLOSARIO.md                        # 80+ tÃ©rminos A-Z
â”œâ”€â”€ RUBRICA_EVALUACION.md              # Criterios (100 pts)
â”œâ”€â”€ CHECKLIST.md                       # VerificaciÃ³n final
â”œâ”€â”€ RECURSOS.md                        # Cursos, libros
â”œâ”€â”€ SIMULACRO_ENTREVISTA.md            # 80 preguntas Pathway
â”œâ”€â”€ DECISIONES_TECH.md                 # ADRs del proyecto
â”œâ”€â”€ REFERENCIAS_CRUZADAS.md            # Mapa de navegaciÃ³n
â”œâ”€â”€ EVALUACION_GUIA.md                 # AutoevaluaciÃ³n
â””â”€â”€ MAINTENANCE_GUIDE.md               # Esta guÃ­a
</code></pre>
<p><strong>Total: 33 archivos</strong></p>
<hr />
<p><strong>Ãšltima actualizaciÃ³n:</strong> Diciembre 2025</p>
        </section>
        
</body>
</html>
